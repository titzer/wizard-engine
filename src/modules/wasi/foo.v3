def S: SigCache;
def map = Strings.newMap<HostAdapter2_of<WasiInstance2>>();

def i_i = 			Wasi2_HostAdapter<int, int>.new(_, HostAdapters.i_i, _);
def i_v =			Wasi2_HostAdapter<int, void>.new(_, HostAdapters.i_v, _);
def ii_i = 			Wasi2_HostAdapter<(int, int), int>.new(_, HostAdapters.ii_i, _);
def iii_i = 		Wasi2_HostAdapter<(int, int, int), int>.new(_, HostAdapters.iii_i, _);
def iiii_i = 		Wasi2_HostAdapter<(int, int, int, int), int>.new(_, HostAdapters.iiii_i, _);
def iiiii_i = 		Wasi2_HostAdapter<(int, int, int, int, int), int>.new(_, HostAdapters.iiiii_i, _);
def iiiiii_i = 		Wasi2_HostAdapter<(int, int, int, int, int, int), int>.new(_, HostAdapters.iiiiii_i, _);
def iiiiiii_i = 	Wasi2_HostAdapter<(int, int, int, int, int, int, int), int>.new(_, HostAdapters.iiiiiii_i, _);
def iiiiillii_i =	Wasi2_HostAdapter<(int, int, int, int, int, long, long, int, int), int>.new(_, HostAdapters.iiiiillii_i, _);
def iiiilli_i = 	Wasi2_HostAdapter<(int, int, int, int, long, long, int), int>.new(_, HostAdapters.iiiilli_i, _);
def iiili_i = 		Wasi2_HostAdapter<(int, int, int, long, int), int>.new(_, HostAdapters.iiili_i, _);
def il_i = 			Wasi2_HostAdapter<(int, long), int>.new(_, HostAdapters.il_i, _);
def ili_i = 		Wasi2_HostAdapter<(int, long, int), int>.new(_, HostAdapters.ili_i, _);
def ilii_i =		Wasi2_HostAdapter<(int, long, int, int), int>.new(_, HostAdapters.ilii_i, _);
def ill_i = 		Wasi2_HostAdapter<(int, long, long), int>.new(_, HostAdapters.ill_i, _);
def illi_i = 		Wasi2_HostAdapter<(int, long, long, int), int>.new(_, HostAdapters.illi_i, _);
def v_i = 			Wasi2_HostAdapter<void, int>.new(_, HostAdapters.v_i, _);

var x_ = void(
	map["args_get"] =				ii_i(		fun i => i.args_get, true),
	map["args_sizes_get"] = 		ii_i(		fun i => i.args_sizes_get, true),
	map["environ_get"] =			ii_i(		fun i => i.environ_get, true),
	map["environ_sizes_get"] =		ii_i(		fun i => i.environ_sizes_get, true),
	map["fd_advise"] =				illi_i(		fun i => i.fd_advise, true),
	map["fd_allocate"] =			ill_i(		fun i => i.fd_allocate, true),
	map["fd_close"] =				i_i(		fun i => i.fd_close, true),
	map["fd_datasync"] =			i_i(		fun i => i.fd_datasync, true),
	map["fd_fdstat_get"] =			ii_i(		fun i => i.fd_fdstat_get, true),
	map["fd_fdstat_set_flags"] =	ii_i(		fun i => i.fd_fdstat_set_flags, true),
	map["fd_fdstat_set_rights"] =	ill_i(		fun i => i.fd_fdstat_set_rights, true),
	map["fd_filestat_get"] =		ii_i(		fun i => i.fd_filestat_get, true),
	map["fd_filestat_set_size"] =	il_i(		fun i => i.fd_filestat_set_size, true),
	map["fd_filestat_set_times"] =	illi_i(		fun i => i.fd_filestat_set_times, true),
	map["fd_pread"] =				iiili_i(	fun i => i.fd_pread, true),
	map["fd_prestat_get"] =			ii_i(		fun i => i.fd_prestat_get, true),
	map["fd_prestat_dir_name"] =	iii_i(		fun i => i.fd_prestat_dir_name, true),
	map["fd_pwrite"] =				iiili_i(	fun i => i.fd_pwrite, true),
	map["fd_read"] =				iiii_i(		fun i => i.fd_read, true),
	map["fd_readdir"] =				iiili_i(	fun i => i.fd_readdir, true),
	map["fd_renumber"] =			ii_i(		fun i => i.fd_renumber, true),
	map["fd_seek"] =				ilii_i(		fun i => i.fd_seek, true),
	map["fd_sync"] =				i_i(		fun i => i.fd_sync, true),
	map["fd_tell"] =				ii_i(		fun i => i.fd_tell, true),
	map["fd_write"] =				iiii_i(		fun i => i.fd_write, true),
	map["path_create_directory"] =	iii_i(		fun i => i.path_create_directory, true),
	map["path_filestat_get"] =		iiiii_i(	fun i => i.path_filestat_get, true),
	map["path_filestat_set_times"] =iiiilli_i(	fun i => i.path_filestat_set_times, true),
	map["path_link"] =				iiiiiii_i(	fun i => i.path_link, true),
	map["path_open"] =				iiiiillii_i(fun i => i.path_open, true),
	map["path_readlink"] =			iiiiii_i(	fun i => i.path_readlink, true),
	map["path_remove_directory"] =	iii_i(		fun i => i.path_remove_directory, true),
	map["path_rename"] =			iiiiii_i(	fun i => i.path_rename, true),
	map["path_symlink"] =			iiiii_i(	fun i => i.path_symlink, true),
	map["path_unlink_file"] =		iii_i(		fun i => i.path_unlink_file, true),
	map["clock_res_get"] =			ii_i(		fun i => i.clock_res_get, true),
	map["clock_time_get"] =			ili_i(		fun i => i.clock_time_get, true),
	map["sched_yield"] =			v_i(		fun i => i.sched_yield, true),
	map["proc_exit"] =				i_v(		fun i => i.proc_exit, true),
	map["proc_raise"] =				i_i(		fun i => i.proc_raise, true),
	map["poll_oneoff"] =			iiii_i(		fun i => i.poll_oneoff, true),
	map["random_get"] =				ii_i(		fun i => i.random_get, true),
	map["sock_recv"] =				iiiiii_i(	fun i => i.sock_recv, true),
	map["sock_send"] =				iiiii_i(	fun i => i.sock_send, true),
	map["sock_shutdown"] =			ii_i(		fun i => i.sock_shutdown, true),
	map["sock_accept"] =			iii_i(		fun i => i.sock_accept, true),
	()
);

class HostAdapter2_of<I> {
	def sig: SigDecl;
	def func(name: string, i: I) -> HostFunction;
}

class Wasi2_HostAdapter<P, R>(f: WasiInstance2 -> P -> R, adapter: (P -> R) -> HostFunc, implemented: bool) extends HostAdapter2_of<WasiInstance2> {
	def func(name: string, i: WasiInstance2) -> HostFunction {
		var g = f(i);
		def host_func = adapter(g);
		if (i.isTargetSpecific && implemented) {
			return HostFunction.new(name, host_func.sig, host_func.invoke);
		} else {
			return HostFunction.new(name, host_func.sig, this.UNIMPLEMENTED);
		}
	}

	def UNIMPLEMENTED(args: Range<Value>) => HostResult.Throw(Trap.new(TrapReason.UNIMPLEMENTED, null, null));
}

class WspOneModule2(instance: WasiInstance2) extends HostModule("wasi_snapshot_preview1b") {
	def preprocess(error: ErrorGen, module: Module, result: Array<Exportable>) {
		var imports = module.imports;
		for (j < imports.length) {
			var i = imports[j];
			if (!Strings.equal(this.name, i.imp.module_name)) continue;
			if (!FuncDecl.?(i)) continue;
			var impf = FuncDecl.!(i), name = i.imp.field_name;
			var t = map[name];
			if (t == null) continue;
			result[j] = t.func(name, instance);
		}
	}
}

// Enforces ordering on installation of platform-specific modules.
component WspOneRegistration2 {
	def X_ = ModuleRegistry.add(WspOneModule2.new(WasiInstance2.new(false)), true); // register platform-independent first
	def register(w: WspOneModule2) {
		// Platform-specific module should call this method to ensure ordering.
		ModuleRegistry.add(w, true);
	}
}

// Contains state and logic for a WASI instance.
class WasiInstance2(isTargetSpecific: bool) {
	var fdmap: WasiFdMap;
	var memory: Memory;
	var cmdline_args: Array<string>;

	// Utility functions for subclasses.
	def getRegion(idx: u32, size: u32) -> i64 {
		if (memory == null) return -1;
		return memory.boundsCheck(0, idx, size);
	}

	def args_get(argv: int, argvbuf: int) -> int {
		var arg = getRegion(u32.view(argv), u32.view(cmdline_args.length) * 4);
		if (arg < 0) return WspOneErrno.INVAL.code;
		var size = 0u;
		for (a in cmdline_args) size += (1u + u32.view(a.length));
		var argbuf = getRegion(u32.view(argvbuf), size);
		if (argbuf < 0) return WspOneErrno.INVAL.code;
		for (i < cmdline_args.length) {
			// write a pointer to a null-terminated string into a arg buffer
			memory.write_u32(u32.view(arg), 0, u32.view(argbuf));
			arg += 4;
			// write a null-terminated string into argvbuf buffer
			var a = cmdline_args[i];
			memory.copyIn(u32.view(argbuf), a, 0, u32.view(a.length));
			argbuf += u32.view(a.length);
			memory.write_u8(u32.view(argbuf), 0, 0);
			argbuf++;
		}
		return WspOneErrno.SUCCESS.code;
	}
	def args_sizes_get(argc: int, argv_buf_size: int) -> int {
		var argptr = getRegion(u32.view(argc), 4);
		if (argptr < 0) return WspOneErrno.INVAL.code;
		var size = 0;
		for (a in cmdline_args) size += (1 + a.length);
		var bufptr = getRegion(u32.view(argv_buf_size), 4);
		if (bufptr < 0) return WspOneErrno.INVAL.code;
		memory.write_u32(u32.view(argptr), 0, u32.view(cmdline_args.length));
		memory.write_u32(u32.view(bufptr), 0, u32.view(size));
		return WspOneErrno.SUCCESS.code;
	}
	def environ_get(environ: int, environ_buf: int) -> int {
		def envs = WasiOptions.envs;
		var environ = getRegion(u32.view(environ), u32.view(envs.length) * 4);
		if (environ < 0) return WspOneErrno.INVAL.code;
		var size = 0u;
		for (i < envs.length) size += (1u + u32.view(envs[i].length));
		var environ_buf = getRegion(u32.view(environ_buf), size);
		if (environ_buf < 0) return WspOneErrno.INVAL.code;
		for (i < envs.length) {
			// write a pointer to a null-terminated string into an environ buffer
			memory.write_u32(u32.view(environ), 0, u32.view(environ_buf));
			environ += 4;
			// write a null-terminated string into a environ_buf buffer
			var e = envs[i];
			memory.copyIn(u32.view(environ_buf), e, 0, u32.view(e.length));
			environ_buf += u32.view(e.length);
			memory.write_u8(u32.view(environ_buf), 0, 0);
			environ_buf++;
		}

		return WspOneErrno.SUCCESS.code;
	 }
	def environ_sizes_get(environ_count: int, environ_buf_size: int) -> int {
		def envs = WasiOptions.envs;
		var argptr = getRegion(u32.view(environ_count), 4);
		if (argptr < 0) return WspOneErrno.INVAL.code;
		var size = 0;
		for (i < envs.length) size += (1 + envs[i].length);
		var bufptr = getRegion(u32.view(environ_buf_size), 4);
		if (bufptr < 0) return WspOneErrno.INVAL.code;
		memory.write_u32(u32.view(argptr), 0, u32.view(envs.length));
		memory.write_u32(u32.view(bufptr), 0, u32.view(size));

		return WspOneErrno.SUCCESS.code;
	 }
	def fd_advise(fd: int, offset: long, len: long, advice: int) -> int;
	def fd_allocate(fd: int, offset: long, len: long) -> int;
	def fd_close(fd: int) -> int {
		var wfd = fdmap.get(fd);
		if (wfd != null) System.fileClose(wfd.sysfd);
		var r = fdmap.free(fd);
		return if(r >= 0, 0, WspOneErrno.INVAL.code);
	}
	def fd_datasync(fd: int) -> int;
	def fd_fdstat_get(fd: int, buf_ptr: int) -> int { return 0; }
	def fd_fdstat_set_flags(fd: int, flags: int) -> int;
	def fd_fdstat_set_rights(fd: int, fs_rights_base: long, fs_rights_inheriting: long) -> int;
	def fd_filestat_get(fd: int, buf: int) -> int;
	def fd_filestat_set_size(fd: int, st_size: long) -> int;
	def fd_filestat_set_times(fd: int, st_atim: long, st_mtim: long, fst_flags: int) -> int;
	def fd_pread(fd: int, iovs: int, iovs_len: int, offset: long, nread: int) -> int;
	def fd_prestat_get(fd: int, buf: int) -> int {
		def wfd = fdmap.get(fd);
		if (wfd == null || !wfd.preopen) return WspOneErrno.BADF.code;
		
		def bufptr = getRegion(u32.view(buf), 4);
		if (bufptr < 0) return WspOneErrno.INVAL.code;
		memory.write_u32(u32.view(bufptr), 0, u32.view(PreopenType.Dir.code));
		memory.write_u32(u32.view(bufptr), 4, u32.view(wfd.path.length));

		return WspOneErrno.SUCCESS.code;
	}
	def fd_prestat_dir_name(fd: int, path: int, path_len: int) -> int {
		def wfd = fdmap.get(fd);
		if (wfd == null || !wfd.preopen) return WspOneErrno.BADF.code;

		def pathptr = getRegion(u32.view(path), u32.view(path_len));
		if (pathptr < 0) return WspOneErrno.INVAL.code;

		// write a directory name into a buffer
		memory.copyIn(u32.view(pathptr), wfd.path, 0, u32.!(wfd.path.length));

		return WspOneErrno.SUCCESS.code;
	}
	def fd_pwrite(fd: int, iovs: int, iovs_len: int, offset: long, nwritten: int) -> int;
	def fd_read(fd: int, iovs_ptr: int, iovs_len: int, outsize_ptr: int) -> int {
		var wfd = fdmap.get(fd);
		if (wfd == null) return WspOneErrno.BADF.code;
		var iovbuf = getRegion(u32.view(iovs_ptr), u32.view(iovs_len * 8));
		if (iovbuf < 0) return WspOneErrno.INVAL.code; // Invalid memory

		var outsize_buf = getRegion(u32.view(outsize_ptr), 4);
		if (outsize_buf < 0) return WspOneErrno.INVAL.code; // Invalid memory
		
		var total = 0;
		for (j < iovs_len) {
			var iov_ptr = memory.read_u32(0, u32.view(iovbuf)).result;
			var iov_len = memory.read_u32(0, u32.view(iovbuf + 4)).result;
			var iobuf = getRegion(iov_ptr, iov_len);
			if (iobuf < 0) return WspOneErrno.INVAL.code; // Invalid memory
			var out = memory.readIn(wfd.sysfd, u32.view(iobuf), iov_len);
			if (out < 0) return WspOneErrno.IO.code;
			total += out;
			iovbuf += 8;
		}

		memory.write_u32(u32.view(outsize_ptr), 0, u32.view(total));
		return WspOneErrno.SUCCESS.code;
	}
	def fd_readdir(fd: int, buf: int, buf_len: int, cookie: long, bufused: int) -> int;
	def fd_renumber(from: int, to: int) -> int;
	def fd_seek(fd: int, offset: long, whence: int, newoffset: int) -> int;
	def fd_sync(fd: int) -> int;
	def fd_tell(fd: int, offset: int) -> int;
	def fd_write(fd: int, iovs_ptr: int, iovs_len: int, outsize_ptr: int) -> int {
		var wfd = fdmap.get(fd);
		if (wfd == null) return WspOneErrno.BADF.code;
		var iovbuf = getRegion(u32.view(iovs_ptr), u32.view(iovs_len * 8));
		if (iovbuf < 0) return WspOneErrno.INVAL.code; // Invalid memory
		var outsize_buf = getRegion(u32.view(outsize_ptr), 4);
		if (outsize_buf < 0) return WspOneErrno.INVAL.code;

		var total = 0;
		for (j < iovs_len) {
			var iov_ptr = memory.read_u32(0, u32.view(iovbuf)).result;
			var iov_len = memory.read_u32(0, u32.view(iovbuf + 4)).result;
			var iobuf = getRegion(u32.view(iov_ptr), iov_len);
			if (iobuf < 0) return WspOneErrno.INVAL.code; // Invalid memory
			var out = memory.writeOut(wfd.sysfd, u32.view(iobuf), iov_len);
			if (out < 0) return WspOneErrno.IO.code;
			total += out;
			iovbuf += 8;
		}
		memory.write_u32(u32.view(outsize_ptr), 0, u32.view(total));
		return WspOneErrno.SUCCESS.code;
	}
	def path_create_directory(fd: int, path: int, path_len: int) -> int;
	def path_filestat_get(fd: int, flags: int, path: int, path_len: int, buf: int) -> int;
	def path_filestat_set_times(fd: int, flags: int, path: int, path_len: int, st_atim: long, st_mtim: long, fst_flags: int) -> int;
	def path_link(old_fd: int, old_flags: int, old_path: int, old_path_len: int, new_fd: int, new_path: int, new_path_len: int) -> int;
	def path_open(dirfd: int, dirflags: int, path: int, path_len: int, o_flags: int, fs_rights_base: long, fs_rights_inheriting: long, fs_flags: int, fd: int) -> int;
	def path_readlink(dir_fd: int, path: int, path_len: int, buf: int, buf_len: int, buf_used: int) -> int;
	def path_remove_directory(fd: int, path: int, path_len: int) -> int;
	def path_rename(old_fd: int, old_path: int, old_path_len: int, new_fd: int, new_path: int, new_path_len: int) -> int;
	def path_symlink(old_path: int, old_path_len: int, fd: int, new_path: int, new_path_len: int) -> int;
	def path_unlink_file(fd: int, path: int, path_len: int) -> int;
	def clock_res_get(clock_id: int, resolution: int) -> int;
	def clock_time_get(clock_id: int, precision: long, time: int) -> int;
	def sched_yield() -> int;
	// TODO: handle proc_exit
	// def proc_exit(code: int) {
	// 	return HostResult.Throw(Exit.new(Values.unbox_u(args[0])));
	// }
	def proc_exit(code: int);
	def proc_raise(sig: int) -> int;
	def poll_oneoff(in_: int, out_: int, nsubscriptions: int, nevents: int) -> int;
	// TODO: handle random_get
	// def random_get(ptr: int, len: int) -> int {
	// 	var range = memory.range_ol_32(ptr, len);
	// 	if (range.reason != TrapReason.NONE) return HostResult.Throw(Trap.new(range.reason, null, null));
	// 	if (WasiOptions.random_seed != 0) return prng_random_get(range.result);
	// 	else return host_random_get(range.result);
	// }
	def random_get(ptr: int, len: int) -> int;
	def sock_recv(sock: int, ri_data: int, ri_data_len: int, ri_flags: int, ro_data_len: int, ro_flags: int) -> int;
	def sock_send(sock: int, si_data: int, si_data_len: int, si_flags: int, ret_data_len: int) -> int;
	def sock_shutdown(sock: int, how: int) -> int;
	def sock_accept(sock: int, fd_flags: int, ro_fd: int) -> int;
}
// Identifiers for preopened capabilities.
private enum PreopenType(code: byte) {
	Dir(0),
}