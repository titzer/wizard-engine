// Copyright 2024 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def LABEL_BUFFER = "whamm_buffer";
def LABEL_BUFFER_START = "whamm_buffer:start";
def LABEL_BUFFER_MAX = "whamm_buffer:max";

// Represents an event that is instrumentable in Whamm.
type WhammEvent {
	case Null;
	case AllOpcodes;
	case FuncEntry;
	case FuncExit;
	case BlockStart;
	case BlockEnd;
	case Opcode(op: Opcode);

	def render(buf: StringBuilder) -> StringBuilder {
		match (this) {
			Null => return buf.puts("<null>");
			AllOpcodes => return buf.puts("opcode:*");
			FuncEntry => return buf.puts("func:entry");
			FuncExit => return buf.puts("func:exit");
			BlockStart => return buf.puts("block:start");
			BlockEnd => return buf.puts("block:end");
			Opcode(op) => return buf.puts("opcode:").puts(op.mnemonic);
		}
	}
}

type WhammRule(params: Array<WhammParam>, func: FuncDecl, pred: WhammPredicate) #unboxed;

// Represents a declared parameter to a Whamm probe call.
type WhammParam {
	case DynamicLoc;
	case FrameAccessor;
	case Pc;
	case Func;
	case OpName;
	case Fname;
	case ProbeId;
	case NumTargets;
	case Offset;
	case InstrCount;
	case AtFuncEnd;
	case Imm(orig: Token, i: u31);
	case Arg(orig: Token, i: u31);
	case Local(orig: Token, i: u31);
	case Call(target: Token, params: Array<WhammParam>);

	def render(buf: StringBuilder) -> StringBuilder {
		match (this) {
			DynamicLoc => return buf.puts("loc");
			FrameAccessor => return buf.puts("frame");
			Pc => return buf.puts("pc");
			Func => return buf.puts("fid");
			OpName => return buf.puts("op_name");
			Fname => return buf.puts("fname");
			ProbeId => return buf.puts("probe_id");
			NumTargets => return buf.puts("num_targets");
			Offset => return buf.puts("offset");
			InstrCount => return buf.puts("instr_count");
			AtFuncEnd => return buf.puts("at_func_end");
			Imm(orig, i) => return buf.put1("imm%d", i);
			Arg(orig, i) => return buf.put1("arg%d", i);
			Local(orig, i) => return buf.put1("local%d", i);
			Call(target, params) => {
				buf.puts(target.image);
				buf.putc('(');
				Trace.renderCspRange(buf, params, WhammParam.render);
				buf.putc(')');
				return buf;
			}
		}
	}
}

// {WhammParam}s are converted to {WhammArg}s when they are bound at a match site. After a match
// is determined, some {WhammParam}s are turned into constants (e.g. func, pc), while others (e.g.
// local slot) have their types determined by the match location. Similarly, calls will be
// evaluated at the match site and replaced with their results.
type WhammArg {
	case Null;
	case FrameAccessor;
	case Val(v: Value);
	case Operand(t: ValueType, i: int);
	case Local(t: ValueType, i: int);
}

class WhammPredicate(call: WhammParam.Call) { }

// Represents an instance of a Whamm monitor attached to an application module.
class WhammInstance {
	def app: Module;			// application module
	def instance: Instance;			// instance of the whamm monitor

	new(app, instance) { }
}

// Utilities associated with Whamm probes.
component Whamm {
	def NO_PARAMS: Array<WhammParam> = [];
	def NO_ARGS: Array<WhammArg> = [];

	// Parse a string representing an opcode match with optional parameters.
	def parseProbePattern(r: TextReader) -> (WhammEvent, Array<WhammParam>, WhammPredicate) {		
		var event: WhammEvent = WhammEvent.Null;
		if (r.optN("wasm:") >= 0) {
			if (r.optN("opcode:*") >= 0) {
				// TODO: handle all possible opcode globs?
				event = WhammEvent.AllOpcodes;
			} else if (r.optN("opcode:") >= 0) {
				var op = Opcodes.parseName(r.data[r.pos ...]);
				if (op != Opcode.INVALID) {
					event = WhammEvent.Opcode(op);
					r.advance(op.mnemonic.length);
					r.skipWhitespace();
				}
			} else if (r.optN("func:entry") >= 0) {
				event = WhammEvent.FuncEntry;
			} else if (r.optN("func:exit") >= 0) {
				event = WhammEvent.FuncExit;
			} else if (r.optN("block:start") >= 0) {
				event = WhammEvent.BlockStart;
			} else if (r.optN("block:end") >= 0) {
				event = WhammEvent.BlockEnd;
			}
		}

		if (event == WhammEvent.Null) {
			return (event, NO_PARAMS, null);
		}

		var pred = if(r.char == '/', parsePredicate(r));
		r.skipWhitespace();
		var params = if(r.char == '(', parseParams(r), NO_PARAMS);
		return (event, params, pred);
	}
	// Parse a string representing Whamm parameters, enclosed in parentheses.
	// Any parse errors are left in the supplied {TextReader}.
	def parseParams(r: TextReader) -> Array<WhammParam> {
		var params = Vector<WhammParam>.new();
		r.req1('(');
		while (r.ok) {
			if (r.opt1(')') > 0) break;
			var p = parseParam0(r);
			if (!r.ok) break;
			params.put(p);
			if (r.opt1(')') > 0) break;
			r.req1(',');
		}
		return params.extract();
	}
	// Parse a string representation of a predicate, which is restricted to be
	// a call, thus "/$func(args)/".
	def parsePredicate(r: TextReader) -> WhammPredicate {
		r.req1('/');
		r.skipWhitespace();
		match (parseParam0(r)) {
			x: WhammParam.Call => {
				var pred = WhammPredicate.new(x);
				r.skipWhitespace();
				r.req1('/');
				return pred;
			}
			_ => {
				r.fail("expected call in predicate");
				return null;
			}
		}
	}
}

// A probe that adapts a Wasm function to be called by the engine-internal probing mechanism.
class WhammProbe(func: Function, sig: Array<WhammArg>) extends Probe {
	var trampoline: TargetCode;
	// properties set by the spc to make inlining optimization decisions.
	var inline_heuristic_checked = false;
	var spc_inline_func = false;
	var spc_swap_instance = false;
	var spc_swap_membase = false;

	private def args = if(sig.length == 0, Values.NONE, Array<Value>.new(sig.length));

	def fire(loc: DynamicLoc) -> ProbeAction {
		for (i < sig.length) {
			var v: Value;
			match (sig[i]) {
				FrameAccessor => v = Value.Ref(loc.frame.getFrameAccessor().getMetaRef());
				Val(val) => v = val;
				Operand(t, i) => v = loc.frame.getFrameAccessor().getOperand(i);
				Local(t, i) => v = loc.frame.getFrameAccessor().getLocal(i);
				Null => System.error("whamm", "null whamm arg!");
			}
			args[i] = v;
		}
		match (Execute.call(func, args)) {
			Throw(thrown) => {
				TraceUtil.renderThrowable(Trace.OUT, thrown);
				System.error("whamm", "probe threw exception");
			}
			_ => ;
		}
		return ProbeAction.Continue;
	}
}

def parseParam0(r: TextReader) -> WhammParam {
	var i = r.star_rel(0, isAlphaOrUnderscore);
	var id = r.data[r.pos ... i];
	if (Ranges.equal("arg", id)) return parseUint(r, i, WhammParam.Arg);
	if (Ranges.equal("imm", id)) return parseUint(r, i, WhammParam.Imm);
	if (Ranges.equal("local", id)) return parseUint(r, i, WhammParam.Local);

	i = r.star_rel(i - r.pos, isIdentChar);

	if (i == r.pos) {
		r.fail("expected identifier");
		return WhammParam.DynamicLoc;
	}

	var token = r.readToken(i - r.pos);
	if (r.char == '(') {
		var params = Whamm.parseParams(r); // TODO: don't allow nested calls.
		return WhammParam.Call(token, params);
	}

	if (Strings.equal("pc", token.image)) return WhammParam.Pc;
	if (Strings.equal("fid", token.image)) return WhammParam.Func;
	if (Strings.equal("op_name", token.image)) return WhammParam.OpName;
	if (Strings.equal("fname", token.image)) return WhammParam.Fname;
	if (Strings.equal("probe_id", token.image)) return WhammParam.ProbeId;
	if (Strings.equal("frame", token.image)) return WhammParam.FrameAccessor;
	if (Strings.equal("num_targets", token.image)) return WhammParam.NumTargets;
	if (Strings.equal("offset", token.image)) return WhammParam.Offset;
	if (Strings.equal("instr_count", token.image)) return WhammParam.InstrCount;
	if (Strings.equal("at_func_end", token.image)) return WhammParam.AtFuncEnd;

	r.setFirstError(token.beginLine, token.beginColumn, Strings.format1("unresolved identifier: \"%s\"", token.image));
	return WhammParam.DynamicLoc;
}
def parseUint<T>(r: TextReader, i: int, f: (Token, u31) -> T) -> T {
	var t = Ints.parsePosDecimal(r.data, i);
	if (t.0 > 0) {
		var token = r.readToken(i + t.0 - r.pos);
		return f(token, u31.!(t.1));
	}
	r.failRel(i, "expected positive integer");
	var d: T;
	return d;
}
def isAlphaOrUnderscore(ch: byte) -> bool {
	return (ch >= 'a' && ch <= 'z')
		|| (ch >= 'A' && ch <= 'Z')
		|| ch == '_';
}
def isIdentChar(ch: byte) -> bool {
	return (ch >= 'a' && ch <= 'z')
		|| (ch >= 'A' && ch <= 'Z')
		|| (ch >= '0' && ch <= '9')
		|| ch == '_' || ch == '$';
}

def debug(r: TextReader, where: string) {
	Trace.OUT.puts(where).ln();
	r.renderCurrentLineWithCaret(Trace.OUT, r.pos);
	Trace.OUT.ln();
}

class WhammVarBinder(wi: WhammInstance, err: ErrorGen) {
	var probe_id = -1;
	var instr_count = -1;
	var func_cache: HashMap<string, Function>;
	var buffer: Memory;
	var buffer_start: u32;
	var buffer_max: u32;

	var buffer_next: u32;

	def resetState() {
		instr_count = -1;
		probe_id = -1;
		buffer_next = buffer_start;
	}

	def evalCall(target: Token, params: Array<WhammParam>, cv: CodeValidator, op: Opcode) -> CallResult {
		def exports = wi.instance.module.exports;
		def func = lookupExportedFunction(target.image);
		if (func == null) {
			putErr(Strings.format1("static function %s not found", target.image), cv);
			return CallResult.Fail;
		}

		def whammArgs = bindParams(cv, func.sig.params, params, op, true);
		if (whammArgs == null) return CallResult.Fail;	// propagating error, not a good idea
		def args = if(whammArgs.length == 0, Values.NONE, Array<Value>.new(whammArgs.length));

		for (i < whammArgs.length) {
			// this cast should always succeed, as a dynamic parameter will
			// cause  `bindParams` to fail
			args[i] = WhammArg.Val.!(whammArgs[i]).v;
		}
		// typecheck before execute
		def result = Execute.call(func, args); // XXX: runs on a new stack
		match (result) {
			Value(vals) => {
				if (vals.length != 1) {
					putErr(Strings.format3("function '%s' invalid, expected %d function result, got %d", target.image, 1, vals.length), cv);
					return CallResult.Fail;
				}
				return CallResult.OK(func.sig.results[0], vals[0]);
			}
			Throw(thrown) => {
				putErr(Strings.format1("static function '%s' threw exception", target.image), cv);
				TraceUtil.renderThrowable(Trace.OUT, thrown);
				return CallResult.Fail;
			}
			Switch => {
				putErr(Strings.format1("static function '%s' attempted stack switch", target.image), cv);
				return CallResult.Fail;
			}
		}
	}

	def bindParams(cv: CodeValidator, expParams: Array<ValueType>,
			params: Array<WhammParam>, op: Opcode, nested: bool) -> Array<WhammArg> {
		var args = Array<WhammArg>.new(expParams.length);
		// calls to lazily perform (only if we have a match)
		var callsToEval: List<void -> WhammArg>;

	  	if (expParams.length < params.length) {
			putErr(Strings.format2("expected at least %d function params, got %d", params.length, expParams.length), cv);
			return null;
	 	}

		var i_whamm = 0; var i_exp = 0;
		while (i_whamm < params.length && i_exp < expParams.length) {
			var arg: WhammArg;
			match (params[i_whamm]) {
				DynamicLoc => ; // TODO
				FrameAccessor => {
					if (nested) {
						putErr("cannot use FrameAccessor in static predicate", cv);
						return null;
					}
					arg = bindFrameAccessor(op, expParams[i_exp], cv);
			  	}
				Pc => { // func scope
					arg = bindPc(op, expParams[i_exp], cv);
				}
				Func => { // func scope
					arg = bindFunc(op, expParams[i_exp], cv);
				}
				OpName         => {
					if (!nested) {
						// TODO: this we need to have a special WhammArg that writes a datasegment to memory at runtime!
						putErr("`op_name` not supported dynamically (yet)", cv);
						return null;
					}
					if (i_exp + 1 >= expParams.length) {
						putErr(Strings.format2("expected at least %d function params, got %d", i_exp + 2, expParams.length), cv);
						return null;
					}
					def opPtr = bindOpName(op, expParams[i_exp], expParams[i_exp + 1], cv);
					if (opPtr.0 == WhammArg.Null) return null;
					args[i_exp] = opPtr.0;

					arg = opPtr.1;
					i_exp++;
				}
				Fname          => {
					if (!nested) {
						// TODO: this we need to have a special WhammArg that writes a datasegment to memory at runtime!
						putErr("`fname` not supported dynamically (yet)", cv);
						return null;
					}
					if (i_exp + 1 >= expParams.length) {
						putErr(Strings.format2("expected at least %d function params, got %d", i_exp + 2, expParams.length), cv);
						return null;
					}
					def fnamePtr = bindFname(expParams[i_exp], expParams[i_exp + 1], cv);
					if (fnamePtr.0 == WhammArg.Null) return null;
					args[i_exp] = fnamePtr.0;

					arg = fnamePtr.1;
					i_exp++;
				}
				ProbeId => {
					arg = bindProbeId(op, expParams[i_exp], cv);
				}
				NumTargets => { // br_table
					arg = bindNumTargets(op, expParams[i_exp], cv);
				}
				Offset => { // load/store
					arg = bindOffset(op, expParams[i_exp], cv);
				}
				InstrCount => { // block:end
					arg = bindInstrCount(op, expParams[i_exp], cv);
				}
				AtFuncEnd => { // whether we are at an 'end' opcode at the END of a function
					arg = bindAtFuncEnd(op, expParams[i_exp], cv);
				}
				Imm(orig, j) => { // opcodes
					arg = bindImm(j, op, expParams[i_exp], cv);
				}
				Arg(orig, j) => {  // arg0 = first arg to bytecode
					if (nested) {
						putErr(Strings.format1("cannot use '%q' in static predicate", params[i_whamm].render), cv);
						return null;
					}
					arg = bindArg(j, op, expParams[i_exp], cv);
				}
				Local(orig, j) => { // func scope
					if (nested) {
						putErr(Strings.format1("cannot use '%q' in static predicate", params[i_whamm].render), cv);
						return null;
					}
					arg = bindLocal(j, op, expParams[i_exp], cv);
				}
				Call(target, params) => {
					if (nested) {
						putErr("cannot nest function calls", cv);
						return null;
					}
					// Call this function only if we have a match!
					callsToEval = List.new((fun => args[i_exp] = bindCallResult(target, params, op, expParams[i_exp], cv)),
						callsToEval);
					i_whamm++; i_exp++;
					continue;
				}
			}
			if (arg == WhammArg.Null) return null;
			args[i_exp] = arg;

			i_whamm++; i_exp++;
		}

		if (i_whamm < params.length) {
			// this shouldn't happen
			System.error("whamm", Strings.format2("[internal-error] only visited %d of the %d total WhammParams!", i_whamm, params.length));
			return null;
		}
		if (i_exp < expParams.length) {
			// we didn't process through all of the params/args like we should have!
			putErr(Strings.format2("expected %d function params, got %d", i_exp, expParams.length), cv);
			return null;
		}
		for (l = callsToEval; l != null; l = l.tail) {
			def arg = l.head();
			if (arg == WhammArg.Null) return null;
		}
		return args;
	}

	private def bindFrameAccessor(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (expType != ValueTypes.EXTERNREF) {
			errTypeMismatch(WhammParam.Fname, ValueTypes.EXTERNREF, expType, cv);
			return WhammArg.Null;
		}
		return WhammArg.FrameAccessor; // type externref
	}

	private def bindPc(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (expType != ValueType.I32) {
			errTypeMismatch(WhammParam.Pc, ValueType.I32, expType, cv);
			return WhammArg.Null;
		}
		return WhammArg.Val(Values.box_i(cv.opcode_pos));
	}

	private def bindFunc(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (expType != ValueType.I32) {
			errTypeMismatch(WhammParam.Func, ValueType.I32, expType, cv);
			return WhammArg.Null;
		}
		return WhammArg.Val(Values.box_i(cv.func.func_index));
	}

	private def bindOpName(op: Opcode, expType0: ValueType, expType1: ValueType, cv: CodeValidator) -> (WhammArg, WhammArg) {
		return writeData(op.mnemonic, WhammParam.OpName, expType0, expType1, cv);
	}

	private def bindFname(expType0: ValueType, expType1: ValueType, cv: CodeValidator) -> (WhammArg, WhammArg) {
		var fname = renderFnameNoQuotes(cv.func, cv.module.names);
		return writeData(fname, WhammParam.Fname, expType0, expType1, cv);
	}

	private def bindProbeId(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (expType != ValueType.I32) {
			errTypeMismatch(WhammParam.ProbeId, ValueType.I32, expType, cv);
			return WhammArg.Null;
		}
		if (probe_id < 0) {
			if (wi.app.dyn_probes == null) wi.app.dyn_probes = Vector.new();
			probe_id = wi.app.dyn_probes.length;
			wi.app.dyn_probes.put(0, 0, null);
		}
		return WhammArg.Val(Values.box_i(probe_id));
	}

	private def bindNumTargets(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (op != Opcode.BR_TABLE) {
			putErr("num_targets variable only in-scope for br_table opcode.", cv);
			return WhammArg.Null;
		}
		if (expType != ValueType.I32) {
			errTypeMismatch(WhammParam.NumTargets, ValueType.I32, expType, cv);
			return WhammArg.Null;
		}

		var accessors = cv.immAccessors();
		var parser = accessors.0;
		var codeptr = accessors.1;
		for (imm in op.imms) {
			if (imm == ImmKind.LABELS) {
				// num_targets is the number of branches (not including the default branch)
				def labels = parser.readLabels();
				
				return WhammArg.Val(Values.box_i(labels.length - 1));
			} else {
				codeptr.skip_immediates([imm]);
			}
		}
		return WhammArg.Null;
	}

	private def bindOffset(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		def imms = op.imms;

		var accessors = cv.immAccessors();
		var parser = accessors.0;
		var codeptr = accessors.1;
		for (imm in op.imms) {
			if (imm == ImmKind.MEMARG) {
				if (expType != ValueType.I64) {
					errTypeMismatch(WhammParam.Offset, ValueType.I64, expType, cv);
				}

				def memarg = parser.readMemoryArg();
				return WhammArg.Val(Values.box_l(i64.!(memarg.offset)));
			} else {
				codeptr.skip_immediates([imm]);
			}
		}
		putErr(Strings.format2("'%q' variable not available for opcode: %s", WhammParam.Offset.render, op.mnemonic), cv);
		return WhammArg.Null;
	}

	private def bindInstrCount(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (instr_count < 0) {
			putErr(Strings.format1("'%q' only in scope for block:end", WhammParam.InstrCount.render), cv);
			return WhammArg.Null;
		}
		if (expType != ValueType.I32) {
			errTypeMismatch(WhammParam.Offset, ValueType.I32, expType, cv);
			return WhammArg.Null;
		}
		return WhammArg.Val(Values.box_i(instr_count));
	}

	private def bindAtFuncEnd(op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (expType != ValueType.I32) {
			err.at(cv.parser.decoder).WhammProbeError("whamm probe", "type mismatch on at_func_end argument");
			return WhammArg.Null;
		}
		def atFuncEnd = cv.opcode_pos + 1 == cv.codeptr.limit;
		return WhammArg.Val(Values.box_b(atFuncEnd));
	}

	private def bindImm(n: int, op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		def imms = op.imms;
		def vals = Vector<Value>.new();

		var accessors = cv.immAccessors();
		var parser = accessors.0;
		for (imm in op.imms) {
			match (imm) {
				ARRAY_TYPE_INDEX  => vals.put(Values.box_u(parser.readU32("array type index", u32.max)));
				BLOCK_TYPE        => vals.put(Values.box_i(parser.readTypeCode()));
				DATA_INDEX        => vals.put(Values.box_u(parser.readU32("data index", u32.max)));
				ELEM_INDEX        => vals.put(Values.box_u(parser.readU32("elem index", u32.max)));
				TAG_INDEX         => vals.put(Values.box_u(parser.readU32("tag index", u32.max)));
				FIELD_INDEX       => vals.put(Values.box_u(parser.readU32("field index", u32.max)));
				FUNC_INDEX        => vals.put(Values.box_u(parser.readU32("func index", u32.max)));
				GLOBAL_INDEX      => vals.put(Values.box_u(parser.readU32("global index", u32.max)));
				LABEL             => vals.put(Values.box_u(parser.readLabel()));
				LABELS            => {
					def labels = parser.readLabels();
					// NOTE hardcoded, because BR_TABLE is the only one that uses imm.LABELS
					vals.put(Values.box_i(labels.length - 1));
					vals.puta(Arrays.map(labels, Values.box_u));
				}
				LOCAL_INDEX       => vals.put(Values.box_u(parser.readU32("local index", u32.max)));
				MEMARG            => {
					// TODO discuss memarg format
					def memarg = parser.readMemoryArg();
					vals.put(Values.box_u(memarg.flags));
					vals.put(Values.box_u(memarg.memory_index));
					vals.put(Values.box_u(u32.!(memarg.offset)));
				}
				MEMORY_INDEX      => vals.put(Values.box_u(parser.readU32("memory index", u32.max)));
				HEAP_TYPE         => vals.put(Values.box_i(parser.readTypeCode()));
				SIG_INDEX         => vals.put(Values.box_u(parser.readU32("sig index", u32.max)));
				STRUCT_TYPE_INDEX => vals.put(Values.box_u(parser.readU32("struct type index", u32.max)));
				TABLE_INDEX	  => vals.put(Values.box_u(parser.readU32("table index", u32.max)));
				VALUE_TYPES	  => ;		// TODO
				ZERO_BYTE	  => vals.put(Values.box_u(parser.decoder.read1()));
				U32		  => vals.put(Values.box_u(parser.readU32("imm U32", u32.max)));
				I32		  => vals.put(Values.box_i(parser.readI32()));
				I64		  => vals.put(Values.box_l(parser.readI64()));
				F32		  => vals.put(Values.box_fu32(parser.readF32()));
				F64		  => vals.put(Values.box_du64(parser.readF64()));
				V128		  => vals.put(Values.box_s(parser.decoder.read_u64(), parser.decoder.read_u64()));
				LANE_INDEX	  => vals.put(Values.box_u(parser.decoder.read1()));
				BR_CAST		  => ;		// TODO
				CATCHES		  => ;		// TODO
				CONT_INDEX	  => ;		// TODO
				EX_HANDLERS	  => ;		// TODO
				SUS_HANDLERS	  => ;		// TODO
			}
		}

		if (n >= vals.length) {
			var msg = Strings.format2("immediate out of bounds, max imm%d, requested imm%d", vals.length - 1, n);
			match (op) {
				BR_TABLE, TRY_TABLE => {
					if (Trace.whamm) Trace.OUT.ln().put1("    no match: %s", msg).ln();
				} // no match error
				_ => {
					putErr(msg, cv);
				}
			}
			return WhammArg.Null;
		}

		var t: ValueType;
		match (vals[n]) {
			Ref  => t = ValueTypes.ANYREF;
			I31  => t = ValueTypes.I31REF;
			I32  => t = ValueType.I32;
			I64  => t = ValueType.I64;
			F32  => t = ValueType.F32;
			F64  => t = ValueType.F64;
			V128 => t = ValueType.V128;
		}
		if (expType != t) {
			errTypeMismatch(WhammParam.Imm(null, u31.!(n)), t, expType, cv);
			return WhammArg.Null;
		}
		return WhammArg.Val(vals[n]);
	}

	private def bindArg(n: int, op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		var accessors = cv.immAccessors();
		var parser = accessors.0;
		def io = Opcodes.stackDelta(cv.sig, op, parser);
		def args = io.0;

		if (n >= args) {
			var msg = Strings.format2("argument out of bounds, max arg%d, requested arg%d", args - 1, n);
			match (op) {
				CALL, CALL_INDIRECT => {
					if (Trace.whamm) Trace.OUT.ln().put1("    no match: %s", msg).ln();
				} // no match
				_ => {
					putErr(msg, cv);
				}
			}
			return WhammArg.Null;
		}
		def stk = cv.val_stack.peekn(args);
		def t   = stk[args - n - 1];
		if (expType != t) {
			match (op) {
				CALL, CALL_INDIRECT => {
					if (Trace.whamm) Trace.OUT.ln().put1("    no match: %s", buildTypeMismatchErr(WhammParam.Arg(null, u31.!(n)).render, t.render, expType.render)).ln();
				} // no match
				_ => {
					errTypeMismatch(WhammParam.Arg(null, u31.!(n)), t, expType, cv);
				}
			}
			return WhammArg.Null;
		}
		return WhammArg.Operand(t, 0 - n);
	}

	private def bindLocal(n: int, op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		if (n >= cv.locals.length) {
			if (Trace.whamm) Trace.OUT.ln().put2("    no match: local out of bounds, max local%d, requested local%d", cv.locals.length - 1, n).ln();
			return WhammArg.Null;
		} // no match error

		def t = cv.locals[n];

		if (expType != t) {
			if (Trace.whamm) Trace.OUT.ln().put1("    no match: %s", buildTypeMismatchErr(WhammParam.Local(null, u31.!(n)).render, t.render, expType.render)).ln();
			return WhammArg.Null;
		} // no match error
		return WhammArg.Local(t, n);
	}

	private def bindCallResult(target: Token, params: Array<WhammParam>, op: Opcode, expType: ValueType, cv: CodeValidator) -> WhammArg {
		var arg: WhammArg;
		match (evalCall(target, params, cv, op)) {
			Fail => {
				if (Trace.whamm) Trace.OUT.ln().put1("    no match: static function '%s' threw exception", target.image).ln();
				return WhammArg.Null;
			}
			OK(t, v) => {
				arg = WhammArg.Val(v);
				if (expType != t) {
					putErr(Strings.format2("expected static call return type %q, got %q", expType.render, t.render), cv);
					return WhammArg.Null;
				}
			}
		}
		return arg;
	}

	// ===============
	// ==== Utils ====
	// ===============

	private def lookupExportedFunction(name: string) -> Function {
		if (func_cache == null) {
			func_cache = Strings.newMap();
			def exports = wi.instance.module.exports;
			for (i < exports.length) {
				var ex = exports[i];
				if (!FuncDecl.?(ex.1)) continue;
				func_cache[ex.0] = Function.!(wi.instance.exports[i]);
			}
		}
		return func_cache[name];
	}
	private def renderFnameNoQuotes(func: FuncDecl, names: NameSection) -> string {
		var name = if (names != null, names.getFuncName(func.func_index));
		if (name != null) return name;
		else return "";
	}
	private def writeData(data: Array<byte>, param: WhammParam, expType0: ValueType, expType1: ValueType, cv: CodeValidator) -> (WhammArg, WhammArg) {
		if (buffer == null) {
			// lazily bind engine memory
			if (!bindWhammBuffer(cv)) {
				return (WhammArg.Null, WhammArg.Null);
			}
		}
		if (expType0 != ValueType.I32 || expType1 != ValueType.I32) {
			errTypeMismatch2(param, ValueType.I32, ValueType.I32, expType0, expType1, cv);
			return (WhammArg.Null, WhammArg.Null);
		}

		// if writing data to memory would overflow the buffer, just write the amount that fits.
		def data_len = if(buffer_next + u32.!(data.length) > buffer_start + buffer_max,
						   (buffer_start + buffer_max) - buffer_next,
						   u32.!(data.length));

		// write the data to the exported memory
		buffer.copyIn(buffer_next, data, 0, u64.!(data_len));

		// Update where we will put the next batch of data in the buffer
		def data_start = buffer_next;
		buffer_next += data_len;
		return (WhammArg.Val(Values.box_u(data_start)), WhammArg.Val(Values.box_u(data_len)));
	}
	private def bindWhammBuffer(cv: CodeValidator) -> bool {
		var found_start: bool, found_max: bool;
		for (i = 0; i < wi.instance.module.exports.length; i++) {
			def exp = wi.instance.module.exports[i];
			match (exp.1) {
				x: MemoryDecl => {
					if (Strings.equal(exp.0, LABEL_BUFFER)) {
						buffer = wi.instance.memories[x.memory_index];
					}
				}
				x: GlobalDecl => {
					if (Strings.equal(exp.0, LABEL_BUFFER_START)) {
						buffer_start = Values.unbox_u(wi.instance.globals[x.global_index].get());
						found_start = true;
					}
					if (Strings.equal(exp.0, LABEL_BUFFER_MAX)) {
						buffer_max = Values.unbox_u(wi.instance.globals[x.global_index].get());
						found_max = true;
					}
				}
				_ => continue;
			};
		}
		if (buffer == null) {
			errExportNotFound("memory", LABEL_BUFFER, cv);
			return false;
		}
		if (!found_start) {
			errExportNotFound("global", LABEL_BUFFER_START, cv);
			return false;
		}
		if (!found_max) {
			errExportNotFound("global", LABEL_BUFFER_MAX, cv);
			return false;
		}

		buffer_next = buffer_start;
		if (Trace.whamm) Trace.OUT.ln().put2("whamm_buffer memory region (inclusive): %d -> %d", buffer_start, buffer_next + buffer_max).ln();
		return true;
	}

	// ================
	// ==== Errors ====
	// ================

	private def errExportNotFound(exportType: string, exportName: string, cv: CodeValidator) {
		putErr(Strings.format2("expected exported %s named '%s' not found", exportType, exportName), cv);
	}
	private def errTypeMismatch(param: WhammParam, exp: ValueType, act: ValueType, cv: CodeValidator) {
		putErr(buildTypeMismatchErr(param.render, exp.render, act.render), cv);
	}
	private def errTypeMismatch2(param: WhammParam, exp0: ValueType, exp1: ValueType, act0: ValueType, act1: ValueType, cv: CodeValidator) {
		putErr(buildTypeMismatchErr(param.render, renderTypeTuple(exp0, exp1, _), renderTypeTuple(act0, act1, _)), cv);
	}
	private def renderTypeTuple(t0: ValueType, t1: ValueType, buf: StringBuilder) -> StringBuilder {
		return buf.put2("(%q,%q)", t0.render, t1.render);
	}
	private def buildTypeMismatchErr(name: (StringBuilder) -> StringBuilder, exp: (StringBuilder) -> StringBuilder, act: (StringBuilder) -> StringBuilder) -> string {
		return Strings.format3("type mismatch on '%q', expected %q, got: %q", name, exp, act);
	}
	private def putErr(msg: string, cv: CodeValidator) {
		err.at(cv.parser.decoder).WhammProbeError("@bind", msg);
	}
}

type CallResult {
	case Fail; // should be set in errorgen, so no extra context needed
	case OK(t: ValueType, v: Value);
}
