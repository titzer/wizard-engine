// Copyright 2025 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def monitor_ = MonitorRegistry.add(
	"alloc", "Collects statistics on struct and array allocations.",
	AllocMonitor.new());

class AllocMonitor extends Monitor {
	def onParse(module: Module, err: ErrorGen) {
		var mi = AllocInstrumenter.new(module);
		mi.run();
		MonitorRegistry.addReport(fun => mi.print(out));
	}
}

type AllocStats {
	case Struct(count: CountProbe);
	case Array(counts: Array<u64>);
}

class AllocInstrumenter extends BytecodeInstrumenter {
	def entries = Vector<(FuncDecl, int, AllocStats)>.new();

	new(module: Module) super(module) {
	}

	def instrumentStructNew(ht_index: u31) {
		var probe = CountProbe.new();
		entries.put(bi.func, bi.pc, AllocStats.Struct(probe));
		insertProbeHere(probe);
	}
	def visit_STRUCT_NEW(ht_index: u31) => instrumentStructNew(ht_index);
	def visit_STRUCT_NEW_DEFAULT(ht_index: u31) => instrumentStructNew(ht_index);
	
	def instrumentArrayNew(ht_index: u31) {
		var probe = ArrayNewProbe.new();
		entries.put(bi.func, bi.pc, AllocStats.Array(probe.counts));
		insertProbeHere(probe);
	}
	def visit_ARRAY_NEW(ht_index: u31) => instrumentArrayNew(ht_index);
	def visit_ARRAY_NEW_DEFAULT(ht_index: u31) => instrumentArrayNew(ht_index);
	def visit_ARRAY_NEW_FIXED	(ht_index: u31, length: u31) {
		var probe = ArrayNewFixedProbe.new(length);
		entries.put(bi.func, bi.pc, AllocStats.Array(probe.counts));
		insertProbeHere(probe);
	}
	def visit_ARRAY_NEW_DATA(ht_index: u31, data_index: u31) => instrumentArrayNew(ht_index);
	def visit_ARRAY_NEW_ELEM(ht_index: u31, elem_index: u31) => instrumentArrayNew(ht_index);

	def print(out: TraceBuilder) {
		var bi = BytecodeIterator.new();
		var prev: FuncDecl;
		for (i < entries.length) {
			var e = entries[i], func = e.0, pc = e.1, stats = e.2;
			if (func != prev) {
				out.beginColor(Color.FUNC)
				   .put1("func %q:", func.render(module.names, _))
				   .endColors()
				   .ln();
				prev = func;
				bi.reset(func);
			}
			out.beginColor(Color.LINE)
			   .mark()
			   .put1("+%d", pc)
			   .rjustify_mark(5)
			   .endColors()
			   .putc(' ');
			bi.at(pc, -1);
			out.mark()
			   .puts(bi.current().mnemonic)
			   .ljustify_mark(20)
			   .sp();
			match (stats) {
				Struct(count) => {
					var c = count.count;
					if (c > 0) out.beginColor(Color.COUNT);
					else out.endColors().beginColor(Color.INACTIVE);
					out.put1("x %d", c);
					out.endColors();
				}
				Array(counts) => {
					var c = counts[0];
					if (c > 0) out.beginColor(Color.COUNT);
					else out.endColors().beginColor(Color.INACTIVE);
					out.put2("x %d, total=%d", c, counts[1]);
					out.endColors();
				}
			}
			out.ln();
		}
	}
}

class ArrayNewProbe extends Probe {
	def counts = [0uL, 0uL];
	def fire(loc: DynamicLoc) -> ProbeAction {
		counts[0]++;	
		match (loc.frame.getFrameAccessor().getOperand(0)) {
			I32(val) => counts[1] += val;
			_ => ;
		}
		return ProbeAction.Continue;
		
	}
}

class ArrayNewFixedProbe(length: u31) extends Probe {
	def counts = [0uL, 0uL];
	def fire(loc: DynamicLoc) -> ProbeAction {
		counts[0]++;
		counts[1] += length;
		return ProbeAction.Continue;
		
	}
}
