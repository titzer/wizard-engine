// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The ModuleMonitor interface implements an API for inserting callbacks for various events that
// occur during execution. Events are detected and instrumented using the lower-level probe API
// offered by the engine.
class ModuleMonitor(module: Module) extends Monitor {
	def finishCallbacks = Vector<(Instance -> void)>.new();

	new() {
		MonitorOptions.insertMonitor(this);
	}

	// Attach callback {f} to be called before {func} is executed.
	def beforeFuncExec(func: FuncDecl, f: DynamicLoc -> Resumption) -> Probe {
		if (func.imp != null) return null;
		return beforeFuncExecAndReturn(func, f, null).0;
	}
	// Attach callback {f} to be called before {func} returns.
	def beforeFuncReturn(func: FuncDecl, f: DynamicLoc -> Resumption) -> Probe {
		if (func.imp != null) return null;
		return beforeFuncExecAndReturn(func, null, f).1;
	}
	// Attach callbacks that are called when a func is executed or returns
	def beforeFuncExecAndReturn(func: FuncDecl, beforeExec: DynamicLoc -> Resumption, beforeRet: DynamicLoc -> Resumption) -> (Probe, Probe) {
		var it = BytecodeIterator.new();
		var bi = it.reset(func);

		var startsWithLoop = false;
		var frameAccessors: ListStack<FrameAccessor>;
		var entryProbe: Probe = null;
		var exitProbe: Probe = null;

		if (bi.current() == Opcode.LOOP) {
			startsWithLoop = true;
			frameAccessors = ListStack<FrameAccessor>.new();
			entryProbe = FuncWithLoopEnterProbe.new(frameAccessors, beforeExec);
			module.insertProbeAt(func.func_index, bi.pc, entryProbe);
		} else if (beforeExec != null) {
			entryProbe = CallbackProbe.new(beforeExec);
			module.insertProbeAt(func.func_index, bi.pc, entryProbe);
		}

		if (startsWithLoop)
			exitProbe = FuncWithLoopExitProbe.new(frameAccessors, beforeRet);
		else if (beforeRet != null)
			exitProbe = CallbackProbe.new(beforeRet);

		for (bi = it.reset(func); bi.more(); bi.next()) {
			var op = bi.current();
			match (op) {
				RETURN => ;
				END => if (bi.pc + 1 < bi.func.cur_bytecode.length) continue;
				_ => continue;
			}

			if (exitProbe != null)
				module.insertProbeAt(func.func_index, bi.pc, exitProbe);
		}

		return (entryProbe, exitProbe);
	}
	// Attach callback {f} to any non-import function execution.
	def beforeAllFuncExec(f: DynamicLoc -> Resumption) {
		forEachFunc(MonitorUtil.isNotImport, beforeFuncExec(_, f));
	}
	// Attach callback {f} to any non-import function return.
	def beforeAllFuncReturn(f: DynamicLoc -> Resumption) {
		forEachFunc(MonitorUtil.isNotImport, beforeFuncReturn(_, f));
	}
	// Attach callback {f} to any non-import function call or return.
	def beforeAllFuncExecAndReturn(callFn: DynamicLoc -> Resumption, retFn: DynamicLoc -> Resumption) {
		forEachFunc(MonitorUtil.isNotImport, beforeFuncExecAndReturn(_, callFn, retFn));
	}
	// Attach callback {f} to before an instruction execution.
	def beforeInstrExec(func: FuncDecl, pc: int, f: DynamicLoc -> Resumption) -> Probe {
		var probe = CallbackProbe.new(f);
		module.insertProbeAt(func.func_index, pc, probe);
		return probe;
	}
	// Attach callback {f} that fires after an instruction has executed
	// The resultant DynamicLoc will be the next wasm bytecode that is executed,
	// skipping the entry/exit of any host functions in between.
	def afterInstrExec(func: FuncDecl, pc: int, f: DynamicLoc -> Resumption) {
		var bi = BytecodeIterator.new();
		var it = bi.reset(func);
		var visitor = AfterInstrVisitor.new(module, func, pc, f);
		visitor.bi = it;

		it.current();
		while (it.pc < pc) {
			it.dispatch(visitor);
			it.next();
		}
		it.dispatch(visitor);
	}
	// Attach callback {f} to before a read of the global at index {global_index}.
	def beforeGlobalRead(f: DynamicLoc -> Resumption, global_index: u31) {
		forEachFunc(MonitorUtil.isNotImport, monitorFuncForGlobalAccess(_, global_index, false, f));
	}
	// Attach callback {f} to before a write of the global at index {global_index}.
	def beforeGlobalWrite(f: DynamicLoc -> Resumption, global_index: u31) {
		forEachFunc(MonitorUtil.isNotImport, monitorFuncForGlobalAccess(_, global_index, true, f));
	}
	// Attach callback {f} to before every memory read.
	def beforeMemRead(f: (DynamicLoc, Memory, u64, u64) -> Resumption) {
		beforeMemOp(f, null, null);
	}
	// Attach callback {f} to before every memory write.
	def beforeMemWrite(f: (DynamicLoc, Memory, u64, u64) -> Resumption) {
		beforeMemOp(null, f, null);
	}
	// Attach callback {f} to before every memory grow.
	def beforeMemGrow(f: (DynamicLoc, Memory, u32) -> Resumption) {
		beforeMemOp(null, null, f);
	}
	def afterFinish(f: (Instance) -> void) {
		finishCallbacks.put(f);
	}
	def onFinish(i: Instance) {
		for (j < finishCallbacks.length) finishCallbacks[j](i);
	}

	// Helpers
	// call f(funcDecl) if filter(module, funcDecl) is true
	def forEachFunc<T>(filter: (Module, FuncDecl) -> bool, f: FuncDecl -> T) {
		for (i < module.functions.length) {
			var func = module.functions[i];
			if (!filter(module, func)) continue;
			f(func);
		}
	}

	private def monitorFuncForGlobalAccess(func: FuncDecl, global_index: u31, isWrite: bool, f: DynamicLoc -> Resumption) {
		var bi = BytecodeIterator.new();
		var visitor = GlobalVisitor.new(module, f, isWrite, global_index);
		visitor.bi = bi;

		for (it = bi.reset(func); it.more(); it.next()) {
			it.dispatch(visitor);
		}
	}
	private def beforeMemOp(
		readFn: (DynamicLoc, Memory, u64, u64) -> Resumption,
		writeFn: (DynamicLoc, Memory, u64, u64) -> Resumption,
		growFn: (DynamicLoc, Memory, u32) -> Resumption
	) {
		var it = BytecodeIterator.new();
		var visitor = MemoryVisitor.new(module, readFn, writeFn, growFn);
		visitor.bi = it;

		forEachFunc(MonitorUtil.isNotImport, monitorFuncForMemoryAccess(_, visitor));
	}
	private def monitorFuncForMemoryAccess(func: FuncDecl, visitor: MemoryVisitor) {
		for (bi = visitor.bi.reset(func); bi.more(); bi.next()) {
			bi.dispatch(visitor);
		}
	}
}

component MonitorUtil {
	def isImport(module: Module, func: FuncDecl) -> bool {
		return func.imp != null;
	}
	def isNotImport(module: Module, func: FuncDecl) -> bool {
		return func.imp == null;
	}
}

private class FuncWithLoopEnterProbe(frameAccessors: ListStack<FrameAccessor>, f: DynamicLoc -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var curAccessor = dynamicLoc.frame.getFrameAccessor();
		if (!frameAccessors.empty() && curAccessor == frameAccessors.peek())
			return Resumption.Continue;
		frameAccessors.push(curAccessor);
		if (f != null)
			return f(dynamicLoc);
		return Resumption.Continue;
	}
}
private class FuncWithLoopExitProbe(frameAccessors: ListStack<FrameAccessor>, f: DynamicLoc -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		frameAccessors.pop();
		if (f != null) return f(dynamicLoc);
		return Resumption.Continue;
	}
}

private class AfterInstrGlobalProbe(f: DynamicLoc -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		Execute.probes.remove(this);
		return f(dynamicLoc);
	}
}
// This probe dynamically activates probes at destinations, based on the current
// state of the program. This is attached for after instruction callbacks that
// have multiple destinations possible at runtime, with the exception of
// CALL_INDIRECT and RETURN/END of function, where it activates the global
// interpreter probe instead.
private class AfterInstrProbe(module: Module, opcode: Opcode, destProbes: Range<AfterInstrDestProbe>, f: DynamicLoc -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var nextProbe = getNextProbe(dynamicLoc);
		if (nextProbe != null) {
			nextProbe.active = true;
		}
		return Resumption.Continue;
	}

	// Get the next destination probe based on the state of the current frame
	private def getNextProbe(dynamicLoc: DynamicLoc) -> AfterInstrDestProbe {
		if (destProbes.length == 1) return destProbes[0];

		match (opcode) {
			BR_IF, BR_TABLE, IF => ;
			_ => return null;
		}

		var accessor = dynamicLoc.frame.getFrameAccessor();
		var condition = Values.v_i(accessor.getOperand(0));

		match (opcode) {
			BR_IF => return destProbes[if(condition != 0, 1, 0)];
			BR_TABLE => {
				if (condition >= destProbes.length) condition = destProbes.length - 1;
				return destProbes[condition];
			}
			IF => return destProbes[if(condition != 0, 1, 0)];
			_ => ;
		}
		return null;
	}
}
private class AfterInstrAddGlobalProbe(f: DynamicLoc -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		Execute.probes.add(AfterInstrGlobalProbe.new(f));
		return Resumption.Continue;
	}
}
private class AfterInstrDestProbe(module: Module, f: DynamicLoc -> Resumption) extends Probe {
	var active = false;
	
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		if (active) {
			active = false;
			return f(dynamicLoc);
		}
		return Resumption.Continue;
	}
}
private class AfterInstrVisitor(module: Module, func: FuncDecl, pc: int, f: DynamicLoc -> Resumption) extends BytecodeVisitor {
	var bi: BytecodeIterator;
	var stp: int;
	var sidetable = func.sidetable.entries; // TODO: use Sidetable abstraction

	def visitOp(op: Opcode) {
		insertProbes([bi.nextPc()], f);
	}
	def visit_BR(depth: u31) {
		var takenPc = sidetable[stp] + bi.pc;
		stp += 4;
		insertProbes([takenPc], f);
	}
	def visit_BR_IF(depth: u31) {
		var notTakenPc = bi.nextPc();
		var takenPc = sidetable[stp] + bi.pc;
		stp += 4;
		insertProbes([notTakenPc, takenPc], f);
	}
	def visit_BR_TABLE(labels: Range<u31>) {
		stp += 4;
		var dests = Array<int>.new(labels.length);
		for (i < labels.length) {
			dests[i] = sidetable[stp] + bi.pc;
			stp += 4;
		}
		insertProbes(dests, f);
	}
	def visit_IF(btc: BlockTypeCode) {
		var elsePc = sidetable[stp] + bi.pc;
		stp += 4;
		insertProbes([elsePc, bi.nextPc()], f);
	}
	def visit_ELSE() {
		var takenPc = sidetable[stp] + bi.pc;
		stp += 4;
		insertProbes([takenPc], f);
	}
	def visit_END() {
		if ((bi.pc + 1) < bi.func.cur_bytecode.length) {
			insertProbes([bi.nextPc()], f);
		} else {
			insertGlobalProbe(f);
		}
	}
	def visit_CALL(func_index: u31) {
		insertCallProbe(func_index, f);
	}
	def visit_RETURN() {
		insertGlobalProbe(f);
	}
	def visit_CALL_INDIRECT(sig_index: u31, table_index: u31) {
		insertGlobalProbe(f);
	}

	private def insertProbes(dests: Range<int>, f: DynamicLoc -> Resumption) {
		if (bi.pc != pc) return;
		var destProbes = Array<AfterInstrDestProbe>.new(dests.length);
		for (i < dests.length) {
			if (dests[i] == -1) {
				destProbes[i] = null;
			} else {
				destProbes[i] = AfterInstrDestProbe.new(module, f);
				module.insertProbeAt(bi.func.func_index, dests[i], destProbes[i]);
			}
		}
		module.insertProbeAt(bi.func.func_index, bi.pc, AfterInstrProbe.new(module, bi.current(), destProbes, f));
	}
	private def insertCallProbe(func_index: u31, f: DynamicLoc -> Resumption) {
		if (bi.pc != pc) return;
		var destProbe = AfterInstrDestProbe.new(module, f);
		var func_it = BytecodeIterator.new();
		var func_bi = func_it.reset(module.functions[func_index]);
		func_bi.current();
		module.insertProbeAt(func_index, func_bi.pc, destProbe);
		module.insertProbeAt(bi.func.func_index, bi.pc, AfterInstrProbe.new(module, bi.current(), [destProbe], f));
	}
	private def insertGlobalProbe(f: DynamicLoc -> Resumption) {
		if (bi.pc != pc) return;
		module.insertProbeAt(bi.func.func_index, bi.pc, AfterInstrAddGlobalProbe.new(f));
	}
}

private class GlobalVisitor(module: Module, f: DynamicLoc -> Resumption, isWrite: bool, targetIndex: u31) extends BytecodeVisitor {
	var bi: BytecodeIterator;
	
	def visit_GLOBAL_GET(global_index: u31) {
		if (global_index == targetIndex && !isWrite) {
			module.insertProbeAt(bi.func.func_index, bi.pc, CallbackProbe.new(f));
		}
	}

	def visit_GLOBAL_SET(global_index: u31) {
		if (global_index == targetIndex && isWrite) {
			module.insertProbeAt(bi.func.func_index, bi.pc, CallbackProbe.new(f));
		}
	}
}

private class MemoryVisitor(
	module: Module,
	loadFn: (DynamicLoc, Memory, u64, u64) -> Resumption,
	storeFn: (DynamicLoc, Memory, u64, u64) -> Resumption,
	growFn: (DynamicLoc, Memory, u32) -> Resumption
) extends BytecodeVisitor {
	var bi: BytecodeIterator;

	def visitLoad(op: Opcode, imm: MemArg, size: u8) {
		// TODO: Take into account lane_index for V128 operations
		if (loadFn == null) return;
		module.insertProbeAt(bi.func.func_index, bi.pc, MemoryAccessProbe.new(imm, size, loadFn));
	}
	def visitStore(op: Opcode, imm: MemArg, size: u8) {
		if (storeFn == null) return;
		module.insertProbeAt(bi.func.func_index, bi.pc, MemoryAccessProbe.new(imm, size, storeFn));
	}

	def visit_MEMORY_GROW(memory_index: u31) {
		if (growFn != null)
			module.insertProbeAt(bi.func.func_index, bi.pc, MemoryGrowProbe.new(memory_index, growFn));
	}
}
private class MemoryAccessProbe(imm: MemArg, size: u64, f: (DynamicLoc, Memory, u64, u64) -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var accessor = dynamicLoc.frame.getFrameAccessor();
		var address: u64 = u64.!(Values.v_i(accessor.getOperand(0)));
		address += imm.offset;

		var memory = dynamicLoc.func.instance.memories[imm.memory_index];

		return f(dynamicLoc, memory, address, size);
	}
}
private class MemoryGrowProbe(memory_index: u31, f: (DynamicLoc, Memory, u32) -> Resumption) extends Probe {
	def fire(dynamicLoc: DynamicLoc) -> Resumption {
		var accessor = dynamicLoc.frame.getFrameAccessor();
		var pages = u23.!(Values.v_i(accessor.getOperand(0)));
		var memory = dynamicLoc.func.instance.memories[memory_index];
		return f(dynamicLoc, memory, pages);
	}
}
