// Copyright 2025 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def paths_ = MonitorRegistry.add(
	"paths", "Tallies control flow path counts per function.",
	PathsMonitor.new());

var pathVars: List<PathVar>;

class PathsMonitor extends Monitor {
	def onParse(module: Module, err: ErrorGen) {
		PathInstrumenter.new(module).run();
	}
	def onFinish(instance: Instance, r: Result) {
		Lists.apply(pathVars, fun (p: PathVar) => void(p.render(Trace.OUT).ln()));
	}
}

class PathInstrumenter extends BytecodeInstrumenter {
	var pathVar: PathVar;

	new(module: Module) super(module) { }

	def onFunc(func: FuncDecl) {
//		Trace.OUT.put1("instrumenting %q", func.render(module.names, _)).ln();
		pathVar = PathVar.new(module, func);
		pathVars = List.new(pathVar, pathVars);
	}

	def visit_IF(btc: BlockTypeCode) {
		insertBranchProbe();
	}
	def visit_BR_IF(depth: u31) {
		insertBranchProbe();
	}
	def visit_BR_TABLE(labels: Range<u31>) {
	}
	def visit_LOOP(btc: BlockTypeCode) {
		insertRetProbe();
	}
	def visit_RETURN() {
		insertRetProbe();
	}
	def visit_END() {
		if (bi.pc == bi.func.cur_bytecode.length - 1) insertRetProbe();
	}
	def insertBranchProbe() {
		var v = pathVar;
		insertProbeHere(CallbackProbe.new(fun loc -> ProbeAction {
			var taken = 0u != Values.unbox_u(loc.frame.getFrameAccessor().getOperand(0));
//			Trace.OUT.puts(if(taken, "taken", "not taken")).ln();
			v.append(taken);
			return ProbeAction.Continue;
		}));
	}
	def insertRetProbe() {
		var v = pathVar;
		insertProbeHere(CallbackProbe.new(fun loc -> ProbeAction {
//			Trace.OUT.puts("finish!").ln();
			v.finish();
			return ProbeAction.Continue;
		}));
	}
}

class PathVar(module: Module, func: FuncDecl) {
	def counts = HashMap<int, u64>.new(int.!<int>, int.==);
	var current: int = 1;
	
	def append(taken: bool) {
		current = (current << 1) | if(taken, 1, 0);
	}
	def finish() {
		counts[current] = 1u + counts[current];
		current = 1;
	}
	def render(buf: TraceBuilder) -> StringBuilder {
		buf.put1("func %q:", func.render(module.names, _)).ln();
		counts.apply(fun (key: int, count: u64) {
			buf.puts("  x ").mark().putd(count).putc(':').ljustify_mark(5).sp();
			while (key >= 1) {
				var taken = (key & 1) != 0;
				if (taken) buf.putc('t');
				else buf.putc('.');
				key >>= 1;
			}
			buf.ln();
		});
		return buf;
	}
}
