// Copyright 2025 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Threads {
	def newThread(f: Function, args: Range<Value>) -> WasmStack;
	def yield(curStack: WasmStack) -> WasmStack;
	def switch(curStack: WasmStack, next: WasmStack);
}

/*
 Random thoughts:
 - main thread is expected to return values (from host->wasm call)
   and has a return_parent stub
 - internal threads are spawned by other means (not host->wasm calls)
   and will exit into their thread groups
 - an internal thread exiting should give up control to another thread
 - if there is another thread, then the containing host thread "exits"
 - if that containing host thread wanted return values (because of a host call)
   but there are no runnable threads, block waiting for one
 - if there are no threads to block on, then throw

Useful functionality:
 - show thread status with stacks
 - sample thread stacks
 - get a parallel event graph of thread interactions

*/

/*
- add case to Resumption: Switch
- handle Resumption.Switch in V3Interpreter, X86_64Runtime
- strategy 1:
  runtime overwrites return address to thread-switch-stub

- class WasmStack {
  var thread_group: ThreadGroup;
  var preserved_return_address: Pointer<code>;
  var next_thread: WasmStack;

  def threadSwitchStub() {
    var next_thread = this.next_thread;
    this.rsp.store<Pointer>(preserved_return_address);
    this.preserved_return_address = 0;
    this.target_stack = null;
    GROUP.parkUnpark(this, next_thread);
    runtime.curStack = next_thread;
    CPU.rsp = next_thread.rsp;
    CPU.return()
  }

- exit-thread-stub
  bottom frame of stacks created as part of a thread group
  sets thread status in thread group and reschedules (switches to another runnable thread)
*/