// Copyright 2020-2025 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// WebAssembly program values.
type Value {
	case Ref(val: Object);
	case I31(val: u31);
	case I32(val: u32);
	case I64(val: u64);
	case F32(bits: u32);
	case F64(bits: u64);
	case V128(low: u64, high: u64);
}

// Categorization of values into storage kinds.
enum ValueKind(code: byte) {
	I32(BpTypeCode.I32.code),
	I64(BpTypeCode.I64.code),
	F32(BpTypeCode.F32.code),
	F64(BpTypeCode.F64.code),
	V128(BpTypeCode.V128.code),
	REF(BpTypeCode.REF.code),
}

// Superclass of all objects referred to by Value.Ref, including external refs.
class Object extends Exportable { }

class ObjectI31(val: u31) extends Object { }

// Objects allocated on the "wasm" GC heap, i.e. from the GC proposal.

class HeapObject extends Object {
	def decl: HeapTypeDecl;
	new(decl) { }
}

// superclass of struct representations; defines getter/setter interface
class HeapStructGeneric extends HeapObject {
	new(decl: StructDecl) super(decl) { }

	def getFieldValue(index: u31) -> Value;
	def getFieldSignExtend8Value(index: u31) -> Value;
	def getFieldSignExtend16Value(index: u31) -> Value;
	def getFieldZeroExtend8Value(index: u31) -> Value;
	def getFieldZeroExtend16Value(index: u31) -> Value;
	def getFieldI32(index: u32) -> i32;
	def getFieldI64(index: u32) -> i64;
	def getFieldI8(index: u32) -> i8;
	def getFieldI16(index: u32) -> i16;
	def getFieldF32(index: u32) -> float;
	def getFieldF64(index: u32) -> double;
	def getFieldRef(index: u32) -> Object;
	def getFieldTRef(index: u32) -> Object;
	def getFieldV128(index: u32) -> (u64, u64);

	def setFieldValue(index: u31, val: Value);
	def setFieldI32(index: u32, val: i32);
	def setFieldI64(index: u32, val: i64);
	def setFieldI8(index: u32, val: i8);
	def setFieldI16(index: u32, val: i16);
	def setFieldF32(index: u32, val: float);
	def setFieldF64(index: u32, val: double);
	def setFieldRef(index: u32, val: Object);
	def setFieldTRef(index: u32, val: Object);
	def setFieldV128(index: u32, low: u64, high: u64);
}

// Original Array<Value> struct representation
// Provides definitions for Value getters/setter (only)
class HeapStruct extends HeapStructGeneric {
	def vals: Array<Value>;
	new(decl: StructDecl, vals) super(decl) { }

	def getFieldValue(index: u31) -> Value { return vals[index]; }
	def getFieldSignExtend8Value(index: u31) -> Value { return Value.I32(u32.view(i8.view(Value.I32.!(vals[index]).val))); }
	def getFieldSignExtend16Value(index: u31) -> Value { return Value.I32(u32.view(i16.view(Value.I32.!(vals[index]).val))); }
	def getFieldZeroExtend8Value(index: u31) -> Value { return Value.I32(u32.view(u8.view(Value.I32.!(vals[index]).val))); }
	def getFieldZeroExtend16Value(index: u31) -> Value { return Value.I32(u32.view(u16.view(Value.I32.!(vals[index]).val))); }

	def setFieldValue(index: u31, val: Value) { vals[index] = val; }
}

// Paired array representation: an Array<Object> holds all the reference fields,
// and an Array<byte> holds all the primitive values
class HeapStructPair extends HeapStructGeneric {
	def objs: Array<Object>;
	def bytes: Array<byte>;
	new(decl: StructDecl, objs, bytes) super(decl) { }

	def getFieldValue(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		match (decl.field_shifts[index]) {
			-1 => {
				return Value.Ref(objs[decl.field_offsets[index]]);
			}
			0 => {
				var v = bytes[decl.field_offsets[index]];
				return Value.I32(u32.view(v));
			}
			1 => {
				var v = Ref<Layout_u16>.at(bytes, decl.field_offsets[index]).val;
				return Value.I32(u32.view(v));
			}
			2 => {
				var v = Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val;
				return if(decl.field_types[index].valtype == ValueType.I32, Value.I32(v), Value.F32(v));
			}
			3 => {
				var v = Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val;
				return if(decl.field_types[index].valtype == ValueType.I64, Value.I64(v), Value.F64(v));
			}
			4 => {
				var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
				return Value.V128(r.lo_val, r.hi_val);
			}
		}
		return Value.I32(u32.view(-1));
	}
	def getFieldSignExtend8Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_i8>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(i32.!(v)));
	}
	def getFieldSignExtend16Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_i16>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(i32.!(v)));
	}
	def getFieldZeroExtend8Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_u8>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(v));
	}
	def getFieldZeroExtend16Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_u16>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(v));
	 }
	def getFieldI32(index: u32) -> i32 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.I32)) { return -1; }
		var v = Ref<Layout_i32>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldI64(index: u32) -> i64 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.I64)) { return -1; }
		var v = Ref<Layout_i64>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldI8(index: u32) -> i8 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && ft.pack != Packedness.PACKED_I8) { return -1; }
		var v = Ref<Layout_i8>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldI16(index: u32) -> i16 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && ft.pack != Packedness.PACKED_I16) { return -1; }
		var v = Ref<Layout_i16>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldF32(index: u32) -> float {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.F32)) { return -1f; }
		var v = Ref<Layout_float>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldF64(index: u32) -> double {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.F64)) { return -1d; }
		var v = Ref<Layout_double>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldRef(index: u32) -> Object {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && ValueType.Ref.?(ft.valtype)) { return null; }
		return objs[decl.field_offsets[index]];
	}
	def getFieldV128(index: u32) -> (u64, u64) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.V128)) { return (u64.view(-1), u64.view(-1)); }
		var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
		return (r.lo_val, r.hi_val);
	}
	def setFieldValue(index: u31, val: Value) {
		var decl = StructDecl.!(this.decl);
		match (decl.field_shifts[index]) {
			-1 => {
				objs[decl.field_offsets[index]] = Value.Ref.!(val).val;
			}
			0 => {
				bytes[decl.field_offsets[index]] = u8.view(Value.I32.!(val).val);
			}
			1 => {
				Ref<Layout_u16>.at(bytes, decl.field_offsets[index]).val = u16.view(Value.I32.!(val).val);
			}
			2 => {
				if (Value.I32.?(val)) {
					Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val = Value.I32.!(val).val;
				} else {
					Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val = Value.F32.!(val).bits;
				}
			}
			3 => {
				if (Value.I64.?(val)) {
					Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val = Value.I64.!(val).val;
				} else {
					Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val = Value.F64.!(val).bits;
				}
			}
			4 => {
				var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
				var pair = Value.V128.!(val);
				r.lo_val = pair.low;
				r.hi_val = pair.high;
			}
		}
	}
	def setFieldI32(index: u32, val: i32) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.I32)) {
			Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val = u32.view(val);
		}
	}
	def setFieldI64(index: u32, val: i64) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.I64)) {
			Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val = u64.view(val);
		}
	}
	def setFieldI8(index: u32, val: i8) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || ft.pack == Packedness.PACKED_I8) {
			bytes[decl.field_offsets[index]] = u8.view(val);
		}
	}
	def setFieldI16(index: u32, val: i16) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || ft.pack == Packedness.PACKED_I16) {
			Ref<Layout_i16>.at(bytes, decl.field_offsets[index]).val = val;
		}
	}
	def setFieldF32(index: u32, val: float) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.F32)) {
			Ref<Layout_float>.at(bytes, decl.field_offsets[index]).val = val;
		}
	 }
	def setFieldF64(index: u32, val: double) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.F64)) {
			Ref<Layout_double>.at(bytes, decl.field_offsets[index]).val = val;
		}
	}
	def setFieldRef(index: u32, val: Object) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || ValueType.Ref.?(ft.valtype)) {
			objs[decl.field_offsets[index]] = val;
		}
	}
	def setFieldV128(index: u32, low: u64, high: u64) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.V128)) {
			var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
			r.lo_val = low;
			r.hi_val = high;
		}
	}
}

// superclass of array representations; defines getter/setter interface
class HeapArrayGeneric extends HeapObject {
	new(decl: ArrayDecl) super(decl) { }

	def length() -> int;

	// get whole array - useful for copy operations, etc.
	def getArray<U>() -> Array<U>;

	def getValues() -> Array<Value> {
		var vals = Array<Value>.new(length());
		for (i < length()) {
			vals[i] = getValue(u32.!(i));
		}
		return vals;
	}

	def getValue(index: u32) -> Value;
	def setValue(index: u32, val: Value);

	def getI32(index: u32) -> i32;
	def setI32(index: u32, val: i32);

	def getI31(index: u32) -> i31;
	def setI31(index: u32, val: i31);

	def getI64(index: u32) -> i64;
	def setI64(index: u32, val: i64);

	def getI8(index: u32) -> i8;
	def setI8(index: u32, val: i8);

	def getI16(index: u32) -> i16;
	def setI16(index: u32, val: i16);

	def getF32(index: u32) -> float;
	def setF32(index: u32, val: float);

	def getF64(index: u32) -> double;
	def setF64(index: u32, val: double);

	def getRef(index: u32) -> Object;
	def setRef(index: u32, val: Object);

	def getV128(index: u32) -> (u64, u64);
	def setV128(index: u32, low: u64, high: u64);

	def getU32(index: u32) -> u32;
	def getU64(index: u32) -> u64;
	def getU8(index: u32) -> u8;
	def getU16(index: u32) -> u16;
}

// Original Array<Value> representation
// Note: bounds checks will already have been done
class HeapArrayValue extends HeapArrayGeneric {
	def vals: Array<Value>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getArray<U>() -> Array<U> {
		return Array<U>.!(vals);
	}
	def getValues() -> Array<Value> {
		return vals;
	}

	def getValue(index: u32) -> Value {
		return vals[index];
	}
	def setValue(index: u32, val: Value) {
		vals[index] = val;
	}
	def getI32(index: u32) -> i32 {
		return i32.view(Value.I32.!(vals[index]).val);
	}
	def setI32(index: u32, val: i32) {
		vals[index] = Value.I32(u32.view(val));
	}
	def getI31(index: u32) -> i31 {
		return i31.view(Value.I31.!(vals[index]).val);
	}
	def setI31(index: u32, val: i31) {
		vals[index] = Value.I31(u31.view(val));
	}
	def getI64(index: u32) -> i64 {
		return i64.view(Value.I64.!(vals[index]).val);
	}
	def setI64(index: u32, val: i64) {
		vals[index] = Value.I64(u64.view(val));
	}
	def getI8(index: u32) -> i8 {
		return i8.view(Value.I32.!(vals[index]).val);
	}
	def setI8(index: u32, val: i8) {
		vals[index] = Value.I32(u32.view(val));
	}
	def getI16(index: u32) -> i16 {
		return i16.view(Value.I32.!(vals[index]).val);
	}
	def setI16(index: u32, val: i16) {
		vals[index] = Value.I32(u32.view(val));
	}
	def getF32(index: u32) -> float {
		return float.view(Value.F32.!(vals[index]).bits);
	}
	def setF32(index: u32, val: float) {
		vals[index] = Value.F32(u32.view(val));
	}
	def getF64(index: u32) -> double {
		return double.view(Value.F64.!(vals[index]).bits);
	}
	def setF64(index: u32, val: double) {
		vals[index] = Value.F64(u64.view(val));
	}
	def getRef(index: u32) -> Object {
		return Value.Ref.!(vals[index]).val;
	}
	def setRef(index: u32, val: Object) {
		vals[index] = Value.Ref(val);
	}
	def getV128(index: u32) -> (u64, u64) {
		var val = Value.V128.!(vals[index]);
		return (val.low, val.high);
	}
	def setV128(index: u32, low: u64, high: u64) {
		vals[index] = Value.V128(low, high);
	}
}

// Paired array representation: an Array<Object> is used for reference arrays,
// and an Array<byte> for primitive arrays; the unused array will be null.
class HeapArrayPair extends HeapArrayGeneric {
	def objs: Array<Object>;
	def bytes: Array<byte>;
	def shift: byte;  // the shift amount for indexing the byte array, etc.
	new(decl: ArrayDecl, objs, bytes, shift) super(decl) { }

	def length() -> int {
		// Check shift to decide which array: shift == OBJS_SHIFT means Ref array
		if (shift == Values.OBJS_SHIFT) {
			return objs.length;
		} else {
			return bytes.length >> shift;
		}
	}

	def getValue(index: u32) -> Value {
		var d = ArrayDecl.!(decl);
		match (d.elem_types[0].pack) {
			UNPACKED => {
				match (d.elem_types[0].valtype) {
					I32 => return Value.I32(getU32(index));
					I64 => return Value.I64(getU64(index));
					F32 => return Value.F32(getU32(index));
					F64 => return Value.F64(getU64(index));
					Ref(nullable, heaptype) => {
						if (heaptype == HeapType.I31 && !nullable) {
							return Value.I31(u31.view(getI31(index)));
						} else {
							match (getRef(index)) {
								x: ObjectI31 => return Value.I31(x.val);
								x: Object => return Value.Ref(x);
								_ => return Values.REF_NULL;
							}
						}
					}
					V128 => {
						var v128 = getV128(index);
						return Value.V128(v128.0, v128.1);
					}
					_ => {
						// This case should not happen
						return Value.Ref(null);
					}
				}
			}
			PACKED_I8 => return Value.I32(u32.view(i32.!(getI8(index))));
			PACKED_I16 => return Value.I32(u32.view(i32.!(getI16(index))));
		}
	}
	def setValue(index: u32, val: Value) {
		var d = ArrayDecl.!(decl);
		match (d.elem_types[0].pack) {
			UNPACKED => {
				match (d.elem_types[0].valtype) {
					I32 => setI32(index, i32.view(Value.I32.!(val).val));
					I64 => setI64(index, i64.view(Value.I64.!(val).val));
					F32 => setF32(index, float.view(Value.F32.!(val).bits));
					F64 => setF64(index, double.view(Value.F64.!(val).bits));
					Ref(nullable, heaptype) => {
						if (heaptype == HeapType.I31 && !nullable) {
							var uv: i31;
							match (val) {
								I31(v) => uv = i31.!(v);
								_ => ;
							}
							setI31(index, uv);
						} else {
							var obj: Object;
							match (val) {
								Ref(o) => obj = o;
								I31(v) => obj = ObjectI31.new(v);
								_ => obj = null;
							}
							setRef(index, obj);
						}
					}
					V128 => {
						var v128 = Value.V128.!(val);
						setV128(index, v128.low, v128.high);
					}
					_ => ;  // This case should not happen
				}
			}
			PACKED_I8 => setI8(index, i8.view(Value.I32.!(val).val));
			PACKED_I16 => setI16(index, i16.view(Value.I32.!(val).val));
		}
	}

	def getI32(index: u32) -> i32 {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.I32)) {
			var offset = int.!(index << 2);
			return Ref<Layout_i32>.at(bytes, offset).val;
		} else {
			return -1;
		}
	}
	def setI32(index: u32, val: i32) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.I32)) {
			var offset = int.!(index << 2);
			Ref<Layout_i32>.at(bytes, offset).val = val;
		}
	}
	def getI31(index: u32) -> i31 {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.Ref(false, HeapType.I31))) {
			var offset = int.!(index << 2);
			return Ref<Layout_i31>.at(bytes, offset).val;
		} else {
			return -1;
		}
	}
	def setI31(index: u32, val: i31) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.Ref(false, HeapType.I31))) {
			var offset = int.!(index << 2);
			Ref<Layout_i31>.at(bytes, offset).val = val;
		}
	}
	def getI64(index: u32) -> i64 {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.I64)) {
			var offset = int.!(index << 3);
			return Ref<Layout_i64>.at(bytes, offset).val;
		} else {
			return -1;
		}
	}
	def setI64(index: u32, val: i64) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.I64)) {
			var offset = int.!(index << 3);
			Ref<Layout_i64>.at(bytes, offset).val = val;
		}
	}

	def getI8(index: u32) -> i8 {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || etype.pack == Packedness.PACKED_I8) {
			var offset = int.!(index);
			return i8.view(bytes[offset]);
		} else {
			return -1;
		}
	}
	def setI8(index: u32, val: i8) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || etype.pack == Packedness.PACKED_I8) {
			var offset = int.!(index);
			bytes[offset] = u8.view(val);
		}
	}
	def getI16(index: u32) -> i16 {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || etype.pack == Packedness.PACKED_I16) {
			var offset = int.!(index << 1);
			return Ref<Layout_i16>.at(bytes, offset).val;
		} else {
			return -1;
		}
	}
	def setI16(index: u32, val: i16) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || etype.pack == Packedness.PACKED_I16) {
			var offset = int.!(index << 1);
			Ref<Layout_i16>.at(bytes, offset).val = val;
		}
	}
	def getF32(index: u32) -> float {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.F32)) {
			var offset = int.!(index << 2);
			return Ref<Layout_float>.at(bytes, offset).val;
		} else {
			return -1f;
		}
	}
	def setF32(index: u32, val: float) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.F32)) {
			var offset = int.!(index << 2);
			Ref<Layout_float>.at(bytes, offset).val = val;
		}
	}
	def getF64(index: u32) -> double {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.F64)) {
			var offset = int.!(index << 3);
			return Ref<Layout_double>.at(bytes, offset).val;
		} else {
			return -1d;
		}
	}
	def setF64(index: u32, val: double) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || (etype.pack == Packedness.UNPACKED && etype.valtype == ValueType.F64)) {
			var offset = int.!(index << 3);
			Ref<Layout_double>.at(bytes, offset).val = val;
		}
	}
	def getRef(index: u32) -> Object {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || ValueType.Ref.?(etype.valtype)) {
			return objs[index];
		} else {
			return null;
		}
	}
	def setRef(index: u32, val: Object) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || ValueType.Ref.?(etype.valtype)) {
			objs[index] = val;
		}
	}
	def getV128(index: u32) -> (u64, u64) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || etype.valtype == ValueType.V128) {
			var offset = int.!(index << 4);
			var r = Ref<Layout_u128>.at(bytes, offset);
			return (r.lo_val, r.hi_val);
		} else {
			return (u64.view(-1), u64.view(-1));
		}
	}
	def setV128(index: u32, low: u64, high: u64) {
		var d = ArrayDecl.!(decl);
		var etype = d.elem_types[0];
		if (Values.NO_CHECKS || etype.valtype == ValueType.V128) {
			var offset = int.!(index << 4);
			var r = Ref<Layout_u128>.at(bytes, offset);
			r.lo_val = low;
			r.hi_val = high;
		}
	}
	def getU32(index: u32) -> u32 {
		if (Values.NO_CHECKS || shift == 2) {
			var offset = int.!(index << 2);
			return Ref<Layout_u32>.at(bytes, offset).val;
		} else {
			return u32.view(-1);
		}
	}
	def getU64(index: u32) -> u64 {
		if (Values.NO_CHECKS || shift == 3) {
			var offset = int.!(index << 3);
			return Ref<Layout_u64>.at(bytes, offset).val;
		} else {
			return u64.view(-1);
		}
	}
	def getU8(index: u32) -> u8 {
		if (Values.NO_CHECKS || shift == 0) {
			var offset = int.!(index);
			return bytes[offset];
		} else {
			return u8.view(-1);
		}
	}
	def getU16(index: u32) -> u16 {
		if (Values.NO_CHECKS || shift == 1) {
			var offset = int.!(index << 1);
			return Ref<Layout_u16>.at(bytes, offset).val;
		} else {
			return u16.view(-1);
		}
	}
}


// Implementations of arrays of specific types
class HeapArrayI32 extends HeapArrayGeneric {
	def vals: Array<u32>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u32.view(Value.I32.!(val).val);
	}
	def getI32(index: u32) -> i32 {
		return i32.view(vals[index]);
	}
	def setI32(index: u32, val: i32) {
		vals[index] = u32.view(val);
	}
}

class HeapArrayI31 extends HeapArrayGeneric {
	def vals: Array<u31>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I31(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u31.view(Value.I31.!(val).val);
	}
	def getI31(index: u32) -> i31 {
		return i31.view(vals[index]);
	}
	def setI31(index: u32, val: i31) {
		vals[index] = u31.view(val);
	}
}

class HeapArrayI64 extends HeapArrayGeneric {
	def vals: Array<u64>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I64(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u64.view(Value.I64.!(val).val);
	}
	def getI64(index: u32) -> i64 {
		return i64.view(vals[index]);
	}
	def setI64(index: u32, val: i64) {
		vals[index] = u64.view(val);
	}
}

class HeapArrayI8 extends HeapArrayGeneric {
	def vals: Array<u8>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u8.view(Value.I32.!(val).val);
	}
	def getI8(index: u32) -> i8 {
		return i8.view(vals[index]);
	}
	def setI8(index: u32, val: i8) {
		vals[index] = u8.view(val);
	}
}

class HeapArrayI16 extends HeapArrayGeneric {
	def vals: Array<u16>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u16.view(Value.I32.!(val).val);
	}
	def getI16(index: u32) -> i16 {
		return i16.view(vals[index]);
	}
	def setI16(index: u32, val: i16) {
		vals[index] = u16.view(val);
	}
}

class HeapArrayF32 extends HeapArrayGeneric {
	def vals: Array<u32>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.F32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u32.view(Value.F32.!(val).bits);
	}
	def getF32(index: u32) -> float {
		return if(index >= 0 && index < vals.length, float.view(vals[index]), -1);
	}
	def setF32(index: u32, val: float) {
		if (index >= 0 && index < vals.length) {
			vals[index] = u32.view(val);
		}
	}
}

class HeapArrayF64 extends HeapArrayGeneric {
	def vals: Array<u64>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.F64(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u64.view(Value.F64.!(val).bits);
	}
	def getF64(index: u32) -> double {
		return double.view(vals[index]);
	}
	def setF64(index: u32, val: double) {
		vals[index] = u64.view(val);
	}
}

class HeapArrayRef extends HeapArrayGeneric {
	def vals: Array<Object>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		match (vals[index]) {
			x: ObjectI31 => return Value.I31(x.val);
			x: Object => return Value.Ref(x);
			_ => return Values.REF_NULL;
		}
	}
	def setValue(index: u32, val: Value) {
		var obj: Object;
		match (val) {
			Ref(v) => obj = v;
			I31(v) => obj = ObjectI31.new(v);
			_ => ;
		}
		vals[index] = obj;
	}
	def getRef(index: u32) -> Object {
		return vals[index];
	}
	def setRef(index: u32, val: Object) {
		vals[index] = val;
	}
}

// A v128 uses two adjacent u64 entries in the vals array
class HeapArrayV128 extends HeapArrayGeneric {
	def vals: Array<u64>; // The array format: [low 0, high 0, low 1, high 1, ...]
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length >> 1; }

	def getValue(index: u32) -> Value {
		var idx = index << 1;
		return Value.V128(vals[idx], vals[idx+1]);
	}
	def setValue(index: u32, val: Value) {
		var idx = index << 1;
		var v128 = Value.V128.!(val);
		vals[idx] = u64.view(v128.low);
		vals[idx+1] = u64.view(v128.high);
	}
	def getV128(index: u32) -> (u64, u64) {
		var idx = index << 1;
		return (vals[idx], vals[idx+1]);
	}
	def setV128(index: u32, low: u64, high: u64) {
		var idx = index << 1;
		vals[idx] = low;
		vals[idx+1] = high;
	}
}

// Utilities associated with values.
component Values {
	def I32_1 = Value.I32(1);
	def I32_0 = Value.I32(0);
	def I64_0 = Value.I64(0);
	def F32_0 = Value.F32(0);
	def F64_0 = Value.F64(0);
	def V128_0 = Value.V128(0, 0);
	def F32_minus_0		= Value.F32(0x8000_0000);
	def F64_minus_0		= Value.F64(0x8000_0000_0000_0000);
	def F32_nan		= Value.F32(0x7fc0_0000);
	def F64_nan		= Value.F64(0x7ff8_0000_0000_0000);
	def F32_infinity	= Value.F32(0x7f80_0000);
	def F64_infinity	= Value.F64(0x7ff0_0000_0000_0000);
	def F32_minus_infinity	= Value.F32(0xff80_0000);
	def F64_minus_infinity	= Value.F64(0xfff0_0000_0000_0000);
	def FUNCREF_NULL = Value.Ref(null);
	def REF_NULL = FUNCREF_NULL;
	def NONE = Array<Value>.new(0);
	def OBJS_SHIFT = 255u8;
	def NO_CHECKS = false;

	def render(v: Value, buf: StringBuilder) -> StringBuilder {
		match (v) {
			Ref(val) => match (val) {
				x: HostObject => buf.put1("<externref %q>", x.render);
				x: WasmFunction => buf.put1("<funcref: #%d>", x.decl.func_index);
				x: HeapStruct => {
					var id = if(x.decl == null, -1, x.decl.heaptype_index);
					buf.put1("<ref struct #%d>", id);
				}
				x: HeapArrayGeneric => {
					var id = if(x.decl == null, -1, x.decl.heaptype_index);
					buf.put1("<ref array #%d>", id);
				}
				x: Continuation => buf.put1("<continuation %q>", x.render);
				x: Object => x.render(buf);
				null => buf.puts("<ref null>");
			}
			I31(val) => buf.put1("i31:%d", u32.view(val));
			I32(val) => buf.put1("%d", val);
			I64(val) => buf.put1("%duL", val);
			F32(val) => buf.put1("f32:%x", val);
			F64(val) => buf.put1("f64:%x", val);
			V128(low, high) => buf.puts("v128:").putx_64(high).putc('_').putx_64(low);
		}
		return buf;
	}
	def renderVals(buf: StringBuilder, av: Range<Value>) -> StringBuilder {
		buf.putc('(');
		Trace.renderCspRange(buf, av, Values.render);
		buf.putc(')');
		return buf;
	}
	def isNull(v: Value) -> bool {
		return v == REF_NULL;
	}
	def isFunc(v: Value) -> bool {
		return Value.Ref.?(v) && Function.?(Value.Ref.!(v).val);
	}
	def isData(v: Value) -> bool {
		match (v) {
			Ref(o) => return HeapObject.?(o) || HeapArrayGeneric.?(o);
			_ => return false;
		}
	}
	def isArray(v: Value) -> bool {
		match (v) {
			Ref(o) => return HeapArrayGeneric.?(o);
			_ => return false;
		}
	}
	def isI31(v: Value) -> bool {
		return Value.I31.?(v);
	}
	def default(t: ValueType) -> Value {
		var v: Value;
		match (t) {
			BOTTOM => v = REF_NULL; // TODO: no default for bottom
			I32 => v = I32_0;
			I64 => v = I64_0;
			F32 => v = F32_0;
			F64 => v = F64_0;
			V128 => v = V128_0;
			Host,
			Ref => v = REF_NULL;
		}
		return v;
	}
	// Unboxing utilities.
	def unbox_i(v: Value) =>	i32.view(Value.I32.!(v).val);
	def unbox_u(v: Value) =>	Value.I32.!(v).val;
	def unbox_u8(v: Value) =>	u8.view(Value.I32.!(v).val);
	def unbox_u16(v: Value) =>	u16.view(Value.I32.!(v).val);
	def unbox_fu32(v: Value) =>	Value.F32.!(v).bits;
	def unbox_du64(v: Value) =>	Value.F64.!(v).bits;
	def unbox_f(v: Value) =>	float.view(Value.F32.!(v).bits);
	def unbox_d(v: Value) =>	double.view(Value.F64.!(v).bits);
	def unbox_l(v: Value) =>	i64.view(Value.I64.!(v).val);
	def unbox_w(v: Value) =>	Value.I64.!(v).val;
	def unbox_w8(v: Value) =>	u8.view(Value.I64.!(v).val);
	def unbox_w16(v: Value) =>	u16.view(Value.I64.!(v).val);
	def unbox_w32(v: Value) =>	u32.view(Value.I64.!(v).val);
	def unbox_s(v: Value) -> (u64, u64) {
		var b = Value.V128.!(v);
		return (b.low, b.high);
	}
	def box_b(b: bool) => Value.I32(if(b, 1, 0));
	// Reflective unboxing.
	def unbox<T>(v: Value) -> T {
		match (Type<T>()) {
			x: Type<int> => return T.!(unbox_i(v));
			x: Type<u32> => return T.!(unbox_u(v));
			x: Type<long> => return T.!(unbox_l(v));
			x: Type<u64> => return T.!(unbox_w(v));
			x: Type<float> => return T.!(unbox_f(v));
			x: Type<double> => return T.!(unbox_d(v));
			x: Type<(u64, u64)> => return T.!(unbox_s(v));
			x: Type<Object> => return T.!(Value.Ref.!(v).val);
			_ => ;
		}
		match (v) {
			Ref(val) => return T.!(val);
			I31(val) => return T.!(val);
			I32(val) => return T.!(val);
			I64(val) => return T.!(val);
			F32(bits) => return T.!(float.view(bits));
			F64(bits) => return T.!(double.view(bits));
			V128(low, high) => return T.!((low, high));
		}
	}

	// Boxing utilities.
	def box_i(v: i32) => Value.I32(u32.view(v));
	def box_u(v: u32) => Value.I32(v);
	def box_l(v: i64) => Value.I64(u64.view(v));
	def box_f(v: float) => Value.F32(u32.view(v));
	def box_d(v: double) => Value.F64(u64.view(v));
	def box_fu32(v: u32) => Value.F32(v);
	def box_du64(v: u64) => Value.F64(v);
	def box_w(v: u64) => Value.I64(v);
	def box_s(x: u64, y: u64) => Value.V128(x, y);
	// Reflective boxing.
	def box<T>(v: T) -> Value {
		match (Type<T>()) {
			x: Type<int> => return box_i(int.!(v));
			x: Type<u32> => return box_u(u32.!(v));
			x: Type<long> => return box_l(long.!(v));
			x: Type<u64> => return box_w(u64.!(v));
			x: Type<float> => return box_f(float.!(v));
			x: Type<double> => return box_d(double.!(v));
			x: Type<(u64, u64)> => return box_s(Type<(u64, u64)>().cast(v));
			x: Type<Object> => return Value.Ref(Object.!(v));
			_ => ;
		}
		match (v) {
			x: i32 => return box_i(x);
			x: u32 => return box_u(x);
			x: i64 => return box_l(x);
			x: u64 => return box_w(x);
			x: Object => return Value.Ref(x);
			_ => System.error("BoxError", "no matching boxing operation for Virgil value");

		}
		return Values.REF_NULL;
	}

	def toFuncAndId(val: Value) -> (Function, int) {
		match (val) {
			Ref(val) => match (val) {
				x: Function => return (x, Canon.sigId(x.sig));
			}
			_ => ;
		}
		return (null, -1);
	}
	def kind(val: Value) -> ValueKind {
		match (val) {
			I32 => return ValueKind.I32;
			I64 => return ValueKind.I64;
			F32 => return ValueKind.F32;
			F64 => return ValueKind.F64;
			V128 => return ValueKind.V128;
			_ => return ValueKind.REF;
		}
	}
}
private type Type<T>() #unboxed {
	def cast<B>(v: B) => T.!(v);
}
