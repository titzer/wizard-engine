component Target {
 	def newWasmStack = fun () => CBDV3Interpreter.new(V3Interpreter.new());
	def interpreter = CBDV3Interpreter.new(V3Interpreter.new());
	
	var unused_ = ExecuteOptions.registerDefaultMode("cbd-int", CBDInterpreterOnlyStrategy.new(), "CBD interpreter only");

	// copied from V3Target.v3
 	def limit_memory_pages = 30000u;
 	def newMemory = V3Memory.new;
 	def forceGC() { } // nop
 	def ticksNs() -> u64 { return u32.view(System.ticksNs()); }
 	def rdtsc() -> u64 { return u32.view(System.ticksNs()); }
 	def getRdtsc() -> (void -> u64) { return rdtsc; }
 	def pregenIntoFile(filename: string) -> ErrorBuilder {
 		return ErrorBuilder.new().puts("interpreter generator: nothing to generate for this target");
 	}
 
 	def getTestTiers() -> List<(string, ExecutionStrategy)> {
 		var int_mode = ("cbd:", CBDInterpreterOnlyStrategy.new());
 		return List.new(int_mode, null);
 	}
 	def fastFwCopy(dst: Range<byte>, src: Range<byte>) {
 		var i = 0u, max = dst.length & ~7;
 		// XXX: for targets without efficient ByteArrayGetField access, a byte-by-byte copy is faster.
 		while (i < max) {
 			var dref = Ref<Layout_u64>.of(dst[i ...]); // XXX: use at with Range?
 			var sref = Ref<Layout_u64>.of(src[i ...]); // XXX: use at with Range?
 			dref.val = sref.val;
 			i += 8;
 		}
 		while (i < dst.length) {
 			dst[i] = src[i];
 			i++;
 		}
 	}
}

class CBDInterpreterOnlyStrategy extends ExecutionStrategy {
	// Called upon selection of this strategy (e.g. by command-line flag).
	def onActivate() { }

	// Called during execution startup and exit.
	def onEngineStart() { }
	def onEngineExit(code: int) { }

	// Called if monitors are activated for the program.
	def onMonitorsStart() { }
	def onFuncProbeInsert1(module: Module, func: FuncDecl, offset: int, p: Probe) { }
	def onFuncProbeInsert2(module: Module, func: FuncDecl, offset: int, p: Probe) { }
	def onFuncProbeInsertN(module: Module, func: FuncDecl, offset: int, p: Probe) { }
	def onFuncProbeRemove(module: Module, func: FuncDecl, offset: int) { }
	def onMonitorsFinish(module: Module, err: ErrorGen) { }

	// Called during binary decoding of a module and relevant sections.
	// Note that code validation has not yet been performed.
	// Example usage: pre-allocate code space and start compiler threads.
	def onModuleStart(module: Module, size: u32) { }			// note: size == 0 if estimate only
	def onCodeSectionStart(module: Module, num_funcs: u32, size: u32) { }
	def onFuncBody(module: Module, func_index: u32, body: Range<byte>, err: ErrorGen) { }
	def onCodeSectionFinish(module: Module, num_funcs: u32, size: u32, err: ErrorGen) { }
	def onModuleFinish(module: Module, size: u32, err: ErrorGen) {		// note: size is exact
        Target.interpreter.init_module(module);
    }

	// Called when a function has its code validated.
	// Example usage: do synchronous (AOT) one-off compile.
	def onFuncValidationStart(module: Module, func: FuncDecl) { }
	def onFuncValidationFinish(module: Module, func: FuncDecl, err: ErrorGen) { 
        if (Target.interpreter.sidetables == null) {
            Validator.init(module, []);
            Target.interpreter.sidetables = Array.new(module.functions.length);
        }
        def fn = CBDFunction.new(func);
        Validator.init_function(fn.code, fn.args.copy(), fn.locals.copy(), fn.rets.copy());
        Validator.dispatch();
        Target.interpreter.sidetables[func.func_index] = Validator.build_sidetable();
    }

	// Called when a module is instantiated.
	// Example usage: generate code specialized to import bindings.
	def onInstantiateStart(instantiator: Instantiator) { }
	def onInstantiateFinish(instantiator: Instantiator, err: ErrorGen) { } // XXX: never called for some reason

	// Called before a test run of a function. (For testing only).
	def onTestModule(m: Module) { }
	def onTestRun(wf: WasmFunction, err: ErrorGen) { }

	// Called if a new function is created in a module.
	def onNewFunction(wf: WasmFunction, err: ErrorGen) { }

	// Called if a function is detected as "hot" at a particular location (e.g. loop header)
	// that probably merits on-stack-replacement.
	def onTierUp(wf: WasmFunction, pc: int) -> TargetOsrInfo {
		var d: TargetOsrInfo;
		return d; // default: no OSR occurred
	}

	// Call a function with arguments and return a result.
	// Example implementation: call into the interpreter.
	def call(func: Function, args: Range<Value>) -> Result {
		Target.interpreter.it.reset(func).bind(args);
		Target.interpreter.dispatch();
		return Result.Value(Ranges.dup(Target.interpreter.it.values.peekn(func.sig.results.length)));
	}
}

 
type TargetOsrInfo #unboxed { }
type TargetCode #unboxed { }
type TargetModule #unboxed { }
type TargetFrame(frame: V3Frame) #unboxed {
	def getFrameAccessor() -> FrameAccessor {
		if (frame.accessor == null) frame.accessor = V3FrameAccessor.new(frame);
		return frame.accessor;
	}
}
class TargetHandlerDest(is_dummy: bool) { }
