// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class V3Interpreter extends WasmStack {
	var instrTracer: InstrTracer;
	def values = ArrayStack<Value>.new();	// storage of all WasmValues
	var state_: StackState;
	var goto_stack: V3Interpreter; // set when state_ == {CALL_CHILD|SUSPENDED|THROWING}
	var cache: V3Frame;			// cache of all V3Frame objects (bottom of stack)
	var frame: V3Frame;
	var host_frame: HostFrame;
	var host_outcall: HostFunction;
	def codeptr = CodePtr.new(null);	// pointer into code
	var thrown: Throwable;			// trap reason, if any
	var params_arity = -1;
	var return_arity = -1;

	var suspend_pc: int = -1;

	// WasmStack interface
	// ===================================================================================
	def state() -> StackState {
		return state_;
	}
	def reset(func: Function) -> this {
		checkState("reset()", StackState.EMPTY);
		pushFrame(func, 0);
		params_arity = func.sig.params.length;
		return_arity = func.sig.results.length;
		suspend_pc = -1;
		thrown = null;
		parent = null;
		state_ = if(params_arity == 0, StackState.RESUMABLE, StackState.SUSPENDED);
	}
	def bind(args: Range<Value>) -> this {
		if (args.length == 0 && state_ == StackState.RESUMABLE) return;
		checkState("bind()", StackState.SUSPENDED);
		if (params_arity < args.length) fatal(Strings.format2("bind() expected %d arguments, got %d", params_arity, args.length));
		values.pushr(args);
		params_arity -= args.length;
		if (params_arity == 0) state_ = StackState.RESUMABLE;
	}
	def resume() -> Result {
		checkState("resume()", StackState.RESUMABLE);
		thrown = null;
		goto_stack = null;

		// Set the initial state to running and loop until return, throw, or suspend.
		state_ = StackState.RUNNING;
		while (state_ == StackState.RUNNING) {
			// Run Wasm code until it either traps, suspends, or makes a host outcall.
			runWasmCode();
			// Run host calls until they either trap, return, or tail-call Wasm.
			runHostCall();
		}

		// Return the appropriate result.
		match (state_) {
			THROWING => {
				var t = thrown, cont = goto_stack;
				clear();
				if (cont == null) return Result.Throw(t);
				else return Result.Switch(cont); // handler found on parent stack
			}
			RETURNING => {
				var top = values.top;
				var vals = Ranges.dup(values.peekn(return_arity));
				clear();
				return Result.Value(vals);
			}
			SUSPENDED, CALL_CHILD => {
				return Result.Switch(goto_stack);
			}
			_ => {
				clear();
				var trap = Trap.new(TrapReason.ERROR, Strings.format1("invalid interpreter state: %s", state_.name), null);
				return Result.Throw(trap);
			}
		}
	}
	def popAllFrames(stacktrace: bool) -> StackSegment {
		var result: StackSegment;
		if (stacktrace) {
			var f = frame;
			var frames = Array<(WasmFunction, int)>.new(if(f != null, 1 + f.depth));
			var i = frames.length - 1;
			while (f != null) {
				frames[i--] = (f.func, f.pc);
				f = f.prev;
			}
			result = StackSegment.new(null, host_outcall, frames);
		}
		frame = null;
		host_outcall = null;
		return result;
	}

	def clear() -> this {
		state_ = StackState.EMPTY;
		values.top = 0;
		frame = null;
		host_outcall = null;
		return_arity = -1;
		params_arity = -1;
		codeptr.reset(null, 0, 0);
		suspend_pc = -1;
		goto_stack = null;
		thrown = null;
	}

	// Internal implementation: nominally private
	// ======================================================================================
	private def checkState(op: string, expected: StackState) {
		if (state_ != expected) fatal(Strings.format3("%s requires state == %s, got %s", op, expected.name, state_.name));
	}

	def pushFrame(f: Function, arity: int) {
		match (f) {
			hf: HostFunction => {
				host_outcall = hf;
			}
			wf: WasmFunction => {
				var next = frame = nextFrame(frame);
				if (next.depth > Execute.limits.max_call_depth) {
					trap(TrapReason.STACK_OVERFLOW);
					return;
				}
				next.func = wf;
				next.fp = values.top - arity;
				next.pc = 0;
				next.stp = 0;
				next.accessor = null;
				var code = wf.decl.cur_bytecode;
				codeptr.reset(code, 0, code.length);
			}
		}
	}
	private def nextFrame(caller: V3Frame) -> V3Frame {
		if (caller == null) {
			if (cache == null) return cache = V3Frame.new(this, null);
			return cache;
		}
		var next = caller.next;
		if (next == null) next = caller.next = V3Frame.new(this, caller);
		return next;
	}
	private def popFrame() -> V3Frame {
		if (frame == null) return null;
		frame.accessor = null;
		frame = frame.prev;
		if (frame == null) {
			codeptr.reset(null, 0, 0);
			return null;
		} else {
			var code = frame.func.decl.cur_bytecode;
			codeptr.reset(code, frame.pc, code.length);
			return frame;
		}
	}
	def pushLocals(count: u32, vtc: ValueTypeCode) {
		var val: Value;
		match (vtc.toValueKind(frame.func.instance)) {
			I32 => val = Values.I32_0;
			I64 => val = Values.I64_0;
			F32 => val = Values.F32_0;
			F64 => val = Values.F64_0;
			V128 => val = Values.V128_0;
			REF => val = Values.REF_NULL;
		}
		values.pushn(val, int.!(count));
	}
	def copyVals(count: int, dest: int) {
		var sp = values.top - count;
		if (sp != dest) {
			var e = values.elems;
			for (i < count) e[dest + i] = e[sp + i];
		}
		values.top = dest + count;
	}

	def runWasmCode() {
		while (state_ == StackState.RUNNING) {
			if (frame == null || host_outcall != null) return;
			var func = frame.func, pc = frame.pc;
			if (pc == 0) {
				// Enter the function and initialize locals.
				codeptr.iterate_local_codes(pushLocals);
				var tags = func.decl.frame_var_tags;
				if (tags != null) for (t in tags) values.push(tagToValue(t));
				frame.pc = pc = codeptr.pos; // update pc after decoding locals
				// Fire entry probe(s).
				if (func.decl.entry_probed) {
					var throwable = Instrumentation.fireLocalProbes(DynamicLoc(func, 0, TargetFrame(frame)));
					if (throwable != null) {
						throw(throwable);
						continue;
					}
				}
			}

			// Fire global probe(s).
			if (Instrumentation.probes != null) {
				var throwable = Instrumentation.fireGlobalProbes(DynamicLoc(func, pc, TargetFrame(frame)));
				if (throwable != null) {
					throw(throwable);
					continue;
				}
			}
			// Read the opcode.
			var b = codeptr.peek1();
			var opcode: Opcode;
			if (b == InternalOpcode.PROBE.code || b == InternalOpcode.WHAMM_PROBE.code) {
				// Fire local probe(s).
				var throwable = Instrumentation.fireLocalProbes(DynamicLoc(func, pc, TargetFrame(frame)));
				if (throwable != null) {
					throw(throwable);
					continue;
				}
				opcode = codeptr.read_orig_opcode(frame.func.decl.orig_bytecode[pc]);
			} else {
				opcode = codeptr.read_opcode();
			}
			execOp(pc, opcode);
		}
	}
	def runHostCall() {
		var hf: HostFunction;
		while ((hf = host_outcall) != null) {
			if (Trace.interpreter) Execute.traceCallHostFunction(hf);
			var sig = hf.sig, arity = sig.params.length;
			var oldVsp = values.top;
			var result = hf.invoke(values.peekn(arity));
			host_outcall = null;
			var newVsp = oldVsp - arity;
			values.top = newVsp;
			match (result) {
				Throw(thrown) => {
					host_outcall = hf; // needed for stacktrace
					return void(throw(thrown));
				}
				Value0 => {
					return doHostReturn(newVsp, sig);
				}
				Value1(val) => {
					values.push(val);
					return doHostReturn(newVsp, sig);
				}
				ValueN(vals) => {
					values.pusha(vals);
					return doHostReturn(newVsp, sig);
				}
				TailCall(f, args) => {
					values.pusha(args);
					pushFrame(f, args.length);
				}
			}
		}
	}
	def doHostReturn(fp: int, sig: SigDecl) {
		if (frame == null) doReturn(fp, sig);
		else advanceCaller();
	}
	def doCallFunction(f: Function) {
		if (frame != null) codeptr.at(frame.pc);
		pushFrame(f, f.sig.params.length);
	}
	def doReturn(fp: int, sig: SigDecl) {
		var count = sig.results.length;
		copyVals(count, fp);
		frame = popFrame();

		if (frame == null) {  // popped top frame, finished execution
			if (return_arity != count) fatal(Strings.format2("top-level return expected %d vals, got %d", return_arity, count));
			state_ = StackState.RETURNING;
		} else { // advance past caller's call instruction
			advanceCaller();
		}
	}
	def execOp(pc: int, opcode: Opcode) {
		if (Debug.interpreter && Trace.interpreter) traceStack();
		match (opcode) {
			UNREACHABLE => {
				trap(TrapReason.UNREACHABLE);
			}
			NOP => {
				// do nothing
			}
			TRY,
			BLOCK,
			LOOP => {
				codeptr.skip_block_type();
			}
			IF => {
				var cond = popi();
				if (cond == 0) {
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_block_type();
					doFallthru();
				}
			}
			CATCH,
			CATCH_ALL,
			ELSE => {
				codeptr.at(doGoto(pc));
			}
			DELEGATE => {
				codeptr.skip_label();
			}
			THROW => {
				var index = codeptr.read_uleb31();
				var tag = frame.func.instance.tags[index];
				var ex = Exception.new(tag, popN(tag.decl.fields), null);
				throw(ex);
			}
			RETHROW => {
				var sidetable = frame.func.decl.sidetable;
				var ex_slot = sidetable.entries[frame.stp];
				if (Trace.exception) Trace.OUT.put2("  rethrow fp=%d ex_slot=%d", frame.fp, ex_slot).ln();
				var popcount = sidetable.entries[frame.stp + 2], valcount = 0;
				if (popcount > 0) {
					copyVals(valcount, values.top - int.!(popcount + valcount));
				}
				frame.stp += 4;
				var exval = values.elems[frame.fp + frame.func.decl.num_locals + ex_slot];
				throw(Exception.!(Value.Ref.!(exval).val));
			}
			THROW_REF => {
				var exval = popr();
				throw(Exception.!(exval.val));
			}
			END => {
				if (codeptr.available() == 0) doReturn(frame.fp, frame.func.sig);
			}
			BR => {
				codeptr.at(doGoto(pc));
			}
			BR_IF => {
				var cond = popi();
				doBranch(pc, cond != 0);
			}
			BR_TABLE => {
				var key = popu();
				codeptr.at(doSwitch(pc, key));
			}
			RETURN => {
				doReturn(frame.fp, frame.func.sig);
			}
			CALL => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				return doCallFunction(f);
			}
			CALL_INDIRECT => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popa(frame.func.instance.tables[table_index].decl.size);
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) return doCallFunction(f);
			}
			RETURN_CALL => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				prepareReturnCall(f.sig);
				return doCallFunction(f);
			}
			RETURN_CALL_INDIRECT => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popa(frame.func.instance.tables[table_index].decl.size);
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) {
					prepareReturnCall(f.sig);
					return doCallFunction(f);
				}
			}
			CALL_REF => {
				var sig_index = codeptr.read_uleb32();
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) trap(TrapReason.NULL_DEREF);
				else return doCallFunction(func);
			}
			RETURN_CALL_REF => {
				var sig_index = codeptr.read_uleb32();
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) {
					trap(TrapReason.NULL_DEREF);
				} else {
					prepareReturnCall(func.sig);
					return doCallFunction(func);
				}
			}
			DROP => {
				pop();
			}
			SELECT => {
				var cond = popu(), b = pop(), a = pop();
				push(if(cond != 0, a, b));
			}
			SELECT_T => {
				var count = codeptr.skip_value_types();
				var cond = popu();
				if (cond != 0) {
					values.top -= count; // pop false values off the stack
				} else {
					copyVals(count, values.top - (count << 1)); // transfer false values down
				}
			}
			TRY_TABLE => {
				codeptr.skip_block_type();
				var count = codeptr.read_uleb31();
				for (i < count) codeptr.skip_catch();
				frame.stp += count * Sidetable_CatchEntry.size / 4; // TODO: catch entry size
			}
			LOCAL_GET => {
				var index = codeptr.read_uleb32();
				var val = values.elems[frame.fp + int.!(index)];
				push(values.elems[frame.fp + int.!(index)]);
			}
			LOCAL_SET => {
				var index = codeptr.read_uleb32();
				values.elems[frame.fp + int.!(index)] = pop();
			}
			LOCAL_TEE => {
				var index = codeptr.read_uleb32();
				values.elems[frame.fp + int.!(index)] = values.peek();
			}
			GLOBAL_GET => {
				var global_index = codeptr.read_uleb31();
				Runtime.GLOBAL_GET(this, frame.func.instance, global_index);
			}
			GLOBAL_SET => {
				var global_index = codeptr.read_uleb31();
				Runtime.GLOBAL_SET(this, frame.func.instance, global_index);
			}
			TABLE_GET => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_GET(this, frame.func.instance, table_index);
			}
			TABLE_SET => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_SET(this, frame.func.instance, table_index);
			}

			I32_LOAD 	=> doLoad(ACCESS_U32, pushu);
			I64_LOAD 	=> doLoad(ACCESS_U64, pushw);
			F32_LOAD 	=> doLoad(ACCESS_F32, pushf);
			F64_LOAD 	=> doLoad(ACCESS_F64, pushd);
			I32_LOAD8_S	=> doLoad(ACCESS_I8, pushi8);
			I32_LOAD8_U	=> doLoad(ACCESS_U8, pushu8);
			I32_LOAD16_S	=> doLoad(ACCESS_I16, pushi16);
			I32_LOAD16_U	=> doLoad(ACCESS_U16, pushu16);
			I64_LOAD8_S	=> doLoad(ACCESS_I8, pushl8);
			I64_LOAD8_U	=> doLoad(ACCESS_U8, pushw8);
			I64_LOAD16_S	=> doLoad(ACCESS_I16, pushl16);
			I64_LOAD16_U	=> doLoad(ACCESS_U16, pushw16);
			I64_LOAD32_S	=> doLoad(ACCESS_I32, pushl32);
			I64_LOAD32_U	=> doLoad(ACCESS_U32, pushw32);
			I32_STORE	=> doStore(ACCESS_U32, popu());
			I64_STORE	=> doStore(ACCESS_U64, popw());
			F32_STORE	=> doStore(ACCESS_F32, popf());
			F64_STORE	=> doStore(ACCESS_F64, popd());
			I32_STORE8	=> doStore(ACCESS_U8, popu8());
			I32_STORE16	=> doStore(ACCESS_U16, popu16());
			I64_STORE8	=> doStore(ACCESS_U8, popw8());
			I64_STORE16	=> doStore(ACCESS_U16, popw16());
			I64_STORE32	=> doStore(ACCESS_U32, popw32());

			// Atomic operations
			MEMORY_ATOMIC_NOTIFY => {
				var imm = codeptr.read_MemArg();
				Runtime.MEMORY_ATOMIC_NOTIFY(this, frame.func.instance, imm.memory_index, imm.offset);
			}
			MEMORY_ATOMIC_WAIT32 => {
				var imm = codeptr.read_MemArg();
				Runtime.MEMORY_ATOMIC_WAIT32(this, frame.func.instance, imm.memory_index, imm.offset);
			}
			MEMORY_ATOMIC_WAIT64 => {
				var imm = codeptr.read_MemArg();
				Runtime.MEMORY_ATOMIC_WAIT64(this, frame.func.instance, imm.memory_index, imm.offset);
			}
			ATOMIC_FENCE => {
				codeptr.read1(); // skip zero byte
				Runtime.ATOMIC_FENCE();
			}

			I32_ATOMIC_LOAD		=> doAtomicLoad(ACCESS_U32, pushu);
			I64_ATOMIC_LOAD		=> doAtomicLoad(ACCESS_U64, pushw);
			I32_ATOMIC_LOAD8_U	=> doAtomicLoad(ACCESS_U8, pushu8);
			I32_ATOMIC_LOAD16_U	=> doAtomicLoad(ACCESS_U16, pushu16);
			I64_ATOMIC_LOAD8_U	=> doAtomicLoad(ACCESS_U8, pushw8);
			I64_ATOMIC_LOAD16_U	=> doAtomicLoad(ACCESS_U16, pushw16);
			I64_ATOMIC_LOAD32_U	=> doAtomicLoad(ACCESS_U32, pushw32);
			I32_ATOMIC_STORE	=> doAtomicStore(ACCESS_U32, popu);
			I64_ATOMIC_STORE	=> doAtomicStore(ACCESS_U64, popw);
			I32_ATOMIC_STORE8	=> doAtomicStore(ACCESS_U8, popu8);
			I32_ATOMIC_STORE16	=> doAtomicStore(ACCESS_U16, popu16);
			I64_ATOMIC_STORE8	=> doAtomicStore(ACCESS_U8, popw8);
			I64_ATOMIC_STORE16	=> doAtomicStore(ACCESS_U16, popw16);
			I64_ATOMIC_STORE32	=> doAtomicStore(ACCESS_U32, popw32);

			I32_ATOMIC_RMW_ADD	=> doAtomicRmw(ACCESS_U32, popu(), 	V3Eval.I32_ADD, pushu);
			I64_ATOMIC_RMW_ADD	=> doAtomicRmw(ACCESS_U64, popw(),	V3Eval.I64_ADD, pushw);
			I32_ATOMIC_RMW8_ADD_U	=> doAtomicRmw(ACCESS_U8,  popu8(), 	u8.+, pushu8);
			I32_ATOMIC_RMW16_ADD_U	=> doAtomicRmw(ACCESS_U16, popu16(), 	u16.+, pushu16);
			I64_ATOMIC_RMW8_ADD_U	=> doAtomicRmw(ACCESS_U8,  popw8(), 	u8.+, pushw8);
			I64_ATOMIC_RMW16_ADD_U	=> doAtomicRmw(ACCESS_U16, popw16(), 	u16.+, pushw16);
			I64_ATOMIC_RMW32_ADD_U	=> doAtomicRmw(ACCESS_U32, popw32(), 	u32.+, pushw32);
			I32_ATOMIC_RMW_SUB	=> doAtomicRmw(ACCESS_U32, popu(), 	V3Eval.I32_SUB, pushu);
			I64_ATOMIC_RMW_SUB	=> doAtomicRmw(ACCESS_U64, popw(),	V3Eval.I64_SUB, pushw);
			I32_ATOMIC_RMW8_SUB_U	=> doAtomicRmw(ACCESS_U8,  popu8(), 	u8.-, pushu8);
			I32_ATOMIC_RMW16_SUB_U	=> doAtomicRmw(ACCESS_U16, popu16(), 	u16.-, pushu16);
			I64_ATOMIC_RMW8_SUB_U	=> doAtomicRmw(ACCESS_U8,  popw8(), 	u8.-, pushw8);
			I64_ATOMIC_RMW16_SUB_U	=> doAtomicRmw(ACCESS_U16, popw16(), 	u16.-, pushw16);
			I64_ATOMIC_RMW32_SUB_U	=> doAtomicRmw(ACCESS_U32, popw32(), 	u32.-, pushw32);
			I32_ATOMIC_RMW_AND	=> doAtomicRmw(ACCESS_U32, popu(), 	V3Eval.I32_AND, pushu);
			I64_ATOMIC_RMW_AND	=> doAtomicRmw(ACCESS_U64, popw(),	V3Eval.I64_AND, pushw);
			I32_ATOMIC_RMW8_AND_U	=> doAtomicRmw(ACCESS_U8,  popu8(), 	u8.&, pushu8);
			I32_ATOMIC_RMW16_AND_U	=> doAtomicRmw(ACCESS_U16, popu16(), 	u16.&, pushu16);
			I64_ATOMIC_RMW8_AND_U	=> doAtomicRmw(ACCESS_U8,  popw8(), 	u8.&, pushw8);
			I64_ATOMIC_RMW16_AND_U	=> doAtomicRmw(ACCESS_U16, popw16(), 	u16.&, pushw16);
			I64_ATOMIC_RMW32_AND_U	=> doAtomicRmw(ACCESS_U32, popw32(), 	u32.&, pushw32);
			I32_ATOMIC_RMW_OR	=> doAtomicRmw(ACCESS_U32, popu(), 	V3Eval.I32_OR, pushu);
			I64_ATOMIC_RMW_OR	=> doAtomicRmw(ACCESS_U64, popw(),	V3Eval.I64_AND, pushw);
			I32_ATOMIC_RMW8_OR_U	=> doAtomicRmw(ACCESS_U8,  popu8(), 	u8.|, pushu8);
			I32_ATOMIC_RMW16_OR_U	=> doAtomicRmw(ACCESS_U16, popu16(), 	u16.|, pushu16);
			I64_ATOMIC_RMW8_OR_U	=> doAtomicRmw(ACCESS_U8,  popw8(), 	u8.|, pushw8);
			I64_ATOMIC_RMW16_OR_U	=> doAtomicRmw(ACCESS_U16, popw16(), 	u16.|, pushw16);
			I64_ATOMIC_RMW32_OR_U	=> doAtomicRmw(ACCESS_U32, popw32(), 	u32.|, pushw32);
			I32_ATOMIC_RMW_XOR	=> doAtomicRmw(ACCESS_U32, popu(), 	V3Eval.I32_XOR, pushu);
			I64_ATOMIC_RMW_XOR	=> doAtomicRmw(ACCESS_U64, popw(),	V3Eval.I64_XOR, pushw);
			I32_ATOMIC_RMW8_XOR_U	=> doAtomicRmw(ACCESS_U8,  popu8(), 	u8.^, pushu8);
			I32_ATOMIC_RMW16_XOR_U	=> doAtomicRmw(ACCESS_U16, popu16(), 	u16.^, pushu16);
			I64_ATOMIC_RMW8_XOR_U	=> doAtomicRmw(ACCESS_U8,  popw8(), 	u8.^, pushw8);
			I64_ATOMIC_RMW16_XOR_U	=> doAtomicRmw(ACCESS_U16, popw16(), 	u16.^, pushw16);
			I64_ATOMIC_RMW32_XOR_U	=> doAtomicRmw(ACCESS_U32, popw32(), 	u32.^, pushw32);
			I32_ATOMIC_RMW_XCHG	=> doAtomicXchg(ACCESS_U32, popu(), 	pushu);
			I64_ATOMIC_RMW_XCHG	=> doAtomicXchg(ACCESS_U64, popw(),	pushw);
			I32_ATOMIC_RMW8_XCHG_U	=> doAtomicXchg(ACCESS_U8,  popu8(), 	pushu8);
			I32_ATOMIC_RMW16_XCHG_U	=> doAtomicXchg(ACCESS_U16, popu16(), 	pushu16);
			I64_ATOMIC_RMW8_XCHG_U	=> doAtomicXchg(ACCESS_U8,  popw8(), 	pushw8);
			I64_ATOMIC_RMW16_XCHG_U	=> doAtomicXchg(ACCESS_U16, popw16(), 	pushw16);
			I64_ATOMIC_RMW32_XCHG_U	=> doAtomicXchg(ACCESS_U32, popw32(), 	pushw32);
			I32_ATOMIC_RMW_CMPXCHG		=> doAtomicCmpXchg(ACCESS_U32, popu(), popu(), pushu);
			I64_ATOMIC_RMW_CMPXCHG		=> doAtomicCmpXchg(ACCESS_U64, popw(), popw(), pushw);
			I32_ATOMIC_RMW8_CMPXCHG_U	=> doAtomicCmpXchg(ACCESS_U8, popu8(), popu8(), pushu8);
			I32_ATOMIC_RMW16_CMPXCHG_U	=> doAtomicCmpXchg(ACCESS_U16, popu16(), popu16(), pushu16);
			I64_ATOMIC_RMW8_CMPXCHG_U	=> doAtomicCmpXchg(ACCESS_U8, popw8(), popw8(), pushw8);
			I64_ATOMIC_RMW16_CMPXCHG_U	=> doAtomicCmpXchg(ACCESS_U16, popw16(), popw16(), pushw16);
			I64_ATOMIC_RMW32_CMPXCHG_U	=> doAtomicCmpXchg(ACCESS_U32, popw32(), popw32(), pushw32);

			MEMORY_SIZE => {
				var index = codeptr.read_uleb32();
				var memory = frame.func.instance.memories[index];
				pusha(memory.decl.size, memory.num_pages);
			}
			MEMORY_GROW => {
				var mem_index = codeptr.read_uleb31();
				Runtime.MEMORY_GROW(this, frame.func.instance, mem_index);
			}

			I32_CONST => pushi(codeptr.read_sleb32());
			I64_CONST => pushl(codeptr.read_sleb64());
			F32_CONST => push(Value.F32(codeptr.read_u32()));
			F64_CONST => push(Value.F64(codeptr.read_u64()));

			I32_EQZ => pushz(popu() == 0);
			I32_EQ => do_uu_z(V3Eval.I32_EQ);
			I32_NE => do_uu_z(V3Eval.I32_NE);
			I32_LT_S => do_ii_z(V3Eval.I32_LT_S);
			I32_LT_U => do_uu_z(V3Eval.I32_LT_U);
			I32_GT_S => do_ii_z(V3Eval.I32_GT_S);
			I32_GT_U => do_uu_z(V3Eval.I32_GT_U);
			I32_LE_S => do_ii_z(V3Eval.I32_LE_S);
			I32_LE_U => do_uu_z(V3Eval.I32_LE_U);
			I32_GE_S => do_ii_z(V3Eval.I32_GE_S);
			I32_GE_U => do_uu_z(V3Eval.I32_GE_U);

			I64_EQZ => pushz(popw() == 0);
			I64_EQ => do_ww_z(V3Eval.I64_EQ);
			I64_NE => do_ww_z(V3Eval.I64_NE);
			I64_LT_S => do_ll_z(V3Eval.I64_LT_S);
			I64_LT_U => do_ww_z(V3Eval.I64_LT_U);
			I64_GT_S => do_ll_z(V3Eval.I64_GT_S);
			I64_GT_U => do_ww_z(V3Eval.I64_GT_U);
			I64_LE_S => do_ll_z(V3Eval.I64_LE_S);
			I64_LE_U => do_ww_z(V3Eval.I64_LE_U);
			I64_GE_S => do_ll_z(V3Eval.I64_GE_S);
			I64_GE_U => do_ww_z(V3Eval.I64_GE_U);

			F32_EQ => do_ff_z(V3Eval.F32_EQ);
			F32_NE => do_ff_z(V3Eval.F32_NE);
			F32_LT => do_ff_z(V3Eval.F32_LT);
			F32_GT => do_ff_z(V3Eval.F32_GT);
			F32_LE => do_ff_z(V3Eval.F32_LE);
			F32_GE => do_ff_z(V3Eval.F32_GE);
			F64_EQ => do_dd_z(V3Eval.F64_EQ);
			F64_NE => do_dd_z(V3Eval.F64_NE);
			F64_LT => do_dd_z(V3Eval.F64_LT);
			F64_GT => do_dd_z(V3Eval.F64_GT);
			F64_LE => do_dd_z(V3Eval.F64_LE);
			F64_GE => do_dd_z(V3Eval.F64_GE);

			I32_CLZ => do_u_u(V3Eval.I32_CLZ);
			I32_CTZ => do_u_u(V3Eval.I32_CTZ);
			I32_POPCNT => do_u_u(V3Eval.I32_POPCNT);
			I32_ADD => do_uu_u(V3Eval.I32_ADD);
			I32_SUB => do_uu_u(V3Eval.I32_SUB);
			I32_MUL => do_uu_u(V3Eval.I32_MUL);
			I32_DIV_S => do_ii_it(V3Eval.I32_DIV_S);
			I32_DIV_U => do_uu_ut(V3Eval.I32_DIV_U);
			I32_REM_S => do_ii_it(V3Eval.I32_REM_S);
			I32_REM_U => do_uu_ut(V3Eval.I32_REM_U);
			I32_AND => do_uu_u(V3Eval.I32_AND);
			I32_OR => do_uu_u(V3Eval.I32_OR);
			I32_XOR => do_uu_u(V3Eval.I32_XOR);
			I32_SHL => do_ii_i(V3Eval.I32_SHL);
			I32_SHR_S => do_ii_i(V3Eval.I32_SHR_S);
			I32_SHR_U => do_ii_i(V3Eval.I32_SHR_U);
			I32_ROTL => do_uu_u(V3Eval.I32_ROTL);
			I32_ROTR => do_uu_u(V3Eval.I32_ROTR);

			I64_CLZ => do_w_w(V3Eval.I64_CLZ);
			I64_CTZ => do_w_w(V3Eval.I64_CTZ);
			I64_POPCNT => do_w_w(V3Eval.I64_POPCNT);

			I64_ADD => do_ww_w(V3Eval.I64_ADD);
			I64_SUB => do_ww_w(V3Eval.I64_SUB);
			I64_MUL => do_ww_w(V3Eval.I64_MUL);
			I64_DIV_S => do_ll_lt(V3Eval.I64_DIV_S);
			I64_DIV_U => do_ww_wt(V3Eval.I64_DIV_U);
			I64_REM_S => do_ll_lt(V3Eval.I64_REM_S);
			I64_REM_U => do_ww_wt(V3Eval.I64_REM_U);
			I64_AND => do_ww_w(V3Eval.I64_AND);
			I64_OR => do_ww_w(V3Eval.I64_OR);
			I64_XOR => do_ww_w(V3Eval.I64_XOR);
			I64_SHL => do_ww_w(V3Eval.I64_SHL);
			I64_SHR_S => do_ll_l(V3Eval.I64_SHR_S);
			I64_SHR_U => do_ww_w(V3Eval.I64_SHR_U);
			I64_ROTL => do_ww_w(V3Eval.I64_ROTL);
			I64_ROTR => do_ww_w(V3Eval.I64_ROTR);

			F32_ABS => do_f_f(V3Eval.F32_ABS);
			F32_NEG => do_f_f(V3Eval.F32_NEG);
			F32_CEIL => do_f_f(V3Eval.F32_CEIL);
			F32_FLOOR => do_f_f(V3Eval.F32_FLOOR);
			F32_TRUNC => do_f_f(V3Eval.F32_TRUNC);
			F32_NEAREST => do_f_f(V3Eval.F32_NEAREST);
			F32_SQRT => do_f_f(V3Eval.F32_SQRT);
			F32_ADD => do_ff_f(V3Eval.F32_ADD);
			F32_SUB => do_ff_f(V3Eval.F32_SUB);
			F32_MUL => do_ff_f(V3Eval.F32_MUL);
			F32_DIV => do_ff_f(V3Eval.F32_DIV);
			F32_MIN => do_ff_f(V3Eval.F32_MIN);
			F32_MAX => do_ff_f(V3Eval.F32_MAX);
			F32_COPYSIGN => do_ff_f(V3Eval.F32_COPYSIGN);

			F64_ABS => do_d_d(V3Eval.F64_ABS);
			F64_NEG => do_d_d(V3Eval.F64_NEG);
			F64_CEIL => do_d_d(V3Eval.F64_CEIL);
			F64_FLOOR => do_d_d(V3Eval.F64_FLOOR);
			F64_TRUNC => do_d_d(V3Eval.F64_TRUNC);
			F64_NEAREST => do_d_d(V3Eval.F64_NEAREST);
			F64_SQRT => do_d_d(V3Eval.F64_SQRT);
			F64_ADD => do_dd_d(V3Eval.F64_ADD);
			F64_SUB => do_dd_d(V3Eval.F64_SUB);
			F64_MUL => do_dd_d(V3Eval.F64_MUL);
			F64_DIV => do_dd_d(V3Eval.F64_DIV);
			F64_MIN => do_dd_d(V3Eval.F64_MIN);
			F64_MAX => do_dd_d(V3Eval.F64_MAX);
			F64_COPYSIGN => do_dd_d(V3Eval.F64_COPYSIGN);

			I32_WRAP_I64 => pushu(V3Eval.I32_WRAP_I64(popw()));

			I32_TRUNC_F32_S => trap_or(V3Eval.I32_TRUNC_F32_S(popf()), pushi);
			I32_TRUNC_F32_U => trap_or(V3Eval.I32_TRUNC_F32_U(popf()), pushu);
			I32_TRUNC_F64_S => trap_or(V3Eval.I32_TRUNC_F64_S(popd()), pushi);
			I32_TRUNC_F64_U => trap_or(V3Eval.I32_TRUNC_F64_U(popd()), pushu);

			I64_EXTEND_I32_S => pushl(V3Eval.I64_EXTEND_I32_S(popi()));
			I64_EXTEND_I32_U => pushw(V3Eval.I64_EXTEND_I32_U(popu()));

			I64_TRUNC_F32_S => trap_or(V3Eval.I64_TRUNC_F32_S(popf()), pushl);
			I64_TRUNC_F32_U => trap_or(V3Eval.I64_TRUNC_F32_U(popf()), pushw);
			I64_TRUNC_F64_S => trap_or(V3Eval.I64_TRUNC_F64_S(popd()), pushl);
			I64_TRUNC_F64_U => trap_or(V3Eval.I64_TRUNC_F64_U(popd()), pushw);

			F32_CONVERT_I32_S => pushf(V3Eval.F32_CONVERT_I32_S(popi()));
			F32_CONVERT_I32_U => pushf(V3Eval.F32_CONVERT_I32_U(popu()));
			F32_CONVERT_I64_S => pushf(V3Eval.F32_CONVERT_I64_S(popl()));
			F32_CONVERT_I64_U => pushf(V3Eval.F32_CONVERT_I64_U(popw()));
			F32_DEMOTE_F64 => pushf(V3Eval.F32_DEMOTE_F64(popd()));
			F64_CONVERT_I32_S => pushd(V3Eval.F64_CONVERT_I32_S(popi()));
			F64_CONVERT_I32_U => pushd(V3Eval.F64_CONVERT_I32_U(popu()));
			F64_CONVERT_I64_S => pushd(V3Eval.F64_CONVERT_I64_S(popl()));
			F64_CONVERT_I64_U => pushd(V3Eval.F64_CONVERT_I64_U(popw()));
			F64_PROMOTE_F32 => pushd(V3Eval.F64_PROMOTE_F32(popf()));

			I32_REINTERPRET_F32 => pushu(V3Eval.I32_REINTERPRET_F32(popf()));
			F32_REINTERPRET_I32 => pushf(V3Eval.F32_REINTERPRET_I32(popu()));
			I64_REINTERPRET_F64 => pushw(V3Eval.I64_REINTERPRET_F64(popd()));
			F64_REINTERPRET_I64 => pushd(V3Eval.F64_REINTERPRET_I64(popw()));

			I32_EXTEND8_S => pushi(V3Eval.I32_EXTEND8_S(popi()));
			I32_EXTEND16_S => pushi(V3Eval.I32_EXTEND16_S(popi()));
			I64_EXTEND8_S => pushl(V3Eval.I64_EXTEND8_S(popl()));
			I64_EXTEND16_S => pushl(V3Eval.I64_EXTEND16_S(popl()));
			I64_EXTEND32_S => pushl(V3Eval.I64_EXTEND32_S(popl()));

			REF_NULL => {
				var index = codeptr.read_sleb32();
				push(Values.REF_NULL);
			}
			REF_IS_NULL => {
				var v = pop();
				var r = Values.isNull(v);
				pushz(r);
			}
			REF_FUNC => {
				var index = codeptr.read_uleb32();
				var func = frame.func.instance.functions[index];
				push(Value.Ref(func));
			}
			REF_AS_NON_NULL => {
				var v = pop();
				if (Values.isNull(v)) trap(TrapReason.NULL_DEREF);
				else push(v);
			}
			BR_ON_NULL => {
				var v = pop();
				if (Values.isNull(v)) { // XXX: use doBranch
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					push(v);
					doFallthru();
				}
			}
			REF_EQ => {
				var a = pop();
				var b = pop();
				pushz(a == b);
			}
			BR_ON_NON_NULL => {
				var v = pop();
				if (!Values.isNull(v)) {
					push(v);
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					doFallthru();
				}
			}
			STRUCT_NEW => {
				var struct_index = codeptr.read_uleb31();
				Runtime.STRUCT_NEW(this, frame.func.instance, struct_index);
			}
			STRUCT_NEW_DEFAULT => {
				var struct_index = codeptr.read_uleb31();
				Runtime.STRUCT_NEW_DEFAULT(this, frame.func.instance, struct_index);
			}
			STRUCT_GET => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_GET(this, frame.func.instance, struct_index, field_index);
			}
			STRUCT_GET_S => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_GET_S(this, frame.func.instance, struct_index, field_index);
			}
			STRUCT_GET_U => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_GET_U(this, frame.func.instance, struct_index, field_index);
			}
			STRUCT_SET => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_SET(this, frame.func.instance, struct_index, field_index);
			}
			ARRAY_NEW => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW(this, frame.func.instance, array_index);
			}
			ARRAY_NEW_DEFAULT => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW_DEFAULT(this, frame.func.instance, array_index);
			}
			ARRAY_GET => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_GET(this, frame.func.instance, array_index);
			}
			ARRAY_GET_S => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_GET_S(this, frame.func.instance, array_index);
			}
			ARRAY_GET_U => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_GET_U(this, frame.func.instance, array_index);
			}
			ARRAY_SET => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_SET(this, frame.func.instance, array_index);
			}
			ARRAY_LEN => {
				var obj = popArray();
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else push(Value.I32(u32.view(obj.vals.length)));
			}
			ARRAY_FILL => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_FILL(this, frame.func.instance, array_index);
			}
			ARRAY_COPY => {
				var array_index1 = codeptr.read_uleb31();
				var array_index2 = codeptr.read_uleb31();
				Runtime.ARRAY_COPY(this, frame.func.instance, array_index1, array_index2);
			}
			ARRAY_INIT_DATA => {
				var array_index = codeptr.read_uleb31();
				var data_index = codeptr.read_uleb31();
				Runtime.ARRAY_INIT_DATA(this, frame.func.instance, array_index, data_index);
			}
			ARRAY_INIT_ELEM => {
				var array_index = codeptr.read_uleb31();
				var elem_index = codeptr.read_uleb31();
				Runtime.ARRAY_INIT_ELEM(this, frame.func.instance, array_index, elem_index);
			}
			ARRAY_NEW_FIXED => {
				var array_index = codeptr.read_uleb31();
				var length = codeptr.read_uleb32();
				Runtime.ARRAY_NEW_FIXED(this, frame.func.instance, array_index, length);
			}
			ARRAY_NEW_DATA => {
				var array_index = codeptr.read_uleb31();
				var data_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW_DATA(this, frame.func.instance, array_index, data_index);
			}
			ARRAY_NEW_ELEM => {
				var array_index = codeptr.read_uleb31();
				var elem_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW_ELEM(this, frame.func.instance, array_index, elem_index);
			}
			REF_I31 => {
				push(Value.I31(u31.view(popu())));
			}
			I31_GET_S => {
				var v = pop();
				if (v == Values.REF_NULL) trap(TrapReason.NULL_DEREF);
				else pushi(i31.view(Value.I31.!(v).val));
			}
			I31_GET_U => {
				var v = pop();
				if (v == Values.REF_NULL) trap(TrapReason.NULL_DEREF);
				else pushu(Value.I31.!(v).val);
			}
			REF_TEST,
			REF_TEST_NULL => {
				var nullable = (opcode == Opcode.REF_TEST_NULL);
				var ht_val = codeptr.read_sleb32();
				var result = Runtime.cast(frame.func.instance, nullable, ht_val, pop());
				pushz(result);
			}
			REF_CAST,
			REF_CAST_NULL => {
				var nullable = (opcode == Opcode.REF_CAST_NULL);
				var ht_val = codeptr.read_sleb32();
				var val = pop();
				var result = Runtime.cast(frame.func.instance, nullable, ht_val, val);
				if (!result) trap(TrapReason.FAILED_CAST);
				else push(val);
			}
			BR_ON_CAST => {
				var imm = codeptr.read_BrOnCastImm();
				var val = pop();
				var result = Runtime.cast(frame.func.instance, imm.null2(), imm.ht2, val);
				push(val);
				if (result) codeptr.at(doGoto(pc));
				else doFallthru();
			}
			BR_ON_CAST_FAIL => {
				var imm = codeptr.read_BrOnCastImm();
				var val = pop();
				var result = Runtime.cast(frame.func.instance, imm.null2(), imm.ht2, val);
				push(val);
				if (!result) codeptr.at(doGoto(pc));
				else doFallthru();
			}
			ANY_CONVERT_EXTERN, EXTERN_CONVERT_ANY => {
				// nop
			}
			I32_TRUNC_SAT_F32_S => pushi(i32.truncf(popf()));
			I32_TRUNC_SAT_F32_U => pushu(u32.truncf(popf()));
			I32_TRUNC_SAT_F64_S => pushi(i32.truncd(popd()));
			I32_TRUNC_SAT_F64_U => pushu(u32.truncd(popd()));
			I64_TRUNC_SAT_F32_S => pushl(i64.truncf(popf()));
			I64_TRUNC_SAT_F32_U => pushw(u64.truncf(popf()));
			I64_TRUNC_SAT_F64_S => pushl(i64.truncd(popd()));
			I64_TRUNC_SAT_F64_U => pushw(u64.truncd(popd()));
			MEMORY_INIT => {
				var data_index = codeptr.read_uleb31(), mem_index = codeptr.read_uleb31();
				Runtime.MEMORY_INIT(this, frame.func.instance, data_index, mem_index);
			}
			DATA_DROP => {
				var dindex = codeptr.read_uleb32();
				frame.func.instance.dropped_data[dindex] = true;
			}
			MEMORY_COPY => {
				var dst = codeptr.read_uleb31(), src = codeptr.read_uleb31();
				Runtime.MEMORY_COPY(this, frame.func.instance, dst, src);
			}
			MEMORY_FILL => {
				var mem_index = codeptr.read_uleb31();
				Runtime.MEMORY_FILL(this, frame.func.instance, mem_index);
			}
			TABLE_INIT => {
				var elem_index = codeptr.read_uleb31();
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_INIT(this, frame.func.instance, elem_index, table_index);
			}
			ELEM_DROP => {
				var index = codeptr.read_uleb32();
				frame.func.instance.dropped_elems[index] = true;
			}
			TABLE_COPY => {
				var table_index1 = codeptr.read_uleb31();
				var table_index2 = codeptr.read_uleb31();
				Runtime.TABLE_COPY(this, frame.func.instance, table_index1, table_index2);
			}
			TABLE_GROW => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_GROW(this, frame.func.instance, table_index);
			}
			TABLE_SIZE => {
				var i = frame.func.instance;
				var table = i.tables[codeptr.read_uleb32()];
				pusha(table.decl.size, u64.!(table.elems.length));
			}
			TABLE_FILL => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_FILL(this, frame.func.instance, table_index);
			}
			V128_LOAD => 		doLoad(ACCESS_V128, pushs);
			V128_LOAD_64_LANE => 	doLoadLane(ACCESS_U64);
			V128_LOAD_32_LANE => 	doLoadLane(ACCESS_U32);
			V128_LOAD_16_LANE => 	doLoadLane(ACCESS_U16);
			V128_LOAD_8_LANE => 	doLoadLane(ACCESS_U8);
			V128_LOAD_64_SPLAT => 	doLoadSplat(ACCESS_U64);
			V128_LOAD_32_SPLAT => 	doLoadSplat(ACCESS_U32);
			V128_LOAD_16_SPLAT => 	doLoadSplat(ACCESS_U16);
			V128_LOAD_8_SPLAT => 	doLoadSplat(ACCESS_U8);
			V128_LOAD_32_ZERO => 	doLoadZero(ACCESS_U32);
			V128_LOAD_64_ZERO => 	doLoadZero(ACCESS_U64);
			V128_LOAD_8X8_S => 	doLoadExtend(1, i8.view<u64>, i16.view<i8>, u16.view<i16>);
			V128_LOAD_8X8_U => 	doLoadExtend(1, u8.view<u64>, u16.view<u8>, u16.view<u16>);
			V128_LOAD_16X4_S => 	doLoadExtend(2, i16.view<u64>, i32.view<i16>, u32.view<i32>);
			V128_LOAD_16X4_U => 	doLoadExtend(2, u16.view<u64>, u32.view<u16>, u32.view<u32>);
			V128_LOAD_32X2_S => 	doLoadExtend(4, i32.view<u64>, i64.view<i32>, u64.view<i64>);
			V128_LOAD_32X2_U => 	doLoadExtend(4, u32.view<u64>, u64.view<u32>, u64.view<u64>);
			V128_STORE => 		doStore(ACCESS_V128, pops());
			V128_STORE_8_LANE => 	doStoreLane(ACCESS_U8, u8.view<u64>);
			V128_STORE_16_LANE => 	doStoreLane(ACCESS_U16, u16.view<u64>);
			V128_STORE_32_LANE => 	doStoreLane(ACCESS_U32, u32.view<u64>);
			V128_STORE_64_LANE => 	doStoreLane(ACCESS_U64, u64.view<u64>);
			V128_CONST => {
				var low = codeptr.read_u64();
				var high = codeptr.read_u64();
				push(Value.V128(low, high));
			}
			I8X16_SPLAT => 		doSplat(1, 0, u8.view<i32>, popi);
			I16X8_SPLAT => 		doSplat(2, 1, u16.view<i32>, popi);
			I32X4_SPLAT => 		doSplat(4, 2, u32.view<i32>, popi);
			I64X2_SPLAT => 		doSplat(8, 3, u64.view<i64>, popl);
			F32X4_SPLAT => 		doSplat(4, 2, u32.view<float>, popf);
			F64X2_SPLAT => 		doSplat(8, 3, u64.view<double>, popd);
			V128_NOT => 		do_s_s(V3Eval.V128_NOT);
			V128_AND => 		do_ss_s(V3Eval.V128_AND);
			V128_OR => 		do_ss_s(V3Eval.V128_OR);
			V128_XOR => 		do_ss_s(V3Eval.V128_XOR);
			F32X4_RELAXED_MADD =>	do_sss_s(V3Eval.V128_F32X4_MADD);
			F32X4_RELAXED_NMADD =>	do_sss_s(V3Eval.V128_F32X4_NMADD);
			F64X2_RELAXED_MADD =>	do_sss_s(V3Eval.V128_F64X2_MADD);
			F64X2_RELAXED_NMADD =>	do_sss_s(V3Eval.V128_F64X2_NMADD);
			I8X16_RELAXED_LANESELECT,
			I16X8_RELAXED_LANESELECT,
			I32X4_RELAXED_LANESELECT,
			I64X2_RELAXED_LANESELECT,
			V128_BITSELECT => 	do_sss_s(V3Eval.V128_BITSELECT);
			V128_ANDNOT => 		do_ss_s(V3Eval.V128_ANDNOT);
			V128_ANYTRUE => 	do_s_z(V3Eval.V128_ANYTRUE);
			I8X16_ALLTRUE => 	do_s_z(V3Eval.I8X16_ALLTRUE);
			I16X8_ALLTRUE => 	do_s_z(V3Eval.I16X8_ALLTRUE);
			I32X4_ALLTRUE => 	do_s_z(V3Eval.I32X4_ALLTRUE);
			I64X2_ALLTRUE => 	do_s_z(V3Eval.I64X2_ALLTRUE);
			I8X16_BITMASK => 	do_s_i(V3Eval.I8X16_BITMASK);
			I16X8_BITMASK => 	do_s_i(V3Eval.I16X8_BITMASK);
			I32X4_BITMASK => 	do_s_i(V3Eval.I32X4_BITMASK);
			I64X2_BITMASK => 	do_s_i(V3Eval.I64X2_BITMASK);
			I64X2_ADD => 		do_ss_s(V3Eval.I64X2_ADD);
			I64X2_SUB => 		do_ss_s(V3Eval.I64X2_SUB);
			I64X2_MUL => 		do_ss_s(V3Eval.I64X2_MUL);
			I64X2_NEG => 		do_s_s(V3Eval.I64X2_NEG);
			I64X2_ABS => 		do_s_s(V3Eval.I64X2_ABS);
			I64X2_EQ => 		do_ss_s(V3Eval.I64X2_EQ);
			I64X2_NE => 		do_ss_s(V3Eval.I64X2_NE);
			I64X2_LT_S => 		do_ss_s(V3Eval.I64X2_LT_S);
			I64X2_LE_S => 		do_ss_s(V3Eval.I64X2_LE_S);
			I64X2_GT_S => 		do_ss_s(V3Eval.I64X2_GT_S);
			I64X2_GE_S => 		do_ss_s(V3Eval.I64X2_GE_S);
			I32X4_ADD => 		do_ss_s(V3Eval.I32X4_ADD);
			I32X4_SUB => 		do_ss_s(V3Eval.I32X4_SUB);
			I32X4_MUL => 		do_ss_s(V3Eval.I32X4_MUL);
			I32X4_NEG => 		do_s_s(V3Eval.I32X4_NEG);
			I32X4_DOT_I16X8_S => 	do_ss_s(V3Eval.I32X4_DOT_I16X8_S);
			I32X4_EXTADDPAIRWISE_I16X8_S => do_s_s(V3Eval.I32X4_EXTADDPAIRWISE_I16X8_S);
			I32X4_EXTADDPAIRWISE_I16X8_U => do_s_s(V3Eval.I32X4_EXTADDPAIRWISE_I16X8_U);
			I32X4_MIN_S => 		do_ss_s(V3Eval.I32X4_MIN_S);
			I32X4_MIN_U => 		do_ss_s(V3Eval.I32X4_MIN_U);
			I32X4_MAX_S => 		do_ss_s(V3Eval.I32X4_MAX_S);
			I32X4_MAX_U => 		do_ss_s(V3Eval.I32X4_MAX_U);
			I32X4_ABS => 		do_s_s(V3Eval.I32X4_ABS);
			I32X4_EQ => 		do_ss_s(V3Eval.I32X4_EQ);
			I32X4_NE => 		do_ss_s(V3Eval.I32X4_NE);
			I32X4_LT_S => 		do_ss_s(V3Eval.I32X4_LT_S);
			I32X4_LT_U => 		do_ss_s(V3Eval.I32X4_LT_U);
			I32X4_LE_S => 		do_ss_s(V3Eval.I32X4_LE_S);
			I32X4_LE_U => 		do_ss_s(V3Eval.I32X4_LE_U);
			I32X4_GT_S => 		do_ss_s(V3Eval.I32X4_GT_S);
			I32X4_GT_U => 		do_ss_s(V3Eval.I32X4_GT_U);
			I32X4_GE_S => 		do_ss_s(V3Eval.I32X4_GE_S);
			I32X4_GE_U => 		do_ss_s(V3Eval.I32X4_GE_U);
			I32X4_SHL => 		do_si_s(V3Eval.I32X4_SHL);
			I32X4_SHR_U => 		do_si_s(V3Eval.I32X4_SHR_U);
			I32X4_SHR_S => 		do_si_s(V3Eval.I32X4_SHR_S);
			I16X8_ADD => 		do_ss_s(V3Eval.I16X8_ADD);
			I16X8_SUB => 		do_ss_s(V3Eval.I16X8_SUB);
			I16X8_MUL => 		do_ss_s(V3Eval.I16X8_MUL);
			I16X8_Q15MULRSAT_S,
			I16X8_RELAXED_Q15MULR_S => 	do_ss_s(V3Eval.I16X8_Q15MULRSAT_S);
			I16X8_NEG => 		do_s_s(V3Eval.I16X8_NEG);
			I16X8_MIN_S => 		do_ss_s(V3Eval.I16X8_MIN_S);
			I16X8_MIN_U => 		do_ss_s(V3Eval.I16X8_MIN_U);
			I16X8_MAX_S => 		do_ss_s(V3Eval.I16X8_MAX_S);
			I16X8_MAX_U => 		do_ss_s(V3Eval.I16X8_MAX_U);
			I16X8_AVGR_U => 	do_ss_s(V3Eval.I16X8_AVGR_U);
			I16X8_ABS => 		do_s_s(V3Eval.I16X8_ABS);
			I16X8_EQ => 		do_ss_s(V3Eval.I16X8_EQ);
			I16X8_NE => 		do_ss_s(V3Eval.I16X8_NE);
			I16X8_LT_S => 		do_ss_s(V3Eval.I16X8_LT_S);
			I16X8_LT_U => 		do_ss_s(V3Eval.I16X8_LT_U);
			I16X8_LE_S => 		do_ss_s(V3Eval.I16X8_LE_S);
			I16X8_LE_U => 		do_ss_s(V3Eval.I16X8_LE_U);
			I16X8_GT_S => 		do_ss_s(V3Eval.I16X8_GT_S);
			I16X8_GT_U => 		do_ss_s(V3Eval.I16X8_GT_U);
			I16X8_GE_S => 		do_ss_s(V3Eval.I16X8_GE_S);
			I16X8_GE_U => 		do_ss_s(V3Eval.I16X8_GE_U);
			I16X8_ADD_SAT_S => 	do_ss_s(V3Eval.I16X8_ADD_SAT_S);
			I16X8_ADD_SAT_U => 	do_ss_s(V3Eval.I16X8_ADD_SAT_U);
			I16X8_SUB_SAT_S => 	do_ss_s(V3Eval.I16X8_SUB_SAT_S);
			I16X8_SUB_SAT_U => 	do_ss_s(V3Eval.I16X8_SUB_SAT_U);
			I16X8_SHL => 		do_si_s(V3Eval.I16X8_SHL);
			I16X8_SHR_U => 		do_si_s(V3Eval.I16X8_SHR_U);
			I16X8_SHR_S => 		do_si_s(V3Eval.I16X8_SHR_S);
			I8X16_ADD => 		do_ss_s(V3Eval.I8X16_ADD);
			I8X16_SUB => 		do_ss_s(V3Eval.I8X16_SUB);
			I8X16_NEG => 		do_s_s(V3Eval.I8X16_NEG);
			I16X8_EXTADDPAIRWISE_I8X16_S => do_s_s(V3Eval.I16X8_EXTADDPAIRWISE_I8X16_S);
			I16X8_EXTADDPAIRWISE_I8X16_U => do_s_s(V3Eval.I16X8_EXTADDPAIRWISE_I8X16_U);
			I8X16_ADD_SAT_S => 	do_ss_s(V3Eval.I8X16_ADD_SAT_S);
			I8X16_ADD_SAT_U => 	do_ss_s(V3Eval.I8X16_ADD_SAT_U);
			I8X16_SUB_SAT_S => 	do_ss_s(V3Eval.I8X16_SUB_SAT_S);
			I8X16_SUB_SAT_U => 	do_ss_s(V3Eval.I8X16_SUB_SAT_U);
			I8X16_MIN_S => 		do_ss_s(V3Eval.I8X16_MIN_S);
			I8X16_MIN_U => 		do_ss_s(V3Eval.I8X16_MIN_U);
			I8X16_MAX_S => 		do_ss_s(V3Eval.I8X16_MAX_S);
			I8X16_MAX_U => 		do_ss_s(V3Eval.I8X16_MAX_U);
			I8X16_AVGR_U => 	do_ss_s(V3Eval.I8X16_AVGR_U);
			I8X16_ABS => 		do_s_s(V3Eval.I8X16_ABS);
			I8X16_POPCNT => 	do_s_s(V3Eval.I8X16_POPCNT);
			I8X16_EQ => 		do_ss_s(V3Eval.I8X16_EQ);
			I8X16_NE => 		do_ss_s(V3Eval.I8X16_NE);
			I8X16_LT_S => 		do_ss_s(V3Eval.I8X16_LT_S);
			I8X16_LT_U => 		do_ss_s(V3Eval.I8X16_LT_U);
			I8X16_LE_S => 		do_ss_s(V3Eval.I8X16_LE_S);
			I8X16_LE_U => 		do_ss_s(V3Eval.I8X16_LE_U);
			I8X16_GT_S => 		do_ss_s(V3Eval.I8X16_GT_S);
			I8X16_GT_U => 		do_ss_s(V3Eval.I8X16_GT_U);
			I8X16_GE_S => 		do_ss_s(V3Eval.I8X16_GE_S);
			I8X16_GE_U => 		do_ss_s(V3Eval.I8X16_GE_U);
			I8X16_SHL => 		do_si_s(V3Eval.I8X16_SHL);
			I8X16_SHR_U => 		do_si_s(V3Eval.I8X16_SHR_U);
			I8X16_SHR_S => 		do_si_s(V3Eval.I8X16_SHR_S);
			F32X4_ADD => 		do_ss_s(V3Eval.F32X4_ADD);
			F32X4_SUB => 		do_ss_s(V3Eval.F32X4_SUB);
			F32X4_MUL => 		do_ss_s(V3Eval.F32X4_MUL);
			F32X4_DIV => 		do_ss_s(V3Eval.F32X4_DIV);
			F32X4_NEG => 		do_s_s(V3Eval.F32X4_NEG);
			F32X4_SQRT => 		do_s_s(V3Eval.F32X4_SQRT);
			F32X4_CEIL => 		do_s_s(V3Eval.F32X4_CEIL);
			F32X4_FLOOR => 		do_s_s(V3Eval.F32X4_FLOOR);
			F32X4_TRUNC => 		do_s_s(V3Eval.F32X4_TRUNC);
			F32X4_NEAREST => 	do_s_s(V3Eval.F32X4_NEAREST);
			F32X4_EQ => 		do_ss_s(V3Eval.F32X4_EQ);
			F32X4_NE => 		do_ss_s(V3Eval.F32X4_NE);
			F32X4_LT => 		do_ss_s(V3Eval.F32X4_LT);
			F32X4_LE => 		do_ss_s(V3Eval.F32X4_LE);
			F32X4_GT => 		do_ss_s(V3Eval.F32X4_GT);
			F32X4_GE => 		do_ss_s(V3Eval.F32X4_GE);
			F32X4_MIN,
			F32X4_RELAXED_MIN =>	do_ss_s(V3Eval.F32X4_MIN);
			F32X4_MAX,
			F32X4_RELAXED_MAX => 	do_ss_s(V3Eval.F32X4_MAX);
			F32X4_ABS => 		do_s_s(V3Eval.F32X4_ABS);
			F32X4_PMIN => 		do_ss_s(V3Eval.F32X4_PMIN);
			F32X4_PMAX => 		do_ss_s(V3Eval.F32X4_PMAX);
			F64X2_ADD => 		do_ss_s(V3Eval.F64X2_ADD);
			F64X2_SUB => 		do_ss_s(V3Eval.F64X2_SUB);
			F64X2_MUL => 		do_ss_s(V3Eval.F64X2_MUL);
			F64X2_DIV => 		do_ss_s(V3Eval.F64X2_DIV);
			F64X2_NEG => 		do_s_s(V3Eval.F64X2_NEG);
			F64X2_SQRT => 		do_s_s(V3Eval.F64X2_SQRT);
			F64X2_CEIL => 		do_s_s(V3Eval.F64X2_CEIL);
			F64X2_FLOOR => 		do_s_s(V3Eval.F64X2_FLOOR);
			F64X2_TRUNC => 		do_s_s(V3Eval.F64X2_TRUNC);
			F64X2_NEAREST => 	do_s_s(V3Eval.F64X2_NEAREST);
			F64X2_EQ => 		do_ss_s(V3Eval.F64X2_EQ);
			F64X2_NE => 		do_ss_s(V3Eval.F64X2_NE);
			F64X2_LT => 		do_ss_s(V3Eval.F64X2_LT);
			F64X2_LE => 		do_ss_s(V3Eval.F64X2_LE);
			F64X2_GT => 		do_ss_s(V3Eval.F64X2_GT);
			F64X2_GE => 		do_ss_s(V3Eval.F64X2_GE);
			F64X2_MIN,
			F64X2_RELAXED_MIN =>	do_ss_s(V3Eval.F64X2_MIN);
			F64X2_MAX,
			F64X2_RELAXED_MAX => 	do_ss_s(V3Eval.F64X2_MAX);
			F64X2_ABS => 		do_s_s(V3Eval.F64X2_ABS);
			F64X2_PMIN => 		do_ss_s(V3Eval.F64X2_PMIN);
			F64X2_PMAX => 		do_ss_s(V3Eval.F64X2_PMAX);
			I64X2_SHL => 		do_si_s(V3Eval.I64X2_SHL);
			I64X2_SHR_U => 		do_si_s(V3Eval.I64X2_SHR_U);
			I64X2_SHR_S => 		do_si_s(V3Eval.I64X2_SHR_S);
			I16X8_EXTEND_HIGH_I8X16_S => 	do_s_s(V3Eval.I16X8_EXTEND_HIGH_I8X16_S);
			I16X8_EXTEND_HIGH_I8X16_U => 	do_s_s(V3Eval.I16X8_EXTEND_HIGH_I8X16_U);
			I16X8_EXTEND_LOW_I8X16_S => 	do_s_s(V3Eval.I16X8_EXTEND_LOW_I8X16_S);
			I16X8_EXTEND_LOW_I8X16_U => 	do_s_s(V3Eval.I16X8_EXTEND_LOW_I8X16_U);
			I32X4_EXTEND_HIGH_I16X8_S => 	do_s_s(V3Eval.I32X4_EXTEND_HIGH_I16X8_S);
			I32X4_EXTEND_HIGH_I16X8_U => 	do_s_s(V3Eval.I32X4_EXTEND_HIGH_I16X8_U);
			I32X4_EXTEND_LOW_I16X8_S => 	do_s_s(V3Eval.I32X4_EXTEND_LOW_I16X8_S);
			I32X4_EXTEND_LOW_I16X8_U => 	do_s_s(V3Eval.I32X4_EXTEND_LOW_I16X8_U);
			I64X2_EXTEND_HIGH_I32X4_S => 	do_s_s(V3Eval.I64X2_EXTEND_HIGH_I32X4_S);
			I64X2_EXTEND_HIGH_I32X4_U => 	do_s_s(V3Eval.I64X2_EXTEND_HIGH_I32X4_U);
			I64X2_EXTEND_LOW_I32X4_S => 	do_s_s(V3Eval.I64X2_EXTEND_LOW_I32X4_S);
			I64X2_EXTEND_LOW_I32X4_U => 	do_s_s(V3Eval.I64X2_EXTEND_LOW_I32X4_U);
			I16X8_EXTMUL_LOW_I8X16_S => 	do_ss_s(V3Eval.I16X8_EXTMUL_LOW_I8X16_S);
			I16X8_EXTMUL_HIGH_I8X16_S => 	do_ss_s(V3Eval.I16X8_EXTMUL_HIGH_I8X16_S);
			I16X8_EXTMUL_LOW_I8X16_U => 	do_ss_s(V3Eval.I16X8_EXTMUL_LOW_I8X16_U);
			I16X8_EXTMUL_HIGH_I8X16_U => 	do_ss_s(V3Eval.I16X8_EXTMUL_HIGH_I8X16_U);
			I32X4_EXTMUL_LOW_I16X8_S => 	do_ss_s(V3Eval.I32X4_EXTMUL_LOW_I16X8_S);
			I32X4_EXTMUL_HIGH_I16X8_S => 	do_ss_s(V3Eval.I32X4_EXTMUL_HIGH_I16X8_S);
			I32X4_EXTMUL_LOW_I16X8_U => 	do_ss_s(V3Eval.I32X4_EXTMUL_LOW_I16X8_U);
			I32X4_EXTMUL_HIGH_I16X8_U => 	do_ss_s(V3Eval.I32X4_EXTMUL_HIGH_I16X8_U);
			I64X2_EXTMUL_LOW_I32X4_S => 	do_ss_s(V3Eval.I64X2_EXTMUL_LOW_I32X4_S);
			I64X2_EXTMUL_HIGH_I32X4_S => 	do_ss_s(V3Eval.I64X2_EXTMUL_HIGH_I32X4_S);
			I64X2_EXTMUL_LOW_I32X4_U => 	do_ss_s(V3Eval.I64X2_EXTMUL_LOW_I32X4_U);
			I64X2_EXTMUL_HIGH_I32X4_U => 	do_ss_s(V3Eval.I64X2_EXTMUL_HIGH_I32X4_U);
			I8X16_EXTRACT_LANE_S => 		doExtractLane(0, i8.view<u64>, i32.view<i8>, pushi);
			I8X16_EXTRACT_LANE_U => 		doExtractLane(0, u8.view<u64>, i32.view<u8>, pushi);
			I16X8_EXTRACT_LANE_S => 		doExtractLane(1, i16.view<u64>, i32.view<i16>, pushi);
			I16X8_EXTRACT_LANE_U => 		doExtractLane(1, u16.view<u64>, i32.view<u16>, pushi);
			I32X4_EXTRACT_LANE => 		doExtractLane(2, i32.view<u64>, i32.view<i32>, pushi);
			I64X2_EXTRACT_LANE => 		doExtractLane(3, i64.view<u64>, i64.view<i64>, pushl);
			F32X4_EXTRACT_LANE => 		doExtractLane(2, u32.view<u64>, float.view<u32>, pushf);
			F64X2_EXTRACT_LANE => 		doExtractLane(3, u64.view<u64>, double.view<u64>, pushd);
			I8X16_REPLACE_LANE => 		doReplaceLane(0, u8.view<i32>, popi, 0xFFul);
			I16X8_REPLACE_LANE => 		doReplaceLane(1, u16.view<i32>, popi, 0xFFFFul);
			I32X4_REPLACE_LANE => 		doReplaceLane(2, u32.view<i32>, popi, 0xFFFFFFFFul);
			I64X2_REPLACE_LANE => 		doReplaceLane(3, u64.view<i64>, popl, 0xFFFFFFFFFFFFFFFFul);
			F32X4_REPLACE_LANE => 		doReplaceLane(2, u32.view<float>, popf, 0xFFFFFFFFul);
			F64X2_REPLACE_LANE => 		doReplaceLane(3, u64.view<double>, popd, 0xFFFFFFFFFFFFFFFFul);
			F32X4_CONVERT_I32X4_S => 	do_s_s(V3Eval.F32X4_CONVERT_I32X4_S);
			F32X4_CONVERT_I32X4_U => 	do_s_s(V3Eval.F32X4_CONVERT_I32X4_U);
			F64X2_CONVERT_LOW_I32X4_S => 	do_s_s(V3Eval.F64X2_CONVERT_LOW_I32X4_S);
			F64X2_CONVERT_LOW_I32X4_U => 	do_s_s(V3Eval.F64X2_CONVERT_LOW_I32X4_U);
			I8X16_NARROW_I16X8_S => 	do_ss_s(V3Eval.I8X16_NARROW_I16X8_S);
			I8X16_NARROW_I16X8_U => 	do_ss_s(V3Eval.I8X16_NARROW_I16X8_U);
			I16X8_NARROW_I32X4_S => 	do_ss_s(V3Eval.I16X8_NARROW_I32X4_S);
			I16X8_NARROW_I32X4_U => 	do_ss_s(V3Eval.I16X8_NARROW_I32X4_U);
			F64X2_PROMOTE_LOW_F32X4 => 	do_s_s(V3Eval.F64X2_PROMOTE_LOW_F32X4);
			F32X4_DEMOTE_F64X2_ZERO => 	do_s_s(V3Eval.F32X4_DEMOTE_F64X2_ZERO);
			I32X4_RELAXED_TRUNC_F32X4_S,
			I32X4_TRUNC_SAT_F32X4_S => 	do_s_s(V3Eval.I32X4_TRUNC_SAT_F32X4_S);
			I32X4_RELAXED_TRUNC_F32X4_U,
			I32X4_TRUNC_SAT_F32X4_U => 	do_s_s(V3Eval.I32X4_TRUNC_SAT_F32X4_U);
			I32X4_RELAXED_TRUNC_F64X2_S_ZERO,
			I32X4_TRUNC_SAT_F64X2_S_ZERO => do_s_s(V3Eval.I32X4_TRUNC_SAT_F64X2_S_ZERO);
			I32X4_RELAXED_TRUNC_F64X2_U_ZERO,
			I32X4_TRUNC_SAT_F64X2_U_ZERO => do_s_s(V3Eval.I32X4_TRUNC_SAT_F64X2_U_ZERO);
			I8X16_SHUFFLE => doShuffle();
			I8X16_SWIZZLE,
			I8X16_RELAXED_SWIZZLE => doSwizzle();
			I16X8_RELAXED_DOT_I8X16_I7X16_S => do_ss_s(V3Eval.I16X8_RELAXED_DOT_I8X16_I7X16_S);
			I32X4_RELAXED_DOT_I8X16_I7X16_ADD_S => do_sss_s(V3Eval.I32X4_RELAXED_DOT_I8X16_I7X16_ADD_S);
			// ext:typed-continuation
			CONT_NEW => {
				var cont_index = codeptr.read_uleb31();
				Runtime.CONT_NEW(this, frame.func.instance, cont_index, make_new_v3_stack);
			}
			CONT_BIND => {
				var in_cont_index = codeptr.read_uleb31();
				var out_cont_index = codeptr.read_uleb31();
				Runtime.CONT_BIND(this, frame.func.instance, in_cont_index, out_cont_index);
			}
			RESUME => {
				var cont_idx = codeptr.read_uleb31();
				var handlers = codeptr.read_handlers();

				var cont_type = ContDecl.!(frame.func.instance.heaptypes[cont_idx]);
				var cont = popContinuation();
				if (cont == null) return void(trap(TrapReason.NULL_DEREF));
				if (cont.stack == null) return void(trap(TrapReason.USED_CONTINUATION));
				var stack = V3Interpreter.!(cont.stack);
				cont.stack = null;

				stack.bind(popN(cont_type.sig.params));
				resumeContinuation(stack);
				return; // skip setting frame.pc = codeptr.pos
			}
			RESUME_THROW => {
				var cont_idx = codeptr.read_uleb31();
				var tag_idx = codeptr.read_uleb31();
				var handlers = codeptr.read_handlers();

				var cont_type = ContDecl.!(frame.func.instance.heaptypes[cont_idx]);
				var cont = popContinuation();
				if (cont == null) return void(trap(TrapReason.NULL_DEREF));
				if (cont.stack == null) return void(trap(TrapReason.USED_CONTINUATION));
				var cont_stack = cont.stack;
				cont.stack = null;

				var tag = frame.func.instance.tags[tag_idx];
				var ex: Throwable = Exception.new(tag, popN(tag.sig.params), null);
				if (Trace.stack) Trace.OUT.put2("resume_throw %q %q", tag.render, cont.render).ln();

				// search for handler in continuation
				var top = V3Interpreter.!(cont_stack);
				top.frame.pc = top.suspend_pc;
				match (cont_stack.throw(ex)) {
					Handled(stack) => {
						if (Trace.stack) Trace.OUT.put1("tag %q handled in continuation, resuming", tag.render).ln();
						var handler = V3Interpreter.!(stack);
						handler.state_ = StackState.RESUMABLE;
						handler.cont_bottom = cont_stack.cont_bottom;
						resumeContinuation(handler);
						return; // skip setting frame.pc = codeptr.pos
					}
					Unhandled => {
						if (Trace.stack) Trace.OUT.put1("tag %q not handled in continuation, throwing", tag.render).ln();
						throw(ex);
					}
				}
			}
			SUSPEND => {
				var tag_idx = codeptr.read_uleb31();
				var tag = frame.func.instance.tags[tag_idx];

				state_ = StackState.SUSPENDED;
				params_arity = tag.sig.results.length;

				var cont = Runtime.unwindStackChain(this, frame.func.instance, tag_idx, WasmStack.tryHandleSuspension);
				if (cont == null) return void(trap(TrapReason.INVALID_SUSPEND));
				var bottom = cont.stack.cont_bottom;
				var handler = V3Interpreter.!(bottom.parent);
				bottom.parent = null;
				handler.pushN(popN(tag.sig.params));
				handler.push(Value.Ref(cont));
				goto_stack = handler;
				suspend_pc = frame.pc;
			}
			SWITCH => {
				// `target_cont`: the continuation to switch to
				// `this_cont`: the continuation created by this {switch}:
				//              (bottom: <handler stack child>, top: <curStack>)
				var target_cont_idx = codeptr.read_uleb31();
				var tag_idx = codeptr.read_uleb31();

				var tag = frame.func.instance.tags[tag_idx];
				var target_cont_decl = ContDecl.!(frame.func.instance.heaptypes[target_cont_idx]);
				var target_cont = popContinuation();
				if (target_cont == null) return void(trap(TrapReason.NULL_DEREF));
				if (target_cont.stack == null) return void(trap(TrapReason.USED_CONTINUATION));

				// -1 to exclude continuation parameter
				var target_params = target_cont_decl.sig.params;
				var vals = popN(target_params[0 ... target_params.length - 1]);

				var target_top_val = target_cont_decl.sig.params[target_cont_decl.sig.params.length - 1];
				var this_cont_decl = ContDecl.!(HeapType.Cont.!(ValueType.Ref.!(target_top_val).heap).cont);

				state_ = StackState.SUSPENDED;
				params_arity = this_cont_decl.sig.params.length;

				var cont = Runtime.unwindStackChain(this, frame.func.instance, tag_idx, WasmStack.tryHandleSwitch);
				if (cont == null) return void(trap(TrapReason.INVALID_SUSPEND));
				var handler = V3Interpreter.!(cont.stack.cont_bottom.parent);
				cont.stack.cont_bottom.parent = null;

				var stack = target_cont.stack;
				target_cont.stack = null;
				stack.cont_bottom.parent = handler;
				stack.bind(vals);
				stack.bind([Value.Ref(cont)]);
				goto_stack = V3Interpreter.!(stack);
				suspend_pc = frame.pc;
			}
			INVALID => trap(TrapReason.INVALID_OPCODE);
// Uncomment the default case when there is an unimplemented instruction.
//YAY(done!)		_ => {
//				trap(TrapReason.UNIMPLEMENTED);
//			}
		}
		if (frame != null) frame.pc = codeptr.pos;
	}
	def decodeMemArgAndGetMemoryRange(size: byte) -> MaybeTrap<Range<byte>> {
		var memarg = codeptr.read_MemArg();
		var memory = frame.func.instance.memories[memarg.memory_index];
		var index = popa(memory.decl.size);
		return memory.range_oil_64(memarg.offset, index, size);
	}
	def doLoad<T>(accessor: MemoryAccessor<T>, push: T -> void) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		push(accessor.read(t.result));
	}
	def doAtomicLoad<T>(accessor: MemoryAccessor<T>, push: T -> void) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		push(accessor.read(t.result)); // XXX: assumes "read" function is atomic
	}
	def doAtomicStore<T>(accessor: MemoryAccessor<T>, pop: void -> T) {
		var val = pop();
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		accessor.write(t.result, val); // XXX: assumes "write" function is atomic
	}
	def doAtomicRmw<T>(accessor: MemoryAccessor<T>, val: T, op: (T, T) -> T, push: T -> void) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var prev = accessor.read(t.result); // XXX: assumes no real threads
		var updated = op(prev, val);
		accessor.write(t.result, updated);
		push(prev);
	}
	def doAtomicXchg<T>(accessor: MemoryAccessor<T>, replacement: T, push: T -> void) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var loaded = accessor.read(t.result); // XXX: assumes no real threads
		accessor.write(t.result, replacement);
		push(loaded);
	}
	def doAtomicCmpXchg<T>(accessor: MemoryAccessor<T>, replacement: T, expected: T, push: T -> void) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var loaded = accessor.read(t.result); // XXX: assumes no real threads
		if (loaded == expected) accessor.write(t.result, replacement);
		push(loaded);
	}
	def doLoadLane<T>(accessor: MemoryAccessor<T>) {
		var v = pops();
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		var idx = codeptr.read1();
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = u64.!(accessor.read(t.result));
		var low = v.0, high = v.1;
		def half_lanes = 8 >> accessor.log2_size;
		if (idx < half_lanes) { // Update a lane in low
			var shift = u6.view(idx << u3.+(accessor.log2_size, 3));
			val <<= shift;
			low |= val;
		} else { // Update a lane in high
			var shift = u6.view((idx - half_lanes) << u3.+(accessor.log2_size, 3));
			val <<= shift;
			high |= val;
		}
		pushs(low, high);
	}
	def doLoadZero<T>(accessor: MemoryAccessor<T>) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = u64.!(accessor.read(t.result));
		var high = 0ul;
		pushs(val, high);
	}
	// Tn: narrow source type, Sw: (signed) wide type, Uw: corresponding unsigned wide type
	def doLoadExtend<Tn, Sw, Uw>(size: byte, view: u64 -> Tn, extend: Tn -> Sw, convert: Sw -> Uw) {
		var t = decodeMemArgAndGetMemoryRange(8);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = DataReaders.read_range_u64(t.result);
		var low = 0ul, high = 0ul;
		def src_shift = u6.view(size << 3);
		def dst_shift = u6.view(src_shift << 1);
		var shift: u6 = 0;
		for (i = 0; i < 4; i += size) {
			var v = u64.!(convert((extend(view(val)))));
			val >>= src_shift;
			low |= (v << shift);
			shift += dst_shift;
		}
		shift = 0;
		for (i = 0; i < 4; i += size) {
			var v = u64.!(convert((extend(view(val)))));
			val >>= src_shift;
			high |= (v << shift);
			shift += dst_shift;
		}
		push(Value.V128(low, high));
	}
	def doReplaceLane<T, S>(log2_size: u3, view: S -> T, stack_pop: void -> S, mask: u64) {
		var val = u64.!(view(stack_pop()));
		var v = pops();
		var idx = codeptr.read1();
		var low = v.0, high = v.1;
		def half_lanes = 8 >> log2_size;
		if (idx < half_lanes) { // Update a lane in low
			var shift = u6.view(idx << u3.+(log2_size, 3));
			mask <<= shift;
			low &= ~mask; // Zero out the target lane in low
			val <<= shift;
			low |= val;
		} else { // Update a lane in high
			var shift = u6.view((idx - half_lanes) << u3.+(log2_size, 3));
			mask <<= shift;
			high &= ~mask; // Zero out the target lane in high
			val <<= shift;
			high |= val;
		}
		push(Value.V128(low, high));
	}
	def doExtractLane<T, S>(log2_size: u3, view: u64 -> T, extend: T -> S, stack_push: S -> void) {
		var v = pops();
		var idx = codeptr.read1();
		var val = doExtractLane0(v, idx, log2_size, view, extend);
		stack_push(S.!(val));
	}
	def doExtractLane0<T, S>(v: (u64, u64), idx: byte, log2_size: u3, view: u64 -> T, extend: T -> S) -> S {
		var low = v.0, high = v.1;
		var val: S;
		def half_lanes = 8 >> log2_size;
		if (idx < half_lanes) { // Extract a lane from low
			var shift = u6.view(idx << u3.+(log2_size, 3));
			val = extend(view(low >> shift));
		} else { // Extract a lane from high
			var shift = u6.view((idx - half_lanes) << u3.+(log2_size, 3));
			val = extend(view(high >> shift));
		}
		return val;
	}
	def doShuffle(){
		var b = pops();
		var a = pops();
		var low = doShuffle0(a, b);
		var high = doShuffle0(a, b);
		push(Value.V128(low, high));
	}
	def doShuffle0(a: (u64, u64), b: (u64, u64)) -> u64 {
		var res = 0ul;
		for (i < 8) {
			var idx = codeptr.read1();
			var val = if (idx < 16, doExtractLane0(a, idx, 0, u8.view<u64>, u8.view<u8>),
									doExtractLane0(b, byte.!(idx - 16), 0, u8.view<u64>, u8.view<u8>));
			res |= u64.view(val) << u6.view(i << 3);
		}
		return res;
	}
	def doSwizzle(){
		var b = pops();
		var a = pops();
		var low = doSwizzle0(a, b.0);
		var high = doSwizzle0(a, b.1);
		push(Value.V128(low, high));
	}
	def doSwizzle0(a: (u64, u64), b: u64) -> u64 {
		var res = 0ul;
		for (i < 8) {
			var idx = u8.view(b);
			// For indices outside of the range the resulting lane is initialized to 0
			var val = if (idx < 16, doExtractLane0(a, idx, 0, u8.view<u64>, u8.view<u8>), 0);
			res |= u64.view(val) << u6.view(i << 3);
			b >>= 8;
		}
		return res;
	}
	def doLoadSplat<T>(accessor: MemoryAccessor<T>) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = u64.!(accessor.read(t.result));
		doSplatV(accessor.size, accessor.log2_size, val);
	}
	def doSplat<T, S>(size: byte, log2_size: u5, view: S -> T, stack_pop: void -> S) {
		var val = u64.!(view((stack_pop())));
		doSplatV(size, log2_size, val);
	}
	def doSplatV(size: byte, log2_size: u5, val: u64) {
		var low = 0ul, high = 0ul;
		def half_lanes = 8 >> log2_size;
		var shift = u6.view(size << 3);
		for (i < half_lanes) {
			low <<= shift;
			low |= val;
			high <<= shift;
			high |= val;
		}
		push(Value.V128(low, high));
	}
	def doStore<T>(accessor: MemoryAccessor<T>, val: T) {
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		if (t.reason != TrapReason.NONE) trap(t.reason);
		else accessor.write(t.result, val);
	}
	def doStoreLane<T>(accessor: MemoryAccessor<T>, view: u64 -> T) {
		var v = pops();
		var t = decodeMemArgAndGetMemoryRange(accessor.size);
		var idx = codeptr.read1(); // get lane immediate
		if (t.reason != TrapReason.NONE) trap(t.reason);
		// Extract lane
		var low = v.0, high = v.1;
		var val: T;
		def half_lanes = 8 >> accessor.log2_size;
		if (idx < half_lanes) { // Extract a lane from low
			var shift = u6.view(idx << u3.+(accessor.log2_size, 3));
			val = view(low >> shift);
		} else { // Extract a lane from high
			var shift = u6.view((idx - half_lanes) << u3.+(accessor.log2_size, 3));
			val = view(high >> shift);
		}
		// Write to memory
		accessor.write(t.result, val);
	}
	def doFallthru() {
		frame.stp += 4;
	}
	def doBranch(pc: int, cond: bool) -> bool {
		if (cond) {
			codeptr.at(doGoto(pc));
		} else {
			codeptr.skip_label();
			doFallthru();
		}
		return cond;
	}
	def doGoto(pc: int) -> int {
		var stp = frame.stp, sidetable = frame.func.decl.sidetable;
		return doCtlXfer(pc, stp, sidetable);
	}
	def doSwitch(pc: int, key: u32) -> int {
		var stp = frame.stp, sidetable = frame.func.decl.sidetable;
		var max = sidetable.entries[stp];
		var index = if(key >= max, max, 1 + int.!(key));
		stp += index << 2;
		pc += index;
		return doCtlXfer(pc, stp, sidetable);
	}
	def doCtlXfer(pc: int, stp: int, sidetable: Sidetable) -> int {
		var e = sidetable.getBrEntry(stp);
		frame.stp = stp + e.dstp;
		if (e.popcount > 0) {
			if (e.valcount > 0) copyVals(e.valcount, values.top - int.!(e.popcount + e.valcount));
			else values.top -= e.popcount;
		}
		return pc + e.dpc;
	}
	def advanceCaller() {
		if (Debug.interpreter) Trace.OUT.put3("advance %q pc=%d codeptr.pos=%d", frame.func.render, frame.pc, codeptr.pos).ln();
		// XXX: use read_opcode_and_skip()
		var opcode = codeptr.read_opcode_but_skip_probe(frame.func.decl);
		match (opcode) {
			CALL, CALL_REF => {
				codeptr.skip_leb();
				frame.pc = codeptr.pos;
			}
			CALL_INDIRECT => {
				codeptr.skip_leb();
				codeptr.skip_leb();
				frame.pc = codeptr.pos;
			}
			_ => {
				fail(Strings.format1("expected call instruction in return, got %s", opcode.name));
			}
		}
	}
	def prepareReturnCall(sig: SigDecl) {
		copyVals(sig.params.length, frame.fp);
		frame = popFrame();
	}
	def lookupIndirect(sig_index: u32, table_index: u32, func_index: u64) -> Function {
		var instance = frame.func.instance;
		var table = instance.tables[table_index];
		if (func_index >= table.elems.length) {
			trap(TrapReason.FUNC_INVALID);
			return null;
		}
		var expected = SigDecl.!(instance.heaptypes[sig_index]);
		var f = table.funcs[func_index];
		if (f == null) { trap(TrapReason.FUNC_INVALID); return null; }
		if (!ValueTypes.isAssignableHeap(f.sig, expected)) { trap(TrapReason.FUNC_SIG_MISMATCH); return null; }
		return f;
	}
	def onChildTerminate(vals: Array<Value>) {
		if (Trace.stack) Trace.OUT.put1("onChildTerminate parent_stack[pc=%d]", frame.pc).ln();
		values.pusha(vals);
		state_ = StackState.RESUMABLE;
		// advance past resume instruction
		var code = frame.func.decl.cur_bytecode;
		codeptr.reset(code, frame.pc, code.length);
		var opcode = codeptr.read_opcode_and_skip(frame.func.decl);
		frame.pc = codeptr.pos;
		// advance past resume sidetable entries
		// XXX: do not use sidetable for this
		var entry = frame.func.decl.sidetable.getResumeEntry(frame.stp);
		frame.stp += Sidetable_ResumeEntry.size / 4;
		frame.stp += entry.nhandlers * Sidetable_SuspendHandlerEntry.size / 4;
		match (opcode) {
			RESUME, RESUME_THROW => ;
			_ => fail(Strings.format1("expected resume instruction in child terminate, got %s", opcode.name));
		}
	}
	def tryHandleSuspension(tag: Tag) -> ExHandler {
		var handler = frame.func.decl.findSuspensionHandler(frame.func.instance, tag, frame.pc);
		if (handler.handler_pc < 0) { // not found
			if (Trace.stack) Trace.OUT.puts("  suspension handler not found, continue to unwind").ln();
			return handler;
		}
		if (Trace.stack) {
			Trace.OUT.put1("  found suspend handler: pc=%d,", handler.handler_pc);
			Trace.OUT.put1(" stp=%d", handler.sidetable_pos).ln();
		}
		values.top = frame.fp + handler.val_stack_top + frame.func.decl.num_locals;
		var code = frame.func.decl.cur_bytecode;
		frame.pc = handler.handler_pc;
		frame.stp = handler.sidetable_pos;
		codeptr.reset(code, frame.pc, code.length);
		state_ = StackState.RESUMABLE;
		return handler;
	}
	def tryHandleSwitch(tag: Tag) -> ExHandler {
		var handler = frame.func.decl.findSwitchHandler(frame.func.instance, tag, frame.pc);
		if (handler.handler_pc < 0) { // not found
			if (Trace.stack) Trace.OUT.puts("  switch handler not found, continue to unwind").ln();
			return handler;
		}
		if (Trace.stack) Trace.OUT.puts("  found switch handler").ln();
		return handler;
	}
	def onChildThrow(t: Throwable) {
		state_ = StackState.RESUMABLE;
		throw(t);
	}
	def resumeContinuation(stack: V3Interpreter) {
		state_ = StackState.CALL_CHILD;
		stack.cont_bottom.parent = this;
		stack.cont_bottom = null;
		goto_stack = V3Interpreter.!(stack);
	}
	def throw(t: Throwable) -> ThrowResult {
		if (Trace.stack) Trace.OUT.put1("throw on stack: %q", t.render).ln();
		if (Exception.?(t)) {
			var ex = Exception.!(t);
			for (stack = this; stack != null; stack = V3Interpreter.!(stack.parent)) {
				for (f = stack.frame; f != null && f.func != null; f = f.prev) {
					if (stack.tryHandleEx(ex, f)) {
						if (stack == this) { // don't transfer
							return ThrowResult.Handled(this);
						} else { // go to handler stack
							state_ = StackState.THROWING;
							goto_stack = stack;
							goto_stack.state_ = StackState.RESUMABLE;
							return ThrowResult.Handled(stack);
						}
					}
				}
				stack.trapWith(ex);
			}
			return ThrowResult.Unhandled(thrown);
		}

		trapWith(t);
		return ThrowResult.Unhandled(thrown);
	}
	// Returns whether the given exception can be handled by the given frame.
	private def tryHandleEx(ex: Exception, f: V3Frame) -> bool {
		var handler = f.func.decl.findExHandler(f.func.instance, ex.tag, f.pc);
		if (handler.handler_pc >= 0) {
			frame = f;
			var code = f.func.decl.cur_bytecode;
			f.pc = handler.handler_pc;
			f.stp = handler.sidetable_pos;
			codeptr.reset(code, f.pc, code.length);
			// TODO: clean up frame math here
			values.top = f.fp + handler.val_stack_top + f.func.decl.num_slots();
			for (v in ex.vals) values.push(v);
			if (handler.ex_slot >= 0) {
				if (Trace.exception) Trace.OUT.put2("  set_ex_slot fp=%d, ex_slot=%d", f.fp, handler.ex_slot).ln();
				values.elems[f.fp + f.func.decl.num_locals + handler.ex_slot] = Value.Ref(ex);
			}
			if (handler.push_exnref) {
				if (Trace.exception) Trace.OUT.puts("  push_exnref").ln();
				values.push(Value.Ref(ex));
			}
			return true;
		}
		return false;
	}
	// Marks this stack as throwing with {t}.
	private def trapWith(t: Throwable) {
		var segment = popAllFrames(true);
		if (segment != null) t = t.prependFrames(segment.frames).prependHostFunction(segment.host);
		state_ = StackState.THROWING;
		thrown = t; // unhandled exception
	}

	def trap(reason: TrapReason) -> Throwable {
		var stacktrace = popAllFrames(true);
		thrown = Trap.new(reason, null, stacktrace);
		state_ = StackState.THROWING;
		return thrown;
	}
	def fail(msg: string) {
		var stacktrace = popAllFrames(true);
		thrown = InternalError.new(msg, stacktrace);
		state_ = StackState.THROWING;
	}
	def pop() -> Value { return values.pop(); }
	def popV(t: ValueType) -> Value { return values.pop(); }
	def popi() -> i32 { return Values.unbox_i(values.pop()); }
	def popu() -> u32 { return Values.unbox_u(values.pop()); }
	def popu8() -> u8 { return u8.view(Values.unbox_u(values.pop())); }
	def popu16() -> u16 { return u16.view(Values.unbox_u(values.pop())); }
	def popl() -> i64 { return Values.unbox_l(values.pop()); }
	def popw() -> u64 { return Values.unbox_w(values.pop()); }
	def popw8() -> u8 { return u8.view(Values.unbox_w(values.pop())); }
	def popw16() -> u16 { return u16.view(Values.unbox_w(values.pop())); }
	def popw32() -> u32 { return u32.view(Values.unbox_w(values.pop())); }
	def popf() -> float { return Values.unbox_f(values.pop()); }
	def popd() -> double { return Values.unbox_d(values.pop()); }
	def pops() -> (u64, u64) { return Values.unbox_s(values.pop()); }
	def popr() -> Value.Ref { return Value.Ref.!(values.pop()); } // TODO: i31
	def popObject() -> Object { return Value.Ref.!(values.pop()).val; }
	def popArray() -> HeapArray { return HeapArray.!(Value.Ref.!(values.pop()).val); }
	def popStruct() -> HeapStruct { return HeapStruct.!(Value.Ref.!(values.pop()).val); }
	def popContinuation() -> Continuation { return Continuation.!(Value.Ref.!(values.pop()).val); }
	def push(val: Value) { values.push(val); }
	def pushi(val: i32) { values.push(Value.I32(u32.view(val))); }
	def pushi8(val: i8) { values.push(Value.I32(u32.view(val))); }
	def pushi16(val: i16) { values.push(Value.I32(u32.view(val))); }
	def pushu(val: u32) { values.push(Value.I32(val)); }
	def pushu8(val: u8) { values.push(Value.I32(val)); }
	def pushu16(val: u16) { values.push(Value.I32(val)); }
	def pushl(val: i64) { values.push(Value.I64(u64.view(val))); }
	def pushl8(val: i8) { values.push(Value.I64(u64.view(val))); }
	def pushl16(val: i16) { values.push(Value.I64(u64.view(val))); }
	def pushl32(val: i32) { values.push(Value.I64(u64.view(val))); }
	def pushw(val: u64) { values.push(Value.I64(val)); }
	def pushw8(val: u8) { values.push(Value.I64(val)); }
	def pushw16(val: u16) { values.push(Value.I64(val)); }
	def pushw32(val: u32) { values.push(Value.I64(val)); }
	def pushf(val: float) { values.push(Value.F32(u32.view(val))); }
	def pushd(val: double) { values.push(Value.F64(u64.view(val))); }
	def pushz(val: bool) { values.push(if(val, Values.I32_1, Values.I32_0)); }
	def pushs(low: u64, high: u64) { values.push(Value.V128(low, high)); }
	def pushN(vs: Range<Value>) { for (i < vs.length) push(vs[i]); }
	def popN(t: Range<ValueType>) -> Array<Value> {
		var result = Array<Value>.new(t.length);
		var sp = values.top - t.length;
		for (i < t.length) result[i] = values.elems[sp + i];
		values.top = sp;
		return result;
	}
	def tagToValue(t: byte) -> Value {
		match (t) {
			BpTypeCode.I8.code,
			BpTypeCode.I16.code,
			BpTypeCode.I32.code => return Values.I32_0;
			BpTypeCode.I64.code => return Values.I64_0;
			BpTypeCode.F32.code => return Values.F32_0;
			BpTypeCode.F64.code => return Values.F64_0;
			BpTypeCode.V128.code => return Values.V128_0;
			_ => return Values.REF_NULL;
		}
	}
	// XXX: reduce duplication of d_xx_x methods
	def do_dd_d(f: (double, double) -> double) {
		var y = Values.unbox_d(values.elems[values.top-1]);
		var x = Values.unbox_d(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.F64(u64.view(r));
		values.top--;
	}
	def do_ff_f(f: (float, float) -> float) {
		var y = Values.unbox_f(values.elems[values.top-1]);
		var x = Values.unbox_f(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.F32(u32.view(r));
		values.top--;
	}
	def do_dd_z(f: (double, double) -> bool) {
		var y = Values.unbox_d(values.elems[values.top-1]);
		var x = Values.unbox_d(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ff_z(f: (float, float) -> bool) {
		var y = Values.unbox_f(values.elems[values.top-1]);
		var x = Values.unbox_f(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ii_i(f: (i32, i32) -> i32) {
		var y = Values.unbox_i(values.elems[values.top-1]);
		var x = Values.unbox_i(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I32(u32.view(r));
		values.top--;
	}
	def do_uu_u(f: (u32, u32) -> u32) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I32(r);
		values.top--;
	}
	def do_uu_ut(f: (u32, u32) -> (u32, TrapReason)) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I32(r.0);
		values.top--;
	}
	def do_ii_it(f: (i32, i32) -> (i32, TrapReason)) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(i32.view(x), i32.view(y));
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I32(u32.view(r.0));
		values.top--;
	}
	def do_u_u(f: u32 -> u32) {
		var x = Values.unbox_u(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.I32(r);
	}
	def do_ii_z(f: (i32, i32) -> bool) {
		var y = Values.unbox_i(values.elems[values.top-1]);
		var x = Values.unbox_i(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_uu_z(f: (u32, u32) -> bool) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ll_l(f: (i64, i64) -> i64) {
		var y = Values.unbox_l(values.elems[values.top-1]);
		var x = Values.unbox_l(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I64(u64.view(r));
		values.top--;
	}
	def do_ll_lt(f: (i64, i64) -> (i64, TrapReason)) {
		var y = Values.unbox_l(values.elems[values.top-1]);
		var x = Values.unbox_l(values.elems[values.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I64(u64.view(r.0));
		values.top--;
	}
	def do_ww_w(f: (u64, u64) -> u64) {
		var y = Values.unbox_w(values.elems[values.top-1]);
		var x = Values.unbox_w(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I64(r);
		values.top--;
	}
	def do_ww_wt(f: (u64, u64) -> (u64, TrapReason)) {
		var y = Values.unbox_w(values.elems[values.top-1]);
		var x = Values.unbox_w(values.elems[values.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I64(r.0);
		values.top--;
	}
	def do_w_w(f: u64 -> u64) {
		var x = Values.unbox_w(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.I64(r);
	}
	def do_ll_z(f: (i64, i64) -> bool) {
		var y = Values.unbox_l(values.elems[values.top-1]);
		var x = Values.unbox_l(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ww_z(f: (u64, u64) -> bool) {
		var y = Values.unbox_w(values.elems[values.top-1]);
		var x = Values.unbox_w(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_s_s(f: (u64, u64) -> (u64, u64)) {
		var x = Values.unbox_s(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.V128(r.0, r.1);
	}
	def do_ss_s(f: ((u64, u64), (u64, u64)) -> (u64, u64)) {
		var y = Values.unbox_s(values.elems[values.top-1]);
		var x = Values.unbox_s(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.V128(r.0, r.1);
		values.top--;
	}
	def do_si_s(f: ((u64, u64), i32) -> (u64, u64)) {
		var y = Values.unbox_i(values.elems[values.top-1]);
		var x = Values.unbox_s(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.V128(r.0, r.1);
		values.top--;
	}
	def do_sss_s(f: ((u64, u64), (u64, u64), (u64, u64)) -> (u64, u64)) {
		var z = Values.unbox_s(values.elems[values.top-1]);
		var y = Values.unbox_s(values.elems[values.top-2]);
		var x = Values.unbox_s(values.elems[values.top-3]);
		var r = f(x, y, z);
		values.elems[values.top-3] = Value.V128(r.0, r.1);
		values.top -= 2;
	}
	def do_s_z(f: (u64, u64) -> bool) {
		var x = Values.unbox_s(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = if(r, Values.I32_1, Values.I32_0);
	}
	def do_s_i(f: (u64, u64) -> i32) {
		var x = Values.unbox_s(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.I32(u32.view(r));
	}
	def do_f_f(f: float -> float) {
		var x = Values.unbox_f(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.F32(u32.view(r));
	}
	def do_d_d(f: double -> double) {
		var x = Values.unbox_d(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.F64(u64.view(r));
	}
	def traceStack() {
		var out = Trace.OUT;
		var last_fp = values.top;
		for (f = frame; f != null; f = f.prev) {
			out.puts("  ===={ ");
			f.func.render(out);
			out.put1(" @ %d }====", f.pc).ln();
			var num_locals = f.func.decl.num_locals;
			var num_params = f.func.sig.params.length;
			for (i = last_fp - 1; i >= f.fp; i--) {
				var index = i - f.fp;
				if (index == (num_locals - 1)) out.put1("  ----- locals = %d -----", f.func.decl.num_locals).ln();
				if (index < num_locals) out.puts("  ").mark().putd(index).rjustify_mark(5).puts(" | ");
				else out.puts("        | ");
				Values.render(values.elems[i], out);
				out.ln();
			}
			out.ln();
			last_fp = f.fp;
		}
	}
}

class V3Frame {
	// state for managing the doubly-linked list
	def stack: V3Interpreter;
	def prev: V3Frame;
	def depth: int = if(prev != null, 1 + prev.depth);
	def var next: V3Frame;

	// state for the current activation
	var func: WasmFunction;		// wasm function
	var fp: int;			// frame pointer; i.e. base of locals
	var pc: int;			// program counter
	var stp: int;			// sidetable pointer
	var accessor: V3FrameAccessor;	// accessor, if any

	new(stack, prev) {
		if (prev != null) prev.next = this;
	}
}

private class V3HostFrame(prev: V3Frame) extends HostFrame {
	def caller() -> FrameLoc {
		return if(prev != null, FrameLoc.Wasm(prev.func, prev.pc, TargetFrame(prev)));
	}
}

class V3FrameAccessor(frame: V3Frame) extends FrameAccessor {
	var writer: V3FrameWriter;

	// Returns {true} if this frame has been unwound, either due to returning, a trap, or exception.
	def isUnwound() -> bool {
		return frame.accessor != this;
	}
	// Returns the Wasm function in this frame.
	def func() -> WasmFunction {
		checkNotUnwound();
		return frame.func;
	}
	// Returns the current program counter.
	def pc() -> int {
		checkNotUnwound();
		return frame.pc;
	}
	// Returns {true} if this frame is currently the top executing frame, {false} if the
	// frame has called another function or been unwound.
	private def isTop() -> bool {
		return if(!isUnwound(), frame.stack.frame == frame);
	}
	// Returns the call depth of this frame within its segment, with the bottom frame being #0.
	def depth() -> int {
		return frame.depth;
	}
	// Get the caller frame, either a wasm or host function. If none, then {Frame.func} will be {null}.
	def caller() -> FrameLoc {
		checkNotUnwound();
		var p = frame.prev;
		if (p == null) return FrameLoc.None;
		return FrameLoc.Wasm(p.func, p.pc, TargetFrame(p));
	}
	// Returns the current program counter.
	def stp() -> int {
		checkNotUnwound();
		return frame.stp;
	}
	// Get the number of local variables in this frame.
	def numLocals() -> int {
		checkNotUnwound();
		return frame.func.decl.num_locals;
	}
	// Get the number of frame variables in this frame.
	def numFrameVars() -> int {
		checkNotUnwound();
		var tags = frame.func.decl.frame_var_tags;
		return if(tags != null, tags.length);
	}
	// Get the value of local variable {i}.
	def getLocal(i: int) -> Value {
		checkNotUnwound();
		if (u32.view(i) >= frame.func.decl.num_locals) fatal("local index out-of-bounds");
		return frame.stack.values.elems[frame.fp + i];
	}
	// Get the value of frame variable {i}.
	def getFrameVar(i: int) -> Value {
		checkNotUnwound();
		var decl = frame.func.decl;
		if (decl.frame_var_tags == null || u32.view(i) >= decl.frame_var_tags.length) fatal("frame var index out-of-bounds");
		return frame.stack.values.elems[frame.fp + decl.num_locals + i];
	}
	// Get the number of operand stack elements.
	def numOperands() -> int {
		checkNotUnwound();
		if (!isTop()) fatal("numOperands only supported for top frame"); // TODO
		return frame.stack.values.top - (frame.fp + frame.func.decl.num_locals);
	}
	// Get operand at depth {i}, with 0 being the top of the stack, -1 being one lower, etc.
	def getOperand(i: int) -> Value {
		checkNotUnwound();
		if (!isTop()) fatal("numOperands only supported for top frame"); // TODO
		return frame.stack.values.elems[frame.stack.values.top + i - 1]; // TODO: bounds check
	}
	// Get the frame writer.
	def getWriter() -> V3FrameWriter {
		return if(writer != null, writer, writer = V3FrameWriter.new(this));
	}

	private def checkNotUnwound() {
		if (isUnwound()) fatal("frame has been unwound");
	}
}

private class V3FrameWriter extends FrameWriter {
	private def accessor: V3FrameAccessor;

	new(accessor) { }

	// Set the value of a local variable. (dynamically typechecked).
	def setLocal(i: int, v: Value) {
		// TODO: dynamically typecheck
		accessor.checkNotUnwound();
		if (u32.view(i) >= accessor.frame.func.decl.num_locals) fatal("local index out-of-bounds");
		accessor.frame.stack.values.elems[accessor.frame.fp + i] = v;
	}
	// Set the value of a frame variable. (dynamically typechecked).
	def setFrameVar(i: int, v: Value) {
		// TODO: dynamically typecheck
		accessor.checkNotUnwound();
		var frame = accessor.frame, decl = frame.func.decl;
		if (decl.frame_var_tags == null || u32.view(i) >= decl.frame_var_tags.length) fatal("frame var index out-of-bounds");
		frame.stack.values.elems[frame.fp + decl.num_locals + i] = v;
	}
}
def fatal = System.error("V3InterpreterError", _);

// Connect a Virgil type <T> to accessing memory (read, write, and push/pop from value stack).
private class MemoryAccessor<T>(size: byte, log2_size: u3, read: Range<byte> -> T, write: (Range<byte>, T) -> void) { }

def ACCESS_I8 = MemoryAccessor.new(1, 0, DataReaders.read_range_i8, DataWriters.write_range_i8);
def ACCESS_U8 = MemoryAccessor.new(1, 0, DataReaders.read_range_u8, DataWriters.write_range_u8);
def ACCESS_I16 = MemoryAccessor.new(2, 1, DataReaders.read_range_i16, DataWriters.write_range_i16);
def ACCESS_U16 = MemoryAccessor.new(2, 1, DataReaders.read_range_u16, DataWriters.write_range_u16);
def ACCESS_I32 = MemoryAccessor.new(4, 2, DataReaders.read_range_i32, DataWriters.write_range_i32);
def ACCESS_U32 = MemoryAccessor.new(4, 2, DataReaders.read_range_u32, DataWriters.write_range_u32);
def ACCESS_U64 = MemoryAccessor.new(8, 3, DataReaders.read_range_u64, DataWriters.write_range_u64);
def ACCESS_F32 = MemoryAccessor.new(4, 2, DataReaders.read_range_float, DataWriters.write_range_float);
def ACCESS_F64 = MemoryAccessor.new(8, 3, DataReaders.read_range_double, DataWriters.write_range_double);
def ACCESS_V128 = MemoryAccessor.new(16, 4, DataReaders.read_range_u128, DataWriters.write_range_u128);

def make_new_v3_stack(func: Function) -> WasmStack {
	var stack = V3Interpreter.new();
	stack.reset(func);
	return stack;
}
