// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Executes wasm code using portable Virgil III code and datastructures.
def OUT = Trace.OUT;
component V3Interpreter {
	private var instrTracer: InstrTracer;
	def val_stack = ArrayStack<Value>.new();	// XXX: inline value stack array and top
	private def codeptr = CodePtr.new(null);	// pointer into code
	private var thrown: Throwable;			// trap reason, if any

	var num_frames: int;			// number of frames on the call stack (including host frames)
	var call_stack_size: int;		// number of non-host frames
	var frame: V3Frame = null;		// points to the top frame
	var host_frame: V3Frame = null;		// points to the top host frame

	def call(f: Function, args: Array<Value>) -> Result {
		var val_stack_top = val_stack.top;

		// Push arguments onto the stack
		if (args != null) for (a in args) val_stack.push(a);
		// Begin execution
		var old_frame = frame;
		var old_frame_index = if(frame == null, 0, frame.index);
		var old_host_frame = host_frame;

		doCallFunction(f);
		while (frame != null && frame.index > old_frame_index) {
			if (Instrumentation.probes != null) {
				var ret = Instrumentation.fireProbes(DynamicLoc(frame.func, frame.pc, TargetFrame(frame)));
				if (ret != null) return finish(ret);
			}
			var pc = codeptr.pos;
			var b = codeptr.peek1();
			var opcode: Opcode;
			if (b == InternalOpcode.PROBE.code) {
				var ret = Instrumentation.fireProbesAt(DynamicLoc(frame.func, pc, TargetFrame(frame)));
				if (ret != null) return finish(ret);
				opcode = codeptr.read_orig_opcode(frame.func.decl.orig_bytecode[pc]);
			} else {
				opcode = codeptr.read_opcode();
			}
			execOp(pc, opcode);
		}

		for (f = frame; f != old_frame; f = f.prev) f.accessor = null;
		frame = old_frame;
		host_frame = old_host_frame;
		if (thrown != null) {
			var thrown = this.thrown;
			this.thrown = null;
			val_stack.top = val_stack_top;
			return Result.Throw(thrown);
		}
		return Result.Value(popN(f.sig.results.length));
	}
	def finish(ret: Throwable) -> Result {
		return Result.Throw(Trap.!(ret));
	}
	def reset() {
		for (f = frame; f != null; f = f.prev) f.accessor = null;
		thrown = null;
		val_stack.top = 0;
		num_frames = 0;
		call_stack_size = 0;
		frame = null;
		host_frame = null;
	}
	def doCallFunction(func: Function) {
		while (true) {
			match (func) {
				wf: WasmFunction => return pushFrame(wf);
				hf: HostFunction => {
					var old_top = host_frame;
					var result = doInvokeHostFunction(hf);
					match (result) {
						Throw(thrown) => {
							thrown.prepend(popFrames(old_top), hf);
							this.thrown = thrown;
							return;
						}
						Value0 => ;
						Value1(val) => {
							val_stack.push(val);
						}
						ValueN(vals) => {
							for (a in vals) val_stack.push(a);
						}
						TailCall(f, args) => {
							func = f;
							for (e in args) val_stack.push(e);
							continue; // execute a tail call to a new function
						}
					}
					if (frame == null) {  // popped top frame, finished execution
						codeptr.reset(null, 0, 0);
					} else if (frame.func != null) {
						advanceCaller();
					}
					return;
				}
			}
		}
	}
	def pushFrame(f: WasmFunction) {
		if (call_stack_size >= Execute.limits.max_call_depth) {
			return trap(TrapReason.STACK_OVERFLOW);
		}

		call_stack_size++;
		// Allocate a frame
		var nf = getNextFrame();
		var sp = val_stack.top;
		nf.fp = sp - f.decl.sig.params.length;

		// Setup function and code pointer
		nf.func = f;
		nf.pc = 0;
		nf.stp = 0;
		nf.accessor = null;

		var code = f.decl.cur_bytecode;
		codeptr.reset(code, 0, code.length);
		// Initialize locals
		codeptr.iterate_local_codes(push_locals);
		for (i < f.decl.num_ex_slots) val_stack.push(Values.REF_NULL); // init ex slots
		nf.pc = codeptr.pos; // move code pointer after locals

		// fire entry probe(s) before executing bytecode.
		if (f.decl.entry_probed) {
			var ret = Instrumentation.fireProbesAt(DynamicLoc(f, 0, TargetFrame(frame)));
			match (ret) {
				x: Exception => throw(x);
				x: Throwable => thrown.prepend(popFrames(host_frame), null);
			}
		}
	}
	def push_locals(count: u32, vtc: ValueTypeCode) {
		var val: Value;
		match (vtc.toConcreteValueKind(frame.func.instance)) {
			I32 => val = Values.I32_0;
			I64 => val = Values.I64_0;
			F32 => val = Values.F32_0;
			F64 => val = Values.F64_0;
			V128 => val = Values.V128_0;
			REF => val = Values.REF_NULL;
			ABS => val = Values.REF_NULL; // TODO: should not happen
		}
		val_stack.pushn(val, int.!(count));
	}
	def execOp(pc: int, opcode: Opcode) {
		match (opcode) {
			UNREACHABLE => {
				trap(TrapReason.UNREACHABLE);
			}
			NOP => {
				// do nothing
			}
			TRY,
			BLOCK,
			LOOP => {
				codeptr.skip_block_type();
			}
			IF => {
				var cond = popi();
				if (cond == 0) {
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_block_type();
					doFallthru();
				}
			}
			CATCH,
			CATCH_ALL,
			ELSE => {
				codeptr.at(doGoto(pc));
			}
			DELEGATE => {
				codeptr.skip_label();
			}
			THROW => {
				var index = codeptr.read_uleb31();
				var tag = frame.func.instance.tags[index];
				var ex = Exception.new(tag, popN(tag.decl.fields.length), null);
				throw(ex);
			}
			RETHROW => {
				var sidetable = frame.func.decl.sidetable;
				var ex_slot = sidetable.entries[frame.stp];
				if (Trace.exception) Trace.OUT.put2("  rethrow fp=%d ex_slot=%d", frame.fp, ex_slot).outln();
				var popcount = sidetable.entries[frame.stp + 2], valcount = 0;
				if (popcount > 0) {
					copyVals(valcount, val_stack.top - int.!(popcount + valcount));
				}
				frame.stp += 4;
				var exval = val_stack.elems[frame.fp + frame.func.decl.num_locals + ex_slot];
				throw(Exception.!(Value.Ref.!(exval).val));
			}
			THROW_REF => {
				var exval = popr();
				throw(Exception.!(exval.val));
			}
			END => {
				if (codeptr.available() == 0) doReturn();
			}
			BR => {
				codeptr.at(doGoto(pc));
			}
			BR_IF => {
				var cond = popi();
				doBranch(pc, cond != 0);
			}
			BR_TABLE => {
				var key = popu();
				codeptr.at(doSwitch(pc, key));
			}
			RETURN => {
				doReturn();
			}
			CALL => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				doCallFunction(f);
			}
			CALL_INDIRECT => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popu();
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) doCallFunction(f);
			}
			RETURN_CALL => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				prepareReturnCall(f.sig);
				doCallFunction(f);
			}
			RETURN_CALL_INDIRECT => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popu();
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) {
					prepareReturnCall(f.sig);
					doCallFunction(f);
				}
			}
			CALL_REF => {
				var sig_index = codeptr.read_uleb32();
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) trap(TrapReason.NULL_DEREF);
				else doCallFunction(func);
			}
			RETURN_CALL_REF => {
				var sig_index = codeptr.read_uleb32();
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) {
					trap(TrapReason.NULL_DEREF);
				} else {
					prepareReturnCall(func.sig);
					doCallFunction(func);
				}
			}
			DROP => {
				pop();
			}
			SELECT => {
				var cond = popu(), b = pop(), a = pop();
				push(if(cond != 0, a, b));
			}
			SELECT_T => {
				var count = codeptr.skip_value_types();
				var cond = popu();
				if (cond != 0) {
					val_stack.top -= count; // pop false values off the stack
				} else {
					copyVals(count, val_stack.top - (count << 1)); // transfer false values down
				}
			}
			TRY_TABLE => {
				codeptr.skip_block_type();
				var count = codeptr.read_uleb31();
				for (i < count) codeptr.skip_catch();
				frame.stp += count * Sidetables.ex_entry_size;
			}
			LOCAL_GET => {
				var index = codeptr.read_uleb32();
				push(val_stack.elems[frame.fp + int.!(index)]);
			}
			LOCAL_SET => {
				var index = codeptr.read_uleb32();
				val_stack.elems[frame.fp + int.!(index)] = pop();
			}
			LOCAL_TEE => {
				var index = codeptr.read_uleb32();
				val_stack.elems[frame.fp + int.!(index)] = val_stack.peek();
			}
			GLOBAL_GET => {
				var index = codeptr.read_uleb32();
				push(frame.func.instance.globals[index].value);
			}
			GLOBAL_SET => {
				var index = codeptr.read_uleb32();
				frame.func.instance.globals[index].value = pop();
			}
			TABLE_GET => {
				var index = codeptr.read_uleb32();
				var elems = frame.func.instance.tables[index].elems;
				var elem = popu();
				if (elem >= elems.length) {
					trap(TrapReason.TABLE_OUT_OF_BOUNDS);
				} else {
					push(elems[elem]);
				}
			}
			TABLE_SET => {
				var index = codeptr.read_uleb32();
				var table = frame.func.instance.tables[index];
				var val = pop();
				var elem = popu();
				if (elem >= table.elems.length) {
					trap(TrapReason.TABLE_OUT_OF_BOUNDS);
				} else {
					table[int.!(elem)] = val;
				}
			}

			I32_LOAD 	=> doLoad(4, DataReaders.read_range_u32, Value.I32);
			I64_LOAD 	=> doLoad(8, DataReaders.read_range_u64, Value.I64);
			F32_LOAD 	=> doLoad(4, DataReaders.read_range_u32, Value.F32);
			F64_LOAD 	=> doLoad(8, DataReaders.read_range_u64, Value.F64);
			I32_LOAD8_S	=> doLoad(1, DataReaders.read_range_u32_i8, Value.I32);
			I32_LOAD8_U	=> doLoad(1, DataReaders.read_range_u32_u8, Value.I32);
			I32_LOAD16_S	=> doLoad(2, DataReaders.read_range_u32_i16, Value.I32);
			I32_LOAD16_U	=> doLoad(2, DataReaders.read_range_u32_u16, Value.I32);
			I64_LOAD8_S	=> doLoad(1, DataReaders.read_range_u64_i8, Value.I64);
			I64_LOAD8_U	=> doLoad(1, DataReaders.read_range_u64_u8, Value.I64);
			I64_LOAD16_S	=> doLoad(2, DataReaders.read_range_u64_i16, Value.I64);
			I64_LOAD16_U	=> doLoad(2, DataReaders.read_range_u64_u16, Value.I64);
			I64_LOAD32_S	=> doLoad(4, DataReaders.read_range_u64_i32, Value.I64);
			I64_LOAD32_U	=> doLoad(4, DataReaders.read_range_u64_u32, Value.I64);
			I32_STORE	=> doStore(4, DataWriters.write_range_u32, Values.v_u);
			I64_STORE	=> doStore(8, DataWriters.write_range_u64, Values.v_w);
			F32_STORE	=> doStore(4, DataWriters.write_range_u32, Values.v_f);
			F64_STORE	=> doStore(8, DataWriters.write_range_u64, Values.v_d);
			I32_STORE8	=> doStore(1, DataWriters.write_range_u8, Values.v_u_8);
			I32_STORE16	=> doStore(2, DataWriters.write_range_u16, Values.v_u_16);
			I64_STORE8	=> doStore(1, DataWriters.write_range_u8, Values.v_w_8);
			I64_STORE16	=> doStore(2, DataWriters.write_range_u16, Values.v_w_16);
			I64_STORE32	=> doStore(4, DataWriters.write_range_u32, Values.v_w_32);

			MEMORY_SIZE => {
				var index = codeptr.read_uleb32();
				var memory = frame.func.instance.memories[index];
				pushm(memory, memory.size());
			}
			MEMORY_GROW => {
				var index = codeptr.read_uleb32();
				var memory = frame.func.instance.memories[index];
				var pages = popm(memory);
				var result = if(u32.?(pages), memory.grow(u32.!(pages)), -1); // TODO: memory64
				pushm(memory, u64.view(result));
			}

			I32_CONST => pushi(codeptr.read_sleb32());
			I64_CONST => pushl(codeptr.read_sleb64());
			F32_CONST => push(Value.F32(codeptr.read_u32()));
			F64_CONST => push(Value.F64(codeptr.read_u64()));

			I32_EQZ => pushz(popu() == 0);
			I32_EQ => do_uu_z(V3Eval.I32_EQ);
			I32_NE => do_uu_z(V3Eval.I32_NE);
			I32_LT_S => do_ii_z(V3Eval.I32_LT_S);
			I32_LT_U => do_uu_z(V3Eval.I32_LT_U);
			I32_GT_S => do_ii_z(V3Eval.I32_GT_S);
			I32_GT_U => do_uu_z(V3Eval.I32_GT_U);
			I32_LE_S => do_ii_z(V3Eval.I32_LE_S);
			I32_LE_U => do_uu_z(V3Eval.I32_LE_U);
			I32_GE_S => do_ii_z(V3Eval.I32_GE_S);
			I32_GE_U => do_uu_z(V3Eval.I32_GE_U);

			I64_EQZ => pushz(popw() == 0);
			I64_EQ => do_ww_z(V3Eval.I64_EQ);
			I64_NE => do_ww_z(V3Eval.I64_NE);
			I64_LT_S => do_ll_z(V3Eval.I64_LT_S);
			I64_LT_U => do_ww_z(V3Eval.I64_LT_U);
			I64_GT_S => do_ll_z(V3Eval.I64_GT_S);
			I64_GT_U => do_ww_z(V3Eval.I64_GT_U);
			I64_LE_S => do_ll_z(V3Eval.I64_LE_S);
			I64_LE_U => do_ww_z(V3Eval.I64_LE_U);
			I64_GE_S => do_ll_z(V3Eval.I64_GE_S);
			I64_GE_U => do_ww_z(V3Eval.I64_GE_U);

			F32_EQ => do_ff_z(V3Eval.F32_EQ);
			F32_NE => do_ff_z(V3Eval.F32_NE);
			F32_LT => do_ff_z(V3Eval.F32_LT);
			F32_GT => do_ff_z(V3Eval.F32_GT);
			F32_LE => do_ff_z(V3Eval.F32_LE);
			F32_GE => do_ff_z(V3Eval.F32_GE);
			F64_EQ => do_dd_z(V3Eval.F64_EQ);
			F64_NE => do_dd_z(V3Eval.F64_NE);
			F64_LT => do_dd_z(V3Eval.F64_LT);
			F64_GT => do_dd_z(V3Eval.F64_GT);
			F64_LE => do_dd_z(V3Eval.F64_LE);
			F64_GE => do_dd_z(V3Eval.F64_GE);

			I32_CLZ => do_u_u(V3Eval.I32_CLZ);
			I32_CTZ => do_u_u(V3Eval.I32_CTZ);
			I32_POPCNT => do_u_u(V3Eval.I32_POPCNT);
			I32_ADD => do_uu_u(V3Eval.I32_ADD);
			I32_SUB => do_uu_u(V3Eval.I32_SUB);
			I32_MUL => do_uu_u(V3Eval.I32_MUL);
			I32_DIV_S => do_ii_it(V3Eval.I32_DIV_S);
			I32_DIV_U => do_uu_ut(V3Eval.I32_DIV_U);
			I32_REM_S => do_ii_it(V3Eval.I32_REM_S);
			I32_REM_U => do_uu_ut(V3Eval.I32_REM_U);
			I32_AND => do_uu_u(V3Eval.I32_AND);
			I32_OR => do_uu_u(V3Eval.I32_OR);
			I32_XOR => do_uu_u(V3Eval.I32_XOR);
			I32_SHL => do_ii_i(V3Eval.I32_SHL);
			I32_SHR_S => do_ii_i(V3Eval.I32_SHR_S);
			I32_SHR_U => do_ii_i(V3Eval.I32_SHR_U);
			I32_ROTL => do_uu_u(V3Eval.I32_ROTL);
			I32_ROTR => do_uu_u(V3Eval.I32_ROTR);

			I64_CLZ => do_w_w(V3Eval.I64_CLZ);
			I64_CTZ => do_w_w(V3Eval.I64_CTZ);
			I64_POPCNT => do_w_w(V3Eval.I64_POPCNT);

			I64_ADD => do_ww_w(V3Eval.I64_ADD);
			I64_SUB => do_ww_w(V3Eval.I64_SUB);
			I64_MUL => do_ww_w(V3Eval.I64_MUL);
			I64_DIV_S => do_ll_lt(V3Eval.I64_DIV_S);
			I64_DIV_U => do_ww_wt(V3Eval.I64_DIV_U);
			I64_REM_S => do_ll_lt(V3Eval.I64_REM_S);
			I64_REM_U => do_ww_wt(V3Eval.I64_REM_U);
			I64_AND => do_ww_w(V3Eval.I64_AND);
			I64_OR => do_ww_w(V3Eval.I64_OR);
			I64_XOR => do_ww_w(V3Eval.I64_XOR);
			I64_SHL => do_ww_w(V3Eval.I64_SHL);
			I64_SHR_S => do_ll_l(V3Eval.I64_SHR_S);
			I64_SHR_U => do_ww_w(V3Eval.I64_SHR_U);
			I64_ROTL => do_ww_w(V3Eval.I64_ROTL);
			I64_ROTR => do_ww_w(V3Eval.I64_ROTR);

			F32_ABS => do_f_f(V3Eval.F32_ABS);
			F32_NEG => do_f_f(V3Eval.F32_NEG);
			F32_CEIL => do_f_f(V3Eval.F32_CEIL);
			F32_FLOOR => do_f_f(V3Eval.F32_FLOOR);
			F32_TRUNC => do_f_f(V3Eval.F32_TRUNC);
			F32_NEAREST => do_f_f(V3Eval.F32_NEAREST);
			F32_SQRT => do_f_f(V3Eval.F32_SQRT);
			F32_ADD => do_ff_f(V3Eval.F32_ADD);
			F32_SUB => do_ff_f(V3Eval.F32_SUB);
			F32_MUL => do_ff_f(V3Eval.F32_MUL);
			F32_DIV => do_ff_f(V3Eval.F32_DIV);
			F32_MIN => do_ff_f(V3Eval.F32_MIN);
			F32_MAX => do_ff_f(V3Eval.F32_MAX);
			F32_COPYSIGN => do_ff_f(V3Eval.F32_COPYSIGN);

			F64_ABS => do_d_d(V3Eval.F64_ABS);
			F64_NEG => do_d_d(V3Eval.F64_NEG);
			F64_CEIL => do_d_d(V3Eval.F64_CEIL);
			F64_FLOOR => do_d_d(V3Eval.F64_FLOOR);
			F64_TRUNC => do_d_d(V3Eval.F64_TRUNC);
			F64_NEAREST => do_d_d(V3Eval.F64_NEAREST);
			F64_SQRT => do_d_d(V3Eval.F64_SQRT);
			F64_ADD => do_dd_d(V3Eval.F64_ADD);
			F64_SUB => do_dd_d(V3Eval.F64_SUB);
			F64_MUL => do_dd_d(V3Eval.F64_MUL);
			F64_DIV => do_dd_d(V3Eval.F64_DIV);
			F64_MIN => do_dd_d(V3Eval.F64_MIN);
			F64_MAX => do_dd_d(V3Eval.F64_MAX);
			F64_COPYSIGN => do_dd_d(V3Eval.F64_COPYSIGN);

			I32_WRAP_I64 => pushu(V3Eval.I32_WRAP_I64(popw()));

			I32_TRUNC_F32_S => trap_or(V3Eval.I32_TRUNC_F32_S(popf()), pushi);
			I32_TRUNC_F32_U => trap_or(V3Eval.I32_TRUNC_F32_U(popf()), pushu);
			I32_TRUNC_F64_S => trap_or(V3Eval.I32_TRUNC_F64_S(popd()), pushi);
			I32_TRUNC_F64_U => trap_or(V3Eval.I32_TRUNC_F64_U(popd()), pushu);

			I64_EXTEND_I32_S => pushl(V3Eval.I64_EXTEND_I32_S(popi()));
			I64_EXTEND_I32_U => pushw(V3Eval.I64_EXTEND_I32_U(popu()));

			I64_TRUNC_F32_S => trap_or(V3Eval.I64_TRUNC_F32_S(popf()), pushl);
			I64_TRUNC_F32_U => trap_or(V3Eval.I64_TRUNC_F32_U(popf()), pushw);
			I64_TRUNC_F64_S => trap_or(V3Eval.I64_TRUNC_F64_S(popd()), pushl);
			I64_TRUNC_F64_U => trap_or(V3Eval.I64_TRUNC_F64_U(popd()), pushw);

			F32_CONVERT_I32_S => pushf(V3Eval.F32_CONVERT_I32_S(popi()));
			F32_CONVERT_I32_U => pushf(V3Eval.F32_CONVERT_I32_U(popu()));
			F32_CONVERT_I64_S => pushf(V3Eval.F32_CONVERT_I64_S(popl()));
			F32_CONVERT_I64_U => pushf(V3Eval.F32_CONVERT_I64_U(popw()));
			F32_DEMOTE_F64 => pushf(V3Eval.F32_DEMOTE_F64(popd()));
			F64_CONVERT_I32_S => pushd(V3Eval.F64_CONVERT_I32_S(popi()));
			F64_CONVERT_I32_U => pushd(V3Eval.F64_CONVERT_I32_U(popu()));
			F64_CONVERT_I64_S => pushd(V3Eval.F64_CONVERT_I64_S(popl()));
			F64_CONVERT_I64_U => pushd(V3Eval.F64_CONVERT_I64_U(popw()));
			F64_PROMOTE_F32 => pushd(V3Eval.F64_PROMOTE_F32(popf()));

			I32_REINTERPRET_F32 => pushu(V3Eval.I32_REINTERPRET_F32(popf()));
			F32_REINTERPRET_I32 => pushf(V3Eval.F32_REINTERPRET_I32(popu()));
			I64_REINTERPRET_F64 => pushw(V3Eval.I64_REINTERPRET_F64(popd()));
			F64_REINTERPRET_I64 => pushd(V3Eval.F64_REINTERPRET_I64(popw()));

			I32_EXTEND8_S => pushi(V3Eval.I32_EXTEND8_S(popi()));
			I32_EXTEND16_S => pushi(V3Eval.I32_EXTEND16_S(popi()));
			I64_EXTEND8_S => pushl(V3Eval.I64_EXTEND8_S(popl()));
			I64_EXTEND16_S => pushl(V3Eval.I64_EXTEND16_S(popl()));
			I64_EXTEND32_S => pushl(V3Eval.I64_EXTEND32_S(popl()));

			REF_NULL => {
				var index = codeptr.read_sleb32();
				push(Values.REF_NULL);
			}
			REF_IS_NULL => {
				var v = pop();
				var r = Values.isNull(v);
				pushz(r);
			}
			REF_FUNC => {
				var index = codeptr.read_uleb32();
				var func = frame.func.instance.functions[index];
				push(Value.Ref(func));
			}
			REF_AS_NON_NULL => {
				var v = pop();
				if (Values.isNull(v)) trap(TrapReason.NULL_DEREF);
				else push(v);
			}
			BR_ON_NULL => {
				var v = pop();
				if (Values.isNull(v)) { // XXX: use doBranch
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					push(v);
					doFallthru();
				}
			}
			REF_EQ => {
				var a = pop();
				var b = pop();
				pushz(a == b);
			}
			BR_ON_NON_NULL => {
				var v = pop();
				if (!Values.isNull(v)) {
					push(v);
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					doFallthru();
				}
			}
			STRUCT_NEW => {
				var index = codeptr.read_uleb32();
				var rtt = StructDecl.!(frame.func.instance.heaptypes[index]);
				var fields = popN(rtt.field_types.length);
				push(Value.Ref(HeapStruct.new(rtt, fields)));
			}
			STRUCT_NEW_DEFAULT => {
				var index = codeptr.read_uleb32();
				var rtt = StructDecl.!(frame.func.instance.heaptypes[index]);
				var fieldTypes = rtt.field_types;
				var fields = Array<Value>.new(fieldTypes.length);
				for (i < fields.length) fields[i] = Values.default(fieldTypes[i].valtype);
				push(Value.Ref(HeapStruct.new(rtt, fields)));
			}
			STRUCT_GET => {
				var index = codeptr.read_uleb32();
				var findex = codeptr.read_uleb32();
				var obj = HeapStruct.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else push(obj.vals[findex]);
			}
			STRUCT_GET_S => {
				var index = codeptr.read_uleb32();
				var decl = StructDecl.!(frame.func.instance.heaptypes[int.view(index)]);
				var findex = codeptr.read_uleb32();
				var obj = HeapStruct.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else push(V3Eval.signExtend(decl.field_types[findex], obj.vals[findex]));
			}
			STRUCT_GET_U => {
				var index = codeptr.read_uleb32();
				var decl = StructDecl.!(frame.func.instance.heaptypes[int.view(index)]);
				var findex = codeptr.read_uleb32();
				var obj = HeapStruct.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else push(V3Eval.zeroExtend(decl.field_types[findex], obj.vals[findex]));
			}
			STRUCT_SET => {
				var index = codeptr.read_uleb32();
				var findex = codeptr.read_uleb32();
				var val = pop();
				var obj = HeapStruct.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else obj.vals[findex] = val; // TODO: narrow on store?
			}
			ARRAY_NEW => {
				var index = codeptr.read_uleb32();
				var rtt = ArrayDecl.!(frame.func.instance.heaptypes[index]);
				var len = popu();
				var elem = pop();
				if (len > Execute.limits.max_array_length) {
					trap(TrapReason.OOM);
				} else {
					var length = int.view(len);
					var vals = Array<Value>.new(length);
					for (i < vals.length) vals[i] = elem;
					push(Value.Ref(HeapArray.new(rtt, vals)));
				}
			}
			ARRAY_NEW_DEFAULT => {
				var index = codeptr.read_uleb32();
				var rtt = ArrayDecl.!(frame.func.instance.heaptypes[index]);
				var len = popu();
				if (len > Execute.limits.max_array_length) {
					trap(TrapReason.OOM);
				} else {
					var length = int.view(len);
					var elem = Values.default(rtt.elem_types[0].valtype);
					var vals = Array<Value>.new(length);
					for (i < vals.length) vals[i] = elem;
					push(Value.Ref(HeapArray.new(rtt, vals)));
				}
			}
			ARRAY_GET => {
				var ignore = codeptr.read_uleb32();
				var index = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
				else push(obj.vals[index]);
			}
			ARRAY_GET_S => {
				var index = codeptr.read_uleb32();
				var array = ArrayDecl.!(frame.func.instance.heaptypes[int.view(index)]);
				index = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
				else push(V3Eval.signExtend(array.elem_types[0], obj.vals[index]));
			}
			ARRAY_GET_U => {
				var index = codeptr.read_uleb32();
				var array = ArrayDecl.!(frame.func.instance.heaptypes[int.view(index)]);
				index = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
				else push(V3Eval.zeroExtend(array.elem_types[0], obj.vals[index]));
			}
			ARRAY_SET => {
				var ignore = codeptr.read_uleb32();
				var val = pop();
				var index = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
				else obj.vals[index] = val;
			}
			ARRAY_LEN => {
				var obj = HeapArray.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else push(Value.I32(u32.view(obj.vals.length)));
			}
			ARRAY_FILL => {
				var typ = codeptr.skip_leb();
				var size = popu();
				var val = pop();
				var offset = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) return trap(TrapReason.NULL_DEREF);
				var index = ArrayUtil.boundsCheck(obj.vals, offset, 0, size);
				if (index < 0) return trap(TrapReason.ARRAY_INDEX_OOB);
				var r = obj.vals[index ..+ size];
				for (i < r.length) r[i] = val;
			}
			ARRAY_COPY => {
				var t1 = codeptr.skip_leb();
				var t2 = codeptr.skip_leb();
				var size = popu();
				var src_offset = popu();
				var src = HeapArray.!(popr().val);
				if (src == null) return trap(TrapReason.NULL_DEREF);
				var dst_offset = popu();
				var dst = HeapArray.!(popr().val);
				if (dst == null) return trap(TrapReason.NULL_DEREF);
				var r = ArrayUtil.safeCopy(dst.vals, dst_offset, src.vals, src_offset, size);
				if (!r) trap(TrapReason.ARRAY_INDEX_OOB);
			}
			ARRAY_INIT_DATA => {
				var index = codeptr.read_uleb32();
				var dindex = codeptr.read_uleb32();
				var i = frame.func.instance;
				var rtt = ArrayDecl.!(i.heaptypes[index]);
				var size = popu();
				var src_offset = popu();
				var dst_offset = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) return trap(TrapReason.NULL_DEREF);
				if (i.dropped_data[dindex]) return if(size > 0, trap(TrapReason.DATA_SEGMENT_DROPPED));
				var data = i.module.data[int.!(dindex)].data;
				if (ArrayUtil.boundsCheck(obj.vals, dst_offset, 0, size) < 0) return trap(TrapReason.ARRAY_INDEX_OOB);
				var t = Execute.bytesToVals(rtt.elem_types[0], data, src_offset, size);
				if (!t.0) return trap(TrapReason.MEM_OUT_OF_BOUNDS);
				ArrayUtil.safeCopy(obj.vals, dst_offset, t.1, 0, size);
			}
			ARRAY_INIT_ELEM => {
				var index = codeptr.read_uleb32();
				var eindex = codeptr.read_uleb32();
				var i = frame.func.instance;
				var rtt = ArrayDecl.!(i.heaptypes[index]);
				var size = popu();
				var src_offset = popu();
				var dst_offset = popu();
				var obj = HeapArray.!(popr().val);
				if (obj == null) return trap(TrapReason.NULL_DEREF);
				if (i.dropped_elems[eindex]) return if(size > 0, trap(TrapReason.ELEM_SEGMENT_DROPPED));
				var edecl = i.module.elems[int.!(eindex)];
				var r = Execute.copyElemsInto(obj.vals, frame.func.instance, dst_offset, edecl, src_offset, size);
				if (!r) return trap(TrapReason.ARRAY_INDEX_OOB);
			}
			ARRAY_NEW_FIXED => {
				var index = codeptr.read_uleb32();
				var len = codeptr.read_uleb32();
				var rtt = ArrayDecl.!(frame.func.instance.heaptypes[index]);
				if (len > Execute.limits.max_array_length) {
					trap(TrapReason.OOM);
				} else {
					var length = int.view(len);
					var vals = Array<Value>.new(length);
					for (i = vals.length - 1; i >= 0; i--) vals[i] = pop();
					push(Value.Ref(HeapArray.new(rtt, vals)));
				}
			}
			ARRAY_NEW_DATA => {
				var index = codeptr.read_uleb32();
				var dindex = codeptr.read_uleb32();
				var i = frame.func.instance;
				if (!i.dropped_data[dindex]) {
					var rtt = ArrayDecl.!(i.heaptypes[index]);
					var len = popu();
					var offset = popu();
					var ddecl = i.module.data[int.!(dindex)];
					if (len <= Execute.limits.max_array_length) {
						var t = Execute.bytesToVals(rtt.elem_types[0], ddecl.data, offset, len);
						if (t.0) push(Value.Ref(HeapArray.new(rtt, t.1)));
						else trap(TrapReason.MEM_OUT_OF_BOUNDS);
					} else {
						trap(TrapReason.OOM);
					}
				} else {
					trap(TrapReason.MEM_OUT_OF_BOUNDS);
				}
			}
			ARRAY_NEW_ELEM => {
				var index = codeptr.read_uleb32();
				var eindex = codeptr.read_uleb32();
				var i = frame.func.instance;
				if (!i.dropped_elems[eindex]) {
					var rtt = ArrayDecl.!(i.heaptypes[index]);
					var len = popu();
					var offset = popu();
					var edecl = i.module.elems[int.!(eindex)];
					if (len <= Execute.limits.max_array_length) {
						var vals = Array<Value>.new(int.!(len));
						var r = Execute.copyElemsInto(vals, i, 0, edecl, offset, len);
						if (r) push(Value.Ref(HeapArray.new(rtt, vals)));
						else trap(TrapReason.TABLE_OUT_OF_BOUNDS); // TODO: elem out of bounds
					} else {
						trap(TrapReason.OOM);
					}
					} else {
					trap(TrapReason.MEM_OUT_OF_BOUNDS);
				}
			}
			I31_NEW => {
				push(Value.I31(u31.view(popu())));
			}
			I31_GET_S => {
				var v = pop();
				if (v == Values.REF_NULL) trap(TrapReason.NULL_DEREF);
				else pushi(i31.view(Value.I31.!(v).val));
			}
			I31_GET_U => {
				var v = pop();
				if (v == Values.REF_NULL) trap(TrapReason.NULL_DEREF);
				else pushu(Value.I31.!(v).val);
			}
			REF_TEST,
			REF_TEST_NULL => {
				var nullable = (opcode == Opcode.REF_TEST_NULL);
				var htcode = codeptr.read_sleb32();
				var result = Execute.doCast(frame.func.instance, nullable, htcode, pop());
				pushz(result);
			}
			REF_CAST,
			REF_CAST_NULL => {
				var nullable = (opcode == Opcode.REF_CAST_NULL);
				var htcode = codeptr.read_sleb32();
				var val = pop();
				var result = Execute.doCast(frame.func.instance, nullable, htcode, val);
				if (!result) trap(TrapReason.FAILED_CAST);
				else push(val);
			}
			BR_ON_CAST => {
				var imm = codeptr.read_BrOnCastImm();
				var val = pop();
				var result = Execute.doCast(frame.func.instance, imm.null2(), imm.ht2, val);
				push(val);
				if (result) codeptr.at(doGoto(pc));
				else doFallthru();
			}
			BR_ON_CAST_FAIL => {
				var imm = codeptr.read_BrOnCastImm();
				var val = pop();
				var result = Execute.doCast(frame.func.instance, imm.null2(), imm.ht2, val);
				push(val);
				if (!result) codeptr.at(doGoto(pc));
				else doFallthru();
			}
			EXTERN_INTERNALIZE, EXTERN_EXTERNALIZE => {
				// nop
			}
			I32_TRUNC_SAT_F32_S => pushi(i32.truncf(popf()));
			I32_TRUNC_SAT_F32_U => pushu(u32.truncf(popf()));
			I32_TRUNC_SAT_F64_S => pushi(i32.truncd(popd()));
			I32_TRUNC_SAT_F64_U => pushu(u32.truncd(popd()));
			I64_TRUNC_SAT_F32_S => pushl(i64.truncf(popf()));
			I64_TRUNC_SAT_F32_U => pushw(u64.truncf(popf()));
			I64_TRUNC_SAT_F64_S => pushl(i64.truncd(popd()));
			I64_TRUNC_SAT_F64_U => pushw(u64.truncd(popd()));
			MEMORY_INIT => {
				var i = frame.func.instance;
				var dindex = codeptr.read_uleb32();
				var ddecl = if(!i.dropped_data[dindex], i.module.data[int.!(dindex)]);
				var mem = i.memories[codeptr.read_uleb32()];
				var size = popu();
				var src_offset = popu();
				var dst_offset = popu();
				var t = mem.copyIn(dst_offset, if(ddecl != null, ddecl.data), src_offset, size);
				if (t != TrapReason.NONE) trap(t);
			}
			DATA_DROP => {
				var dindex = codeptr.read_uleb32();
				frame.func.instance.dropped_data[dindex] = true;
			}
			MEMORY_COPY => {
				var i = frame.func.instance;
				var dst = i.memories[codeptr.read_uleb32()];
				var src = i.memories[codeptr.read_uleb32()];
				var size = popu(), src_offset = popu(), dst_offset = popu();
				var t = dst.copyM(dst_offset, src, src_offset, size);
				if (t != TrapReason.NONE) trap(t);
			}
			MEMORY_FILL => {
				var i = frame.func.instance;
				var mem = i.memories[codeptr.read_uleb32()];
				var size = popu();
				var val = popu();
				var dest = popu();
				var t = mem.fill(dest, u8.view(val), size);
				if (t != TrapReason.NONE) trap(t);
			}
			TABLE_INIT => {
				var i = frame.func.instance;
				var eindex = codeptr.read_uleb32(); // XXX: use read_uleb31
				var elem = if (!i.dropped_elems[eindex], i.module.elems[int.!(eindex)]);
				var table = i.tables[codeptr.read_uleb32()];
				var size = popu();
				var src_offset = popu();
				var dst_offset = popu();
				var t = table.copyE(i, dst_offset, elem, src_offset, size);
				if (t != TrapReason.NONE) trap(t);
			}
			ELEM_DROP => {
				var index = codeptr.read_uleb32();
				frame.func.instance.dropped_elems[index] = true;
			}
			TABLE_COPY => {
				var i = frame.func.instance;
				var dst = i.tables[codeptr.read_uleb32()];
				var src = i.tables[codeptr.read_uleb32()];
				var size = popu(), src_offset = popu(), dst_offset = popu();
				var t = dst.copyT(dst_offset, src, src_offset, size);
				if (t != TrapReason.NONE) trap(t);
			}
			TABLE_GROW => {
				var i = frame.func.instance;
				var table = i.tables[codeptr.read_uleb32()];
				var size = popu();
				var val = pop();
				var r = table.grow(size, val);
				pushi(r);
			}
			TABLE_SIZE => {
				var i = frame.func.instance;
				var table = i.tables[codeptr.read_uleb32()];
				pushi(table.elems.length);
			}
			TABLE_FILL => {
				var i = frame.func.instance;
				var table = i.tables[codeptr.read_uleb32()];
				var size = popu();
				var val = pop();
				var dest = popu();
				var t = table.fill(dest, val, size);
				if (t != TrapReason.NONE) trap(t);
			}
			V128_LOAD => doLoad(16, DataReaders.read_range_u128, Value.V128);
			V128_STORE => doStore(16, DataWriters.write_range_u128, Values.v_v128);
			V128_CONST => {
				var low = codeptr.read_u64();
				var high = codeptr.read_u64();
				push(Value.V128(low, high));
			}
			V128_NOT => do_v_v(V3Eval.V128_NOT);
			V128_AND => do_vv_v(V3Eval.V128_AND);
			V128_OR => do_vv_v(V3Eval.V128_OR);
			V128_XOR => do_vv_v(V3Eval.V128_XOR);
			V128_BITSELECT => do_vvv_v(V3Eval.V128_BITSELECT);
			V128_ANDNOT => do_vv_v(V3Eval.V128_ANDNOT);
			I64X2_ADD => do_vv_v(V3Eval.I64X2_ADD);
			I64X2_SUB => do_vv_v(V3Eval.I64X2_SUB);
			I64X2_MUL => do_vv_v(V3Eval.I64X2_MUL);
			I64X2_NEG => do_v_v(V3Eval.I64X2_NEG);
			I32X4_ADD => do_vv_v(V3Eval.I32X4_ADD);
			I32X4_SUB => do_vv_v(V3Eval.I32X4_SUB);
			I32X4_MUL => do_vv_v(V3Eval.I32X4_MUL);
			I32X4_NEG => do_v_v(V3Eval.I32X4_NEG);
			I16X8_ADD => do_vv_v(V3Eval.I16X8_ADD);
			I16X8_SUB => do_vv_v(V3Eval.I16X8_SUB);
			I16X8_MUL => do_vv_v(V3Eval.I16X8_MUL);
			I16X8_NEG => do_v_v(V3Eval.I16X8_NEG);
			I8X16_ADD => do_vv_v(V3Eval.I8X16_ADD);
			I8X16_SUB => do_vv_v(V3Eval.I8X16_SUB);
			I8X16_NEG => do_v_v(V3Eval.I8X16_NEG);
			I8X16_MIN_S => do_vv_v(V3Eval.I8X16_MIN_S);
			I8X16_MIN_U => do_vv_v(V3Eval.I8X16_MIN_U);
			I8X16_MAX_S => do_vv_v(V3Eval.I8X16_MAX_S);
			I8X16_MAX_U => do_vv_v(V3Eval.I8X16_MAX_U);
			I8X16_AVGR_U => do_vv_v(V3Eval.I8X16_AVGR_U);
			I8X16_ABS => do_v_v(V3Eval.I8X16_ABS);
			I8X16_POPCNT => do_v_v(V3Eval.I8X16_POPCNT);
			F32X4_ADD => do_vv_v(V3Eval.F32X4_ADD);
			F32X4_SUB => do_vv_v(V3Eval.F32X4_SUB);
			F32X4_MUL => do_vv_v(V3Eval.F32X4_MUL);
			F32X4_DIV => do_vv_v(V3Eval.F32X4_DIV);
			F32X4_NEG => do_v_v(V3Eval.F32X4_NEG);
			F32X4_SQRT => do_v_v(V3Eval.F32X4_SQRT);
			F64X2_ADD => do_vv_v(V3Eval.F64X2_ADD);
			F64X2_SUB => do_vv_v(V3Eval.F64X2_SUB);
			F64X2_MUL => do_vv_v(V3Eval.F64X2_MUL);
			F64X2_DIV => do_vv_v(V3Eval.F64X2_DIV);
			F64X2_SQRT => do_v_v(V3Eval.F64X2_SQRT);
			F64X2_NEG => do_v_v(V3Eval.F64X2_NEG);
			INVALID => trap(TrapReason.INVALID_OPCODE);
			CRASH_EXEC => System.error("WizengError", "crash-exec opcode executed");
			CRASH_COMPILER => System.error("WizengError", "crash-compiler opcode executed");
			_ => {
				trap(TrapReason.UNIMPLEMENTED);
			}
		}
		if (frame != null) frame.pc = codeptr.pos;
	}
	def doLoad<T>(size: byte, read: Range<byte> -> T, box: T -> Value) {
		var memarg = codeptr.read_MemArg();
		var memory = frame.func.instance.memories[memarg.memory_index];
		var index = popm(memory);
		if (!u32.?(index)) return trap(TrapReason.MEM_OUT_OF_BOUNDS);
		if (!u32.?(memarg.offset)) return trap(TrapReason.MEM_OUT_OF_BOUNDS);
		var t = memory.range_oil_32(u32.!(memarg.offset), u32.!(index), size);
		if (t.reason != TrapReason.NONE) trap(t.reason);
		else push(box(read(t.result)));
	}
	def doStore<T>(size: byte, write: (Range<byte>, T) -> void, unbox: Value -> T) {
		var memarg = codeptr.read_MemArg();
		var memory = frame.func.instance.memories[memarg.memory_index];
		var val = pop();
		var index = popm(memory);
		if (!u32.?(index)) return trap(TrapReason.MEM_OUT_OF_BOUNDS);
		if (!u32.?(memarg.offset)) return trap(TrapReason.MEM_OUT_OF_BOUNDS);
		var t = memory.range_oil_32(u32.!(memarg.offset), u32.!(index), size);
		if (t.reason != TrapReason.NONE) trap(t.reason);
		else write(t.result, unbox(val));
	}
	def doFallthru() {
		frame.stp += 4;
	}
	def doBranch(pc: int, cond: bool) -> bool {
		if (cond) {
			codeptr.at(doGoto(pc));
		} else {
			codeptr.skip_label();
			doFallthru();
		}
		return cond;
	}
	def doGoto(pc: int) -> int {
		var stp = frame.stp, sidetable = frame.func.decl.sidetable;
		return doCtlXfer(pc, stp, sidetable);
	}
	def doSwitch(pc: int, key: u32) -> int {
		var stp = frame.stp, sidetable = frame.func.decl.sidetable;
		var max = sidetable.entries[stp];
		var index = if(key >= max, max, 1 + int.!(key));
		stp += index << 2;
		pc += index;
		return doCtlXfer(pc, stp, sidetable);
	}
	def doCtlXfer(pc: int, stp: int, sidetable: Sidetable) -> int {
		var e = sidetable.getBrEntry(stp);
		frame.stp = stp + e.dstp;
		if (e.popcount > 0) {
			copyVals(e.valcount, val_stack.top - int.!(e.popcount + e.valcount));
		}
		return pc + e.dpc;
	}
	def advanceCaller() {
		var code = frame.func.decl.cur_bytecode;
		codeptr.reset(code, frame.pc, code.length);
		var opcode = codeptr.read_opcode_but_skip_probe(frame.func.decl);
		match (opcode) {
			CALL, CALL_REF => {
				codeptr.read_uleb32();
			}
			CALL_INDIRECT => {
				codeptr.read_uleb32();
				codeptr.read_uleb32();
			}
			_ => fail(Strings.format1("expected call instruction in return, got %s", opcode.name));
		}
		frame.pc = codeptr.pos;
	}
	def doReturn() {
		var count = frame.func.decl.sig.results.length;
		copyVals(count, frame.fp);
		frame.accessor = null;
		popFrame();

		if (frame == null) {  // popped top frame, finished execution
			codeptr.reset(null, 0, 0);
		} else if (frame.func != null) { // advance past caller's call instruction
			advanceCaller();
		}
	}
	def doCast(val: Value, nullable: bool) -> bool {
		var htcode = codeptr.read_sleb32();
		return Execute.doCast(frame.func.instance, nullable, htcode, val);
	}
	def prepareReturnCall(sig: SigDecl) {
		var fp = frame.fp, count = sig.params.length, sp = val_stack.top - count;
		copyVals(count, frame.fp);
		popFrame();
	}
	def lookupIndirect(sig_index: u32, table_index: u32, func_index: u32) -> Function {
		var instance = frame.func.instance;
		var table = instance.tables[table_index];
		if (func_index >= table.elems.length) {
			trap(TrapReason.FUNC_INVALID);
			return null;
		}
		var expected = SigDecl.!(instance.heaptypes[sig_index]);
		var f = table.funcs[func_index];
		if (f == null) { trap(TrapReason.FUNC_INVALID); return null; }
		Trace.OUT.put3("lookupIndirect %d, expected.uid = %d, f.uid = %d", sig_index, expected.canon_id, f.sig.canon_id).outln();
		if (!ValueTypes.isAssignableHeap(f.sig, expected)) { trap(TrapReason.FUNC_SIG_MISMATCH); return null; }
		return f;
	}
	def doInvokeHostFunction(hf: HostFunction) -> HostResult {
		if (Trace.interpreter) Execute.traceCallHostFunction(hf);
		var result: HostResult;
		var count: int, sp: int;
		var elems = val_stack.elems;

		var host_frame = getNextHostFrame();
		host_frame.hf = hf;

		match (hf) {
			hf0: HostFunction0 => {
				count = 0;
				sp = val_stack.top;
				result = hf0.invoke0();
			}
			hf1: HostFunction1 => {
				count = 1;
				sp = val_stack.top - count;
				val_stack.top = sp;
				result = hf1.invoke1(elems[sp]);
			}
			hf2: HostFunction2 => {
				count = 2;
				sp = val_stack.top - count;
				val_stack.top = sp;
				result = hf2.invoke2(elems[sp], elems[sp+1]);
			}
			hf3: HostFunction3 => {
				count = 3;
				sp = val_stack.top - count;
				val_stack.top = sp;
				result = hf3.invoke3(elems[sp], elems[sp+1], elems[sp+2]);
			}
			hfN: HostFunctionN => {
				count = hf.sig.params.length;
				sp = val_stack.top - count;
				val_stack.top = sp;
				var args = Array<Value>.new(count);
				for (i < count) args[i] = elems[sp + i];
				result = hfN.invokeN(args);
			}
		}
		popFrame();
		return result;
	}
	def doTruncF32<T>(min: float, max: float, trunc: float -> T, push: T -> ()) {
		var a = popf();
		if (a >= max) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (a <= min) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (!(a == a)) trap(TrapReason.FLOAT_UNREPRESENTABLE);
		push(trunc(a));
	}
	def doTruncF64<T>(min: double, max: double, trunc: double -> T, push: T -> ()) {
		var a = popd();
		if (a >= max) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (a <= min) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (!(a == a)) trap(TrapReason.FLOAT_UNREPRESENTABLE);
		push(trunc(a));
	}
	def throw(ex: Exception) {
//TODO		ex.prepend((prev_call_stack_top), null);
		for (f = frame; f != null && f.func != null; f = f.prev) {
			var handler = f.func.decl.findExHandler(f.func.instance, ex.tag, f.pc);
			if (handler.handler_pc >= 0) {
				frame = f;
				var code = f.func.decl.cur_bytecode;
				f.pc = handler.handler_pc;
				f.stp = handler.sidetable_pos;
				codeptr.reset(code, f.pc, code.length);
				// TODO: clean up frame math here
				val_stack.top = f.fp + handler.val_stack_top + f.func.decl.num_locals + f.func.decl.num_ex_slots;
				for (v in ex.vals) val_stack.push(v);
				if (Trace.exception) Trace.OUT.put2("  set_ex_slot fp=%d, ex_slot=%d", f.fp, handler.ex_slot).outln();
				val_stack.elems[f.fp + f.func.decl.num_locals + handler.ex_slot] = Value.Ref(ex);
				frame = f;
				return;
			}
		}
		thrown = ex; // unhandled exception
	}
	def trap(reason: TrapReason) {
		thrown = Trap.new(reason, null, null);
		thrown.prepend(popFrames(host_frame), null);
	}
	def fail(msg: string) {
		thrown = InternalError.new(msg, null);
		thrown.prepend(popFrames(host_frame), null);
	}
	def copyVals(count: int, dest: int) {
		var sp = val_stack.top - count;
		if (sp != dest) {
			var e = val_stack.elems;
			for (i < count) e[dest + i] = e[sp + i];
		}
		val_stack.top = dest + count;
	}
	def pop() -> Value { return val_stack.pop(); }
	def popi() -> i32 { return Values.v_i(val_stack.pop()); }
	def popu() -> u32 { return Values.v_u(val_stack.pop()); }
	def popl() -> i64 { return Values.v_l(val_stack.pop()); }
	def popw() -> u64 { return Values.v_w(val_stack.pop()); }
	def popf() -> float { return float.view(Values.v_f(val_stack.pop())); }
	def popd() -> double { return double.view(Values.v_d(val_stack.pop())); }
	def popr() -> Value.Ref { return Value.Ref.!(val_stack.pop()); } // TODO: i31
	def popm(memory: Memory) -> u64 {
		if (memory.decl.indexType == ValueType.I32) return popu();
		else return popw();
	}
	def push(val: Value) { val_stack.push(val); }
	def pushi(val: i32) { val_stack.push(Value.I32(u32.view(val))); }
	def pushu(val: u32) { val_stack.push(Value.I32(val)); }
	def pushl(val: i64) { val_stack.push(Value.I64(u64.view(val))); }
	def pushw(val: u64) { val_stack.push(Value.I64(val)); }
	def pushf(val: float) { val_stack.push(Value.F32(u32.view(val))); }
	def pushd(val: double) { val_stack.push(Value.F64(u64.view(val))); }
	def pushz(val: bool) { val_stack.push(if(val, Values.I32_1, Values.I32_0)); }
	def pushm(memory: Memory, val: u64) {
		if (memory.decl.indexType == ValueType.I32) pushu(u32.view(val));
		else pushw(val);
	}
	def trap_or<T>(r: (T, TrapReason), push: T -> ()) {
		if (r.1 != TrapReason.NONE) return trap(r.1);
		push(r.0);
	}
	def popN(count: int) -> Array<Value> {
		var result = Array<Value>.new(count);
		var sp = val_stack.top - count;
		for (i < count) result[i] = val_stack.elems[sp + i];
		val_stack.top = sp;
		return result;
	}
	def traceStep() {
		for (i < call_stack_size) OUT.sp();
		OUT.put1("+%d: ", codeptr.pos);  // XXX: fixed width decimal offset
		var module = if(frame.func.instance != null, frame.func.instance.module);
		var opcode = codeptr.data[codeptr.pos];
		if (instrTracer == null) instrTracer = InstrTracer.new();
		if (opcode == InternalOpcode.PROBE.code) {
			OUT.puts("<probe> ");
			var prev = (codeptr.data, codeptr.pos, codeptr.limit);
			codeptr.reset(frame.func.decl.orig_bytecode, prev.1, prev.2);
			instrTracer.putInstr(OUT, module, codeptr);
			codeptr.reset(prev.0, prev.1, prev.2);
		} else {
			instrTracer.putInstr(OUT, module, codeptr);
		}
		if (Trace.operands) {
			var locals_end = frame.fp + frame.func.decl.num_locals - 1;
			for (i = frame.fp; i < val_stack.top; i++) {
				var v = val_stack.elems[i];
				v.render(OUT.sp());
				if (i == locals_end) OUT.puts(" | ");
			}
		}
		OUT.outln();
	}
	// XXX: reduce duplication of d_xx_x methods
	def do_dd_d(f: (double, double) -> double) {
		var y = Values.v_d(val_stack.elems[val_stack.top-1]);
		var x = Values.v_d(val_stack.elems[val_stack.top-2]);
		var r = f(double.view(x), double.view(y));
		val_stack.elems[val_stack.top-2] = Value.F64(u64.view(r));
		val_stack.top--;
	}
	def do_ff_f(f: (float, float) -> float) {
		var y = Values.v_f(val_stack.elems[val_stack.top-1]);
		var x = Values.v_f(val_stack.elems[val_stack.top-2]);
		var r = f(float.view(x), float.view(y));
		val_stack.elems[val_stack.top-2] = Value.F32(u32.view(r));
		val_stack.top--;
	}
	def do_dd_z(f: (double, double) -> bool) {
		var y = Values.v_d(val_stack.elems[val_stack.top-1]);
		var x = Values.v_d(val_stack.elems[val_stack.top-2]);
		var r = f(double.view(x), double.view(y));
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ff_z(f: (float, float) -> bool) {
		var y = Values.v_f(val_stack.elems[val_stack.top-1]);
		var x = Values.v_f(val_stack.elems[val_stack.top-2]);
		var r = f(float.view(x), float.view(y));
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ii_i(f: (i32, i32) -> i32) {
		var y = Values.v_i(val_stack.elems[val_stack.top-1]);
		var x = Values.v_i(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I32(u32.view(r));
		val_stack.top--;
	}
	def do_uu_u(f: (u32, u32) -> u32) {
		var y = Values.v_u(val_stack.elems[val_stack.top-1]);
		var x = Values.v_u(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I32(r);
		val_stack.top--;
	}
	def do_uu_ut(f: (u32, u32) -> (u32, TrapReason)) {
		var y = Values.v_u(val_stack.elems[val_stack.top-1]);
		var x = Values.v_u(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return trap(r.1);
		val_stack.elems[val_stack.top-2] = Value.I32(r.0);
		val_stack.top--;
	}
	def do_ii_it(f: (i32, i32) -> (i32, TrapReason)) {
		var y = Values.v_u(val_stack.elems[val_stack.top-1]);
		var x = Values.v_u(val_stack.elems[val_stack.top-2]);
		var r = f(i32.view(x), i32.view(y));
		if (r.1 != TrapReason.NONE) return trap(r.1);
		val_stack.elems[val_stack.top-2] = Value.I32(u32.view(r.0));
		val_stack.top--;
	}
	def do_u_u(f: u32 -> u32) {
		var x = Values.v_u(val_stack.elems[val_stack.top-1]);
		var r = f(x);
		val_stack.elems[val_stack.top-1] = Value.I32(r);
	}
	def do_ii_z(f: (i32, i32) -> bool) {
		var y = Values.v_i(val_stack.elems[val_stack.top-1]);
		var x = Values.v_i(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_uu_z(f: (u32, u32) -> bool) {
		var y = Values.v_u(val_stack.elems[val_stack.top-1]);
		var x = Values.v_u(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ll_l(f: (i64, i64) -> i64) {
		var y = Values.v_l(val_stack.elems[val_stack.top-1]);
		var x = Values.v_l(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I64(u64.view(r));
		val_stack.top--;
	}
	def do_ll_lt(f: (i64, i64) -> (i64, TrapReason)) {
		var y = Values.v_l(val_stack.elems[val_stack.top-1]);
		var x = Values.v_l(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return trap(r.1);
		val_stack.elems[val_stack.top-2] = Value.I64(u64.view(r.0));
		val_stack.top--;
	}
	def do_ww_w(f: (u64, u64) -> u64) {
		var y = Values.v_w(val_stack.elems[val_stack.top-1]);
		var x = Values.v_w(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I64(r);
		val_stack.top--;
	}
	def do_ww_wt(f: (u64, u64) -> (u64, TrapReason)) {
		var y = Values.v_w(val_stack.elems[val_stack.top-1]);
		var x = Values.v_w(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return trap(r.1);
		val_stack.elems[val_stack.top-2] = Value.I64(r.0);
		val_stack.top--;
	}
	def do_w_w(f: u64 -> u64) {
		var x = Values.v_w(val_stack.elems[val_stack.top-1]);
		var r = f(x);
		val_stack.elems[val_stack.top-1] = Value.I64(r);
	}
	def do_ll_z(f: (i64, i64) -> bool) {
		var y = Values.v_l(val_stack.elems[val_stack.top-1]);
		var x = Values.v_l(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ww_z(f: (u64, u64) -> bool) {
		var y = Values.v_w(val_stack.elems[val_stack.top-1]);
		var x = Values.v_w(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_v_v(f: (u64, u64) -> (u64, u64)) {
		var x = Values.v_v128(val_stack.elems[val_stack.top-1]);
		var r = f(x);
		val_stack.elems[val_stack.top-1] = Value.V128(r.0, r.1);
	}
	def do_vv_v(f: ((u64, u64), (u64, u64)) -> (u64, u64)) {
		var y = Values.v_v128(val_stack.elems[val_stack.top-1]);
		var x = Values.v_v128(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.V128(r.0, r.1);
		val_stack.top--;
	}
	def do_vvv_v(f: ((u64, u64), (u64, u64), (u64, u64)) -> (u64, u64)) {
		var z = Values.v_v128(val_stack.elems[val_stack.top-1]);
		var y = Values.v_v128(val_stack.elems[val_stack.top-2]);
		var x = Values.v_v128(val_stack.elems[val_stack.top-3]);
		var r = f(x, y, z);
		val_stack.elems[val_stack.top-3] = Value.V128(r.0, r.1);
		val_stack.top -= 2;
	}
	def do_f_f(f: float -> float) {
		var x = Values.v_f(val_stack.elems[val_stack.top-1]);
		var r = f(float.view(x));
		val_stack.elems[val_stack.top-1] = Value.F32(u32.view(r));
	}
	def do_d_d(f: double -> double) {
		var x = Values.v_d(val_stack.elems[val_stack.top-1]);
		var r = f(double.view(x));
		val_stack.elems[val_stack.top-1] = Value.F64(u64.view(r));
	}

	// Get the next frame, or make a new one if necessary
	private def getNextFrame() -> V3Frame {
		if (frame == null) {
			frame = V3Frame.new();
		} else if (frame.next != null) { // reuse frame object
			frame = frame.next;
		} else {
			var new_frame = V3Frame.new();
			new_frame.prev = frame;
			frame.next = new_frame;
			frame = new_frame;
		}
		num_frames++;
		frame.index = num_frames;
		return frame;
	}
	// Get the next host frame, or make a new one if necessary
	private def getNextHostFrame() -> V3Frame {
		frame = getNextFrame();
		if (host_frame == null) {
			frame.prev_host = null;
			frame.next_host = null;
		} else {
			frame.prev_host = host_frame;
			host_frame.next_host = frame;
		}
		host_frame = frame;
		return host_frame;
	}
	private def popFrame() -> V3Frame {
		num_frames--;
		if (frame == host_frame) {
			host_frame = host_frame.prev_host;
		} else if (frame.func != null) {
			call_stack_size--;
		}
		frame.hf = frame.func = frame.accessor = null;
		frame = frame.prev;
		return frame;
	}
	private def popFrames(prev_top: V3Frame) -> Array<(WasmFunction, int)> {
		var top_index = if(frame == null, 0, frame.index);
		var prev_top_index = if(prev_top == null, 0, prev_top.index);
		var frames = Array<(WasmFunction, int)>.new(top_index - prev_top_index);
		while (frame != prev_top) {
			frames[frame.index - prev_top_index - 1] = (frame.func, frame.pc);
			popFrame();
		}
		return frames;
	}
}

class V3Frame {
	var hf: HostFunction;	// null if wasm function
	var func: WasmFunction;	// null if host function
	// both hf and wf null if frame is inactive

	var prev: V3Frame;
	var next: V3Frame;
	var prev_host: V3Frame;	// null if wasm function
	var next_host: V3Frame;	// null if wasm function

	var fp: int;
	var pc: int;
	var stp: int;
	var accessor: V3FrameAccessor;

	var index: int;

	def caller() -> WasmOrHostLoc {
		if (prev == null) {
			return WasmOrHostLoc.None;
		} else if (prev.func != null) {
			return WasmOrHostLoc.WasmLoc(prev.func, prev.pc, TargetFrame(prev));
		} else {
			return WasmOrHostLoc.HostLoc(prev.hf, V3HostFrame.new(prev));
		}
	}
}

class V3HostFrame(frame: V3Frame) extends HostFrame {
	def caller() -> WasmOrHostLoc {
		return frame.caller();
	}
}

class V3FrameAccessor(frame: V3Frame) extends FrameAccessor {
	var cached_caller: V3Frame;
	var cached_depth = -1;
	// Returns {true} if this frame has been unwound, either due to returning, a trap, or exception.
	def isUnwound() -> bool {
		return frame.accessor != this;
	}
	// Returns the Wasm function in this frame.
	def func() -> WasmFunction {
		checkNotUnwound();
		return frame.func;
	}
	// Returns the current program counter.
	def pc() -> int {
		checkNotUnwound();
		return frame.pc;
	}
	// Returns {true} if this frame is currently the top executing frame, {false} if the
	// frame has called another function or been unwound.
	private def isTop() -> bool {
		return if(!isUnwound(), V3Interpreter.frame == frame);
	}
	// Returns the call depth of this frame within its segment, with the bottom frame being #0.
	def depth() -> int {
		checkNotUnwound();
		if (cached_depth < 0) cached_depth = computeDepth();
		return cached_depth;
	}
	private def computeDepth() -> int {
		if (cached_caller != null) {
			var a = cached_caller.accessor;
			if (a != null && a.cached_depth >= 0) return a.cached_depth + 1;
		}
		var i = V3Interpreter.call_stack_size - 1;
		for (f = V3Interpreter.frame; f != null; f = f.prev) {
			if (f == frame) return i;
			// do a drive-by calculation of non-matching frame depth
			if (f.hf == null) {
				var a = f.accessor;
				if (a != null && a.cached_depth < 0) a.cached_depth = i;
				i--;
			}
		}
		return 0; // TODO: not found. error?
	}
	// Get the caller frame, either a wasm or host function. If none, then {Frame.func} will be {null}.
	def caller() -> WasmOrHostLoc {
		checkNotUnwound();
		return frame.caller();
	}
	// Get the number of local variables in this frame.
	def numLocals() -> int {
		checkNotUnwound();
		return frame.func.decl.num_locals;
	}
	// Get the value of local variable {i}.
	def getLocal(i: int) -> Value {
		checkNotUnwound();
		if (u32.view(i) >= frame.func.decl.num_locals) System.error("FrameAccessorError", "local index out-of-bounds");
		return V3Interpreter.val_stack.elems[frame.fp + i];
	}
	// Set the value of a local variable. (dynamically typechecked).
	def setLocal(i: int, v: Value) {
		// TODO: dynamically typecheck
		checkNotUnwound();
		if (u32.view(i) >= frame.func.decl.num_locals) System.error("FrameAccessorError", "local index out-of-bounds");
		V3Interpreter.val_stack.elems[frame.fp + i] = v;
	}
	// Get the number of operand stack elements.
	def numOperands() -> int {
		checkNotUnwound();
		if (!isTop()) System.error("FrameAccessorError", "numOperands only supported for top frame"); // TODO
		return V3Interpreter.val_stack.top - (frame.fp + frame.func.decl.num_locals);
	}
	// Get operand at depth {i}, with 0 being the top of the stack, -1 being one lower, etc.
	def getOperand(i: int) -> Value {
		checkNotUnwound();
		if (!isTop()) System.error("FrameAccessorError", "numOperands only supported for top frame"); // TODO
		return V3Interpreter.val_stack.elems[V3Interpreter.val_stack.top + i - 1]; // TODO: bounds check
	}
	// Set operand at depth {i}, with 0 being the top of the stack, -1 being one lower, etc. (dynamically typechecked).
	def setOperand(i: int, v: Value);

	private def checkNotUnwound() {
		if (isUnwound()) System.error("FrameAccessorError", "frame has been unwound");
	}
}
