// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class V3Interpreter extends WasmStack {
	private var instrTracer: InstrTracer;
	private def values = ArrayStack<Value>.new();	// storage of all WasmValues
	private var state_: StackState;
	private var stack_switch_info: StackSwitchInfo;	// set when `state_` is `SUSPENDED` or `CALL_CHILD`
	private var cache: V3Frame;			// cache of all V3Frame objects (bottom of stack)
	private var frame: V3Frame;
	private var host_frame: HostFrame;
	private var host_outcall: HostFunction;
	private def codeptr = CodePtr.new(null);	// pointer into code
	private var thrown: Throwable;			// trap reason, if any
	private var params_arity = -1;
	private var return_arity = -1;

	// After `resume` is called, this stack is marked as CALL_CHILD and moves to
	// the next instruction when resumed in the future. However at that time,
	// the `pc` would point to the next instruction, making handler lookup
	// impossible without somehow retrieving the `pc` at the `resume` that
	// caused the CALL_CHILD transition. This variable is a hack for that.
	private var prev_resume_pc = -1;

	// WasmStack interface
	// ===================================================================================
	def state() -> StackState {
		return state_;
	}
	def reset(func: Function) -> this {
		checkState("reset()", StackState.EMPTY);
		pushFrame(func, 0);
		params_arity = func.sig.params.length;
		return_arity = func.sig.results.length;
		thrown = null;
		state_ = if(params_arity == 0, StackState.RESUMABLE, StackState.SUSPENDED);
	}
	def bind(args: Range<Value>) -> this {
		if (args.length == 0 && state_ == StackState.RESUMABLE) return;
		checkState("bind()", StackState.SUSPENDED);
		if (params_arity < args.length) fatal(Strings.format2("bind() expected %d arguments, got %d", params_arity, args.length));
		for (v in args) values.push(v); // XXX: ArrayStack.pushr
		params_arity -= args.length;
		if (params_arity == 0) state_ = StackState.RESUMABLE;
	}
	def resume() -> Result {
		checkState("resume()", StackState.RESUMABLE);
		thrown = null;

		// Set the initial state to running and loop until return, throw, or suspend.
		state_ = StackState.RUNNING;
		while (state_ == StackState.RUNNING) {
			// Run Wasm code until it either traps, suspends, or makes a host outcall.
			runWasmCode();
			// Run host calls until they either trap, return, or tail-call Wasm.
			runHostCall();
		}

		// Return the appropriate result.
		match (state_) {
			THROWING => return clearAndThrow();
			RETURNING => return clearAndReturn();
			SUSPENDED => return Result.StackSwitch(stack_switch_info);
			CALL_CHILD => return Result.StackSwitch(stack_switch_info);
			_ => {
				clear();
				return Result.Throw(Trap.new(TrapReason.ERROR, "invalid interpreter state", null)); // TODO: error message for wrong state
			}
		}
	}
	def clearAndThrow() -> Result.Throw {
		var t = thrown;
		clear();
		return Result.Throw(t);
	}
	def clearAndReturn() -> Result.Value {
		var top = values.top;
		var vals = Ranges.dup(values.elems[(top - return_arity) ... top]);
		clear();
		return Result.Value(vals);
	}
	def popAllFrames(stacktrace: bool) -> StackSegment {
		var result: StackSegment;
		if (stacktrace) {
			var f = frame;
			var frames = Array<(WasmFunction, int)>.new(if(f != null, 1 + f.depth));
			var i = frames.length - 1;
			while (f != null) {
				frames[i--] = (f.func, f.pc);
				f = f.prev;
			}
			result = StackSegment.new(null, host_outcall, frames);
		}
		frame = null;
		host_outcall = null;
		return result;
	}

	def clear() -> this {
		state_ = StackState.EMPTY;
		values.top = 0;
		frame = null;
		host_outcall = null;
		return_arity = -1;
		params_arity = -1;
		codeptr.reset(null, 0, 0);
	}

	// Internal implementation: nominally private
	// ======================================================================================
	private def checkState(op: string, expected: StackState) {
		if (state_ != expected) fatal(Strings.format3("%s requires state == %s, got %s", op, expected.name, state_.name));
	}

	def pushFrame(f: Function, arity: int) {
		match (f) {
			hf: HostFunction => {
				host_outcall = hf;
			}
			wf: WasmFunction => {
				var next = frame = nextFrame(frame);
				if (next.depth > Execute.limits.max_call_depth) {
					trap(TrapReason.STACK_OVERFLOW);
					return;
				}
				next.func = wf;
				next.fp = values.top - arity;
				next.pc = 0;
				next.stp = 0;
				next.accessor = null;
				var code = wf.decl.cur_bytecode;
				codeptr.reset(code, 0, code.length);
			}
		}
	}
	private def nextFrame(caller: V3Frame) -> V3Frame {
		if (caller == null) {
			if (cache == null) return cache = V3Frame.new(this, null);
			return cache;
		}
		var next = caller.next;
		if (next == null) next = caller.next = V3Frame.new(this, caller);
		return next;
	}
	private def popFrame() -> V3Frame {
		if (frame == null) return null;
		frame.accessor = null;
		frame = frame.prev;
		if (frame == null) {
			codeptr.reset(null, 0, 0);
			return null;
		} else {
			var code = frame.func.decl.cur_bytecode;
			codeptr.reset(code, frame.pc, code.length);
			return frame;
		}
	}
	private def pushLocals(count: u32, vtc: ValueTypeCode) {
		var val: Value;
		match (vtc.toConcreteValueKind(frame.func.instance)) {
			I32 => val = Values.I32_0;
			I64 => val = Values.I64_0;
			F32 => val = Values.F32_0;
			F64 => val = Values.F64_0;
			V128 => val = Values.V128_0;
			REF => val = Values.REF_NULL;
		}
		values.pushn(val, int.!(count));
	}
	private def copyVals(count: int, dest: int) {
		var sp = values.top - count;
		if (sp != dest) {
			var e = values.elems;
			for (i < count) e[dest + i] = e[sp + i];
		}
		values.top = dest + count;
	}

	def runWasmCode() {
		while (state_ == StackState.RUNNING) {
			if (frame == null || host_outcall != null) return;
			var func = frame.func, pc = frame.pc;
			if (pc == 0) {
				// Entering the function; initialize locals.
				codeptr.iterate_local_codes(pushLocals);
				for (i < func.decl.num_ex_slots) values.push(Values.REF_NULL); // init legacy EH slots
				frame.pc = pc = codeptr.pos; // update pc after decoding locals
				// Fire entry probe(s).
				if (func.decl.entry_probed) {
					var throwable = Instrumentation.fireLocalProbes(DynamicLoc(func, 0, TargetFrame(frame)));
					if (throwable != null) {
						throw(throwable);
						continue;
					}
				}
			}

			// Fire global probes.
			if (Instrumentation.probes != null) {
				var throwable = Instrumentation.fireGlobalProbes(DynamicLoc(func, pc, TargetFrame(frame)));
				if (throwable != null) {
					throw(throwable);
					continue;
				}
			}
			// Read the opcode.
			var b = codeptr.peek1();
			var opcode: Opcode;
			if (b == InternalOpcode.PROBE.code) {
				// First local probes.
				var throwable = Instrumentation.fireLocalProbes(DynamicLoc(func, pc, TargetFrame(frame)));
				if (throwable != null) {
					throw(throwable);
					continue;
				}
				opcode = codeptr.read_orig_opcode(frame.func.decl.orig_bytecode[pc]);
			} else {
				opcode = codeptr.read_opcode();
			}
			execOp(pc, opcode);
		}
	}
	def runHostCall() {
		var hf: HostFunction;
		while ((hf = host_outcall) != null) {
			if (Trace.interpreter) Execute.traceCallHostFunction(hf);
			var sig = hf.sig, arity = sig.params.length;
			var oldVsp = values.top;
			var result = hf.invoke(values.peekn(arity));
			var newVsp = oldVsp - arity;
			values.top = newVsp;
			match (result) {
				Throw(thrown) => {
					return void(throw(thrown));
				}
				Value0 => {
					return doHostReturn(newVsp, sig);
				}
				Value1(val) => {
					values.push(val);
					return doHostReturn(newVsp, sig);
				}
				ValueN(vals) => {
					for (v in vals) values.push(v);
					return doHostReturn(newVsp, sig);
				}
				TailCall(f, args) => {
					host_outcall = null;
					for (v in args) values.push(v);
					pushFrame(f, args.length);
				}
			}
		}
	}
	def doHostReturn(fp: int, sig: SigDecl) {
		host_outcall = null;
		if (frame == null) doReturn(fp, sig);
		else advanceCaller();
	}
	def doCallFunction(f: Function) {
		if (frame != null) codeptr.at(frame.pc);
		pushFrame(f, f.sig.params.length);
	}
	def doReturn(fp: int, sig: SigDecl) {
		var count = sig.results.length;
		copyVals(count, fp);
		frame = popFrame();

		if (frame == null) {  // popped top frame, finished execution
			if (return_arity != count) fatal(Strings.format2("top-level return expected %d vals, got %d", return_arity, count));
			state_ = StackState.RETURNING;
		} else { // advance past caller's call instruction
			advanceCaller();
		}
	}
	def execOp(pc: int, opcode: Opcode) {
		if (Debug.interpreter && Trace.interpreter) traceStack();
		match (opcode) {
			UNREACHABLE => {
				trap(TrapReason.UNREACHABLE);
			}
			NOP => {
				// do nothing
			}
			TRY,
			BLOCK,
			LOOP => {
				codeptr.skip_block_type();
			}
			IF => {
				var cond = popi();
				if (cond == 0) {
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_block_type();
					doFallthru();
				}
			}
			CATCH,
			CATCH_ALL,
			ELSE => {
				codeptr.at(doGoto(pc));
			}
			DELEGATE => {
				codeptr.skip_label();
			}
			THROW => {
				var index = codeptr.read_uleb31();
				var tag = frame.func.instance.tags[index];
				var ex = Exception.new(tag, popN(tag.decl.fields.length), null);
				throw(ex);
			}
			RETHROW => {
				var sidetable = frame.func.decl.sidetable;
				var ex_slot = sidetable.entries[frame.stp];
				if (Trace.exception) Trace.OUT.put2("  rethrow fp=%d ex_slot=%d", frame.fp, ex_slot).ln();
				var popcount = sidetable.entries[frame.stp + 2], valcount = 0;
				if (popcount > 0) {
					copyVals(valcount, values.top - int.!(popcount + valcount));
				}
				frame.stp += 4;
				var exval = values.elems[frame.fp + frame.func.decl.num_locals + ex_slot];
				throw(Exception.!(Value.Ref.!(exval).val));
			}
			THROW_REF => {
				var exval = popr();
				throw(Exception.!(exval.val));
			}
			END => {
				if (codeptr.available() == 0) doReturn(frame.fp, frame.func.sig);
			}
			BR => {
				codeptr.at(doGoto(pc));
			}
			BR_IF => {
				var cond = popi();
				doBranch(pc, cond != 0);
			}
			BR_TABLE => {
				var key = popu();
				codeptr.at(doSwitch(pc, key));
			}
			RETURN => {
				doReturn(frame.fp, frame.func.sig);
			}
			CALL => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				return doCallFunction(f);
			}
			CALL_INDIRECT => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popu();
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) return doCallFunction(f);
			}
			RETURN_CALL => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				prepareReturnCall(f.sig);
				return doCallFunction(f);
			}
			RETURN_CALL_INDIRECT => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popu();
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) {
					prepareReturnCall(f.sig);
					return doCallFunction(f);
				}
			}
			CALL_REF => {
				var sig_index = codeptr.read_uleb32();
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) trap(TrapReason.NULL_DEREF);
				else return doCallFunction(func);
			}
			RETURN_CALL_REF => {
				var sig_index = codeptr.read_uleb32();
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) {
					trap(TrapReason.NULL_DEREF);
				} else {
					prepareReturnCall(func.sig);
					return doCallFunction(func);
				}
			}
			DROP => {
				pop();
			}
			SELECT => {
				var cond = popu(), b = pop(), a = pop();
				push(if(cond != 0, a, b));
			}
			SELECT_T => {
				var count = codeptr.skip_value_types();
				var cond = popu();
				if (cond != 0) {
					values.top -= count; // pop false values off the stack
				} else {
					copyVals(count, values.top - (count << 1)); // transfer false values down
				}
			}
			TRY_TABLE => {
				codeptr.skip_block_type();
				var count = codeptr.read_uleb31();
				for (i < count) codeptr.skip_catch();
				frame.stp += count * Sidetable_CatchEntry.size / 4; // TODO: catch entry size
			}
			LOCAL_GET => {
				var index = codeptr.read_uleb32();
				var val = values.elems[frame.fp + int.!(index)];
				push(values.elems[frame.fp + int.!(index)]);
			}
			LOCAL_SET => {
				var index = codeptr.read_uleb32();
				values.elems[frame.fp + int.!(index)] = pop();
			}
			LOCAL_TEE => {
				var index = codeptr.read_uleb32();
				values.elems[frame.fp + int.!(index)] = values.peek();
			}
			GLOBAL_GET => {
				var global_index = codeptr.read_uleb31();
				Runtime.GLOBAL_GET(this, frame.func.instance, global_index);
			}
			GLOBAL_SET => {
				var global_index = codeptr.read_uleb31();
				Runtime.GLOBAL_SET(this, frame.func.instance, global_index);
			}
			TABLE_GET => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_GET(this, frame.func.instance, table_index);
			}
			TABLE_SET => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_SET(this, frame.func.instance, table_index);
			}

			I32_LOAD 	=> doLoad(4, DataReaders.read_range_u32, Value.I32);
			I64_LOAD 	=> doLoad(8, DataReaders.read_range_u64, Value.I64);
			F32_LOAD 	=> doLoad(4, DataReaders.read_range_u32, Value.F32);
			F64_LOAD 	=> doLoad(8, DataReaders.read_range_u64, Value.F64);
			I32_LOAD8_S	=> doLoad(1, DataReaders.read_range_u32_i8, Value.I32);
			I32_LOAD8_U	=> doLoad(1, DataReaders.read_range_u32_u8, Value.I32);
			I32_LOAD16_S	=> doLoad(2, DataReaders.read_range_u32_i16, Value.I32);
			I32_LOAD16_U	=> doLoad(2, DataReaders.read_range_u32_u16, Value.I32);
			I64_LOAD8_S	=> doLoad(1, DataReaders.read_range_u64_i8, Value.I64);
			I64_LOAD8_U	=> doLoad(1, DataReaders.read_range_u64_u8, Value.I64);
			I64_LOAD16_S	=> doLoad(2, DataReaders.read_range_u64_i16, Value.I64);
			I64_LOAD16_U	=> doLoad(2, DataReaders.read_range_u64_u16, Value.I64);
			I64_LOAD32_S	=> doLoad(4, DataReaders.read_range_u64_i32, Value.I64);
			I64_LOAD32_U	=> doLoad(4, DataReaders.read_range_u64_u32, Value.I64);
			I32_STORE	=> doStore(4, DataWriters.write_range_u32, Values.unbox_u);
			I64_STORE	=> doStore(8, DataWriters.write_range_u64, Values.unbox_w);
			F32_STORE	=> doStore(4, DataWriters.write_range_u32, Values.unbox_fu32);
			F64_STORE	=> doStore(8, DataWriters.write_range_u64, Values.unbox_du64);
			I32_STORE8	=> doStore(1, DataWriters.write_range_u8, Values.unbox_u8);
			I32_STORE16	=> doStore(2, DataWriters.write_range_u16, Values.unbox_u16);
			I64_STORE8	=> doStore(1, DataWriters.write_range_u8, Values.unbox_w8);
			I64_STORE16	=> doStore(2, DataWriters.write_range_u16, Values.unbox_w16);
			I64_STORE32	=> doStore(4, DataWriters.write_range_u32, Values.unbox_w32);

			// Atomic load and stores
			I32_ATOMIC_LOAD	       => doAtomicLoad(4, DataReaders.read_range_u32, Value.I32);
			I64_ATOMIC_LOAD        => doAtomicLoad(8, DataReaders.read_range_u64, Value.I64);
            		I32_ATOMIC_LOAD8_U     => doAtomicLoad(1, DataReaders.read_range_u32_u8, Value.I32);
            		I32_ATOMIC_LOAD16_U    => doAtomicLoad(2, DataReaders.read_range_u32_u16, Value.I32);
            		I64_ATOMIC_LOAD8_U     => doAtomicLoad(1, DataReaders.read_range_u64_u8, Value.I64);
            		I64_ATOMIC_LOAD16_U    => doAtomicLoad(2, DataReaders.read_range_u64_u16, Value.I64);
			I64_ATOMIC_LOAD32_U    => doAtomicLoad(4, DataReaders.read_range_u64_u32, Value.I64);

			MEMORY_SIZE => {
				var index = codeptr.read_uleb32();
				var memory = frame.func.instance.memories[index];
				pushm(memory, memory.num_pages);
			}
			MEMORY_GROW => {
				var mem_index = codeptr.read_uleb31();
				Runtime.MEMORY_GROW(this, frame.func.instance, mem_index);
			}

			I32_CONST => pushi(codeptr.read_sleb32());
			I64_CONST => pushl(codeptr.read_sleb64());
			F32_CONST => push(Value.F32(codeptr.read_u32()));
			F64_CONST => push(Value.F64(codeptr.read_u64()));

			I32_EQZ => pushz(popu() == 0);
			I32_EQ => do_uu_z(V3Eval.I32_EQ);
			I32_NE => do_uu_z(V3Eval.I32_NE);
			I32_LT_S => do_ii_z(V3Eval.I32_LT_S);
			I32_LT_U => do_uu_z(V3Eval.I32_LT_U);
			I32_GT_S => do_ii_z(V3Eval.I32_GT_S);
			I32_GT_U => do_uu_z(V3Eval.I32_GT_U);
			I32_LE_S => do_ii_z(V3Eval.I32_LE_S);
			I32_LE_U => do_uu_z(V3Eval.I32_LE_U);
			I32_GE_S => do_ii_z(V3Eval.I32_GE_S);
			I32_GE_U => do_uu_z(V3Eval.I32_GE_U);

			I64_EQZ => pushz(popw() == 0);
			I64_EQ => do_ww_z(V3Eval.I64_EQ);
			I64_NE => do_ww_z(V3Eval.I64_NE);
			I64_LT_S => do_ll_z(V3Eval.I64_LT_S);
			I64_LT_U => do_ww_z(V3Eval.I64_LT_U);
			I64_GT_S => do_ll_z(V3Eval.I64_GT_S);
			I64_GT_U => do_ww_z(V3Eval.I64_GT_U);
			I64_LE_S => do_ll_z(V3Eval.I64_LE_S);
			I64_LE_U => do_ww_z(V3Eval.I64_LE_U);
			I64_GE_S => do_ll_z(V3Eval.I64_GE_S);
			I64_GE_U => do_ww_z(V3Eval.I64_GE_U);

			F32_EQ => do_ff_z(V3Eval.F32_EQ);
			F32_NE => do_ff_z(V3Eval.F32_NE);
			F32_LT => do_ff_z(V3Eval.F32_LT);
			F32_GT => do_ff_z(V3Eval.F32_GT);
			F32_LE => do_ff_z(V3Eval.F32_LE);
			F32_GE => do_ff_z(V3Eval.F32_GE);
			F64_EQ => do_dd_z(V3Eval.F64_EQ);
			F64_NE => do_dd_z(V3Eval.F64_NE);
			F64_LT => do_dd_z(V3Eval.F64_LT);
			F64_GT => do_dd_z(V3Eval.F64_GT);
			F64_LE => do_dd_z(V3Eval.F64_LE);
			F64_GE => do_dd_z(V3Eval.F64_GE);

			I32_CLZ => do_u_u(V3Eval.I32_CLZ);
			I32_CTZ => do_u_u(V3Eval.I32_CTZ);
			I32_POPCNT => do_u_u(V3Eval.I32_POPCNT);
			I32_ADD => do_uu_u(V3Eval.I32_ADD);
			I32_SUB => do_uu_u(V3Eval.I32_SUB);
			I32_MUL => do_uu_u(V3Eval.I32_MUL);
			I32_DIV_S => do_ii_it(V3Eval.I32_DIV_S);
			I32_DIV_U => do_uu_ut(V3Eval.I32_DIV_U);
			I32_REM_S => do_ii_it(V3Eval.I32_REM_S);
			I32_REM_U => do_uu_ut(V3Eval.I32_REM_U);
			I32_AND => do_uu_u(V3Eval.I32_AND);
			I32_OR => do_uu_u(V3Eval.I32_OR);
			I32_XOR => do_uu_u(V3Eval.I32_XOR);
			I32_SHL => do_ii_i(V3Eval.I32_SHL);
			I32_SHR_S => do_ii_i(V3Eval.I32_SHR_S);
			I32_SHR_U => do_ii_i(V3Eval.I32_SHR_U);
			I32_ROTL => do_uu_u(V3Eval.I32_ROTL);
			I32_ROTR => do_uu_u(V3Eval.I32_ROTR);

			I64_CLZ => do_w_w(V3Eval.I64_CLZ);
			I64_CTZ => do_w_w(V3Eval.I64_CTZ);
			I64_POPCNT => do_w_w(V3Eval.I64_POPCNT);

			I64_ADD => do_ww_w(V3Eval.I64_ADD);
			I64_SUB => do_ww_w(V3Eval.I64_SUB);
			I64_MUL => do_ww_w(V3Eval.I64_MUL);
			I64_DIV_S => do_ll_lt(V3Eval.I64_DIV_S);
			I64_DIV_U => do_ww_wt(V3Eval.I64_DIV_U);
			I64_REM_S => do_ll_lt(V3Eval.I64_REM_S);
			I64_REM_U => do_ww_wt(V3Eval.I64_REM_U);
			I64_AND => do_ww_w(V3Eval.I64_AND);
			I64_OR => do_ww_w(V3Eval.I64_OR);
			I64_XOR => do_ww_w(V3Eval.I64_XOR);
			I64_SHL => do_ww_w(V3Eval.I64_SHL);
			I64_SHR_S => do_ll_l(V3Eval.I64_SHR_S);
			I64_SHR_U => do_ww_w(V3Eval.I64_SHR_U);
			I64_ROTL => do_ww_w(V3Eval.I64_ROTL);
			I64_ROTR => do_ww_w(V3Eval.I64_ROTR);

			F32_ABS => do_f_f(V3Eval.F32_ABS);
			F32_NEG => do_f_f(V3Eval.F32_NEG);
			F32_CEIL => do_f_f(V3Eval.F32_CEIL);
			F32_FLOOR => do_f_f(V3Eval.F32_FLOOR);
			F32_TRUNC => do_f_f(V3Eval.F32_TRUNC);
			F32_NEAREST => do_f_f(V3Eval.F32_NEAREST);
			F32_SQRT => do_f_f(V3Eval.F32_SQRT);
			F32_ADD => do_ff_f(V3Eval.F32_ADD);
			F32_SUB => do_ff_f(V3Eval.F32_SUB);
			F32_MUL => do_ff_f(V3Eval.F32_MUL);
			F32_DIV => do_ff_f(V3Eval.F32_DIV);
			F32_MIN => do_ff_f(V3Eval.F32_MIN);
			F32_MAX => do_ff_f(V3Eval.F32_MAX);
			F32_COPYSIGN => do_ff_f(V3Eval.F32_COPYSIGN);

			F64_ABS => do_d_d(V3Eval.F64_ABS);
			F64_NEG => do_d_d(V3Eval.F64_NEG);
			F64_CEIL => do_d_d(V3Eval.F64_CEIL);
			F64_FLOOR => do_d_d(V3Eval.F64_FLOOR);
			F64_TRUNC => do_d_d(V3Eval.F64_TRUNC);
			F64_NEAREST => do_d_d(V3Eval.F64_NEAREST);
			F64_SQRT => do_d_d(V3Eval.F64_SQRT);
			F64_ADD => do_dd_d(V3Eval.F64_ADD);
			F64_SUB => do_dd_d(V3Eval.F64_SUB);
			F64_MUL => do_dd_d(V3Eval.F64_MUL);
			F64_DIV => do_dd_d(V3Eval.F64_DIV);
			F64_MIN => do_dd_d(V3Eval.F64_MIN);
			F64_MAX => do_dd_d(V3Eval.F64_MAX);
			F64_COPYSIGN => do_dd_d(V3Eval.F64_COPYSIGN);

			I32_WRAP_I64 => pushu(V3Eval.I32_WRAP_I64(popw()));

			I32_TRUNC_F32_S => trap_or(V3Eval.I32_TRUNC_F32_S(popf()), pushi);
			I32_TRUNC_F32_U => trap_or(V3Eval.I32_TRUNC_F32_U(popf()), pushu);
			I32_TRUNC_F64_S => trap_or(V3Eval.I32_TRUNC_F64_S(popd()), pushi);
			I32_TRUNC_F64_U => trap_or(V3Eval.I32_TRUNC_F64_U(popd()), pushu);

			I64_EXTEND_I32_S => pushl(V3Eval.I64_EXTEND_I32_S(popi()));
			I64_EXTEND_I32_U => pushw(V3Eval.I64_EXTEND_I32_U(popu()));

			I64_TRUNC_F32_S => trap_or(V3Eval.I64_TRUNC_F32_S(popf()), pushl);
			I64_TRUNC_F32_U => trap_or(V3Eval.I64_TRUNC_F32_U(popf()), pushw);
			I64_TRUNC_F64_S => trap_or(V3Eval.I64_TRUNC_F64_S(popd()), pushl);
			I64_TRUNC_F64_U => trap_or(V3Eval.I64_TRUNC_F64_U(popd()), pushw);

			F32_CONVERT_I32_S => pushf(V3Eval.F32_CONVERT_I32_S(popi()));
			F32_CONVERT_I32_U => pushf(V3Eval.F32_CONVERT_I32_U(popu()));
			F32_CONVERT_I64_S => pushf(V3Eval.F32_CONVERT_I64_S(popl()));
			F32_CONVERT_I64_U => pushf(V3Eval.F32_CONVERT_I64_U(popw()));
			F32_DEMOTE_F64 => pushf(V3Eval.F32_DEMOTE_F64(popd()));
			F64_CONVERT_I32_S => pushd(V3Eval.F64_CONVERT_I32_S(popi()));
			F64_CONVERT_I32_U => pushd(V3Eval.F64_CONVERT_I32_U(popu()));
			F64_CONVERT_I64_S => pushd(V3Eval.F64_CONVERT_I64_S(popl()));
			F64_CONVERT_I64_U => pushd(V3Eval.F64_CONVERT_I64_U(popw()));
			F64_PROMOTE_F32 => pushd(V3Eval.F64_PROMOTE_F32(popf()));

			I32_REINTERPRET_F32 => pushu(V3Eval.I32_REINTERPRET_F32(popf()));
			F32_REINTERPRET_I32 => pushf(V3Eval.F32_REINTERPRET_I32(popu()));
			I64_REINTERPRET_F64 => pushw(V3Eval.I64_REINTERPRET_F64(popd()));
			F64_REINTERPRET_I64 => pushd(V3Eval.F64_REINTERPRET_I64(popw()));

			I32_EXTEND8_S => pushi(V3Eval.I32_EXTEND8_S(popi()));
			I32_EXTEND16_S => pushi(V3Eval.I32_EXTEND16_S(popi()));
			I64_EXTEND8_S => pushl(V3Eval.I64_EXTEND8_S(popl()));
			I64_EXTEND16_S => pushl(V3Eval.I64_EXTEND16_S(popl()));
			I64_EXTEND32_S => pushl(V3Eval.I64_EXTEND32_S(popl()));

			REF_NULL => {
				var index = codeptr.read_sleb32();
				push(Values.REF_NULL);
			}
			REF_IS_NULL => {
				var v = pop();
				var r = Values.isNull(v);
				pushz(r);
			}
			REF_FUNC => {
				var index = codeptr.read_uleb32();
				var func = frame.func.instance.functions[index];
				push(Value.Ref(func));
			}
			REF_AS_NON_NULL => {
				var v = pop();
				if (Values.isNull(v)) trap(TrapReason.NULL_DEREF);
				else push(v);
			}
			BR_ON_NULL => {
				var v = pop();
				if (Values.isNull(v)) { // XXX: use doBranch
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					push(v);
					doFallthru();
				}
			}
			REF_EQ => {
				var a = pop();
				var b = pop();
				pushz(a == b);
			}
			BR_ON_NON_NULL => {
				var v = pop();
				if (!Values.isNull(v)) {
					push(v);
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					doFallthru();
				}
			}
			STRUCT_NEW => {
				var struct_index = codeptr.read_uleb31();
				Runtime.STRUCT_NEW(this, frame.func.instance, struct_index);
			}
			STRUCT_NEW_DEFAULT => {
				var struct_index = codeptr.read_uleb31();
				Runtime.STRUCT_NEW_DEFAULT(this, frame.func.instance, struct_index);
			}
			STRUCT_GET => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_GET(this, frame.func.instance, struct_index, field_index);
			}
			STRUCT_GET_S => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_GET_S(this, frame.func.instance, struct_index, field_index);
			}
			STRUCT_GET_U => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_GET_U(this, frame.func.instance, struct_index, field_index);
			}
			STRUCT_SET => {
				var struct_index = codeptr.read_uleb31();
				var field_index = codeptr.read_uleb31();
				Runtime.STRUCT_SET(this, frame.func.instance, struct_index, field_index);
			}
			ARRAY_NEW => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW(this, frame.func.instance, array_index);
			}
			ARRAY_NEW_DEFAULT => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW_DEFAULT(this, frame.func.instance, array_index);
			}
			ARRAY_GET => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_GET(this, frame.func.instance, array_index);
			}
			ARRAY_GET_S => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_GET_S(this, frame.func.instance, array_index);
			}
			ARRAY_GET_U => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_GET_U(this, frame.func.instance, array_index);
			}
			ARRAY_SET => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_SET(this, frame.func.instance, array_index);
			}
			ARRAY_LEN => {
				var obj = HeapArray.!(popr().val);
				if (obj == null) trap(TrapReason.NULL_DEREF);
				else push(Value.I32(u32.view(obj.vals.length)));
			}
			ARRAY_FILL => {
				var array_index = codeptr.read_uleb31();
				Runtime.ARRAY_FILL(this, frame.func.instance, array_index);
			}
			ARRAY_COPY => {
				var array_index1 = codeptr.read_uleb31();
				var array_index2 = codeptr.read_uleb31();
				Runtime.ARRAY_COPY(this, frame.func.instance, array_index1, array_index2);
			}
			ARRAY_INIT_DATA => {
				var array_index = codeptr.read_uleb31();
				var data_index = codeptr.read_uleb31();
				Runtime.ARRAY_INIT_DATA(this, frame.func.instance, array_index, data_index);
			}
			ARRAY_INIT_ELEM => {
				var array_index = codeptr.read_uleb31();
				var elem_index = codeptr.read_uleb31();
				Runtime.ARRAY_INIT_ELEM(this, frame.func.instance, array_index, elem_index);
			}
			ARRAY_NEW_FIXED => {
				var array_index = codeptr.read_uleb31();
				var length = codeptr.read_uleb32();
				Runtime.ARRAY_NEW_FIXED(this, frame.func.instance, array_index, length);
			}
			ARRAY_NEW_DATA => {
				var array_index = codeptr.read_uleb31();
				var data_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW_DATA(this, frame.func.instance, array_index, data_index);
			}
			ARRAY_NEW_ELEM => {
				var array_index = codeptr.read_uleb31();
				var elem_index = codeptr.read_uleb31();
				Runtime.ARRAY_NEW_ELEM(this, frame.func.instance, array_index, elem_index);
			}
			REF_I31 => {
				push(Value.I31(u31.view(popu())));
			}
			I31_GET_S => {
				var v = pop();
				if (v == Values.REF_NULL) trap(TrapReason.NULL_DEREF);
				else pushi(i31.view(Value.I31.!(v).val));
			}
			I31_GET_U => {
				var v = pop();
				if (v == Values.REF_NULL) trap(TrapReason.NULL_DEREF);
				else pushu(Value.I31.!(v).val);
			}
			REF_TEST,
			REF_TEST_NULL => {
				var nullable = (opcode == Opcode.REF_TEST_NULL);
				var htcode = codeptr.read_sleb32();
				var result = Runtime.cast(frame.func.instance, nullable, htcode, pop());
				pushz(result);
			}
			REF_CAST,
			REF_CAST_NULL => {
				var nullable = (opcode == Opcode.REF_CAST_NULL);
				var htcode = codeptr.read_sleb32();
				var val = pop();
				var result = Runtime.cast(frame.func.instance, nullable, htcode, val);
				if (!result) trap(TrapReason.FAILED_CAST);
				else push(val);
			}
			BR_ON_CAST => {
				var imm = codeptr.read_BrOnCastImm();
				var val = pop();
				var result = Runtime.cast(frame.func.instance, imm.null2(), imm.ht2, val);
				push(val);
				if (result) codeptr.at(doGoto(pc));
				else doFallthru();
			}
			BR_ON_CAST_FAIL => {
				var imm = codeptr.read_BrOnCastImm();
				var val = pop();
				var result = Runtime.cast(frame.func.instance, imm.null2(), imm.ht2, val);
				push(val);
				if (!result) codeptr.at(doGoto(pc));
				else doFallthru();
			}
			ANY_CONVERT_EXTERN, EXTERN_CONVERT_ANY => {
				// nop
			}
			I32_TRUNC_SAT_F32_S => pushi(i32.truncf(popf()));
			I32_TRUNC_SAT_F32_U => pushu(u32.truncf(popf()));
			I32_TRUNC_SAT_F64_S => pushi(i32.truncd(popd()));
			I32_TRUNC_SAT_F64_U => pushu(u32.truncd(popd()));
			I64_TRUNC_SAT_F32_S => pushl(i64.truncf(popf()));
			I64_TRUNC_SAT_F32_U => pushw(u64.truncf(popf()));
			I64_TRUNC_SAT_F64_S => pushl(i64.truncd(popd()));
			I64_TRUNC_SAT_F64_U => pushw(u64.truncd(popd()));
			MEMORY_INIT => {
				var data_index = codeptr.read_uleb31(), mem_index = codeptr.read_uleb31();
				Runtime.MEMORY_INIT(this, frame.func.instance, data_index, mem_index);
			}
			DATA_DROP => {
				var dindex = codeptr.read_uleb32();
				frame.func.instance.dropped_data[dindex] = true;
			}
			MEMORY_COPY => {
				var dst = codeptr.read_uleb31(), src = codeptr.read_uleb31();
				Runtime.MEMORY_COPY(this, frame.func.instance, dst, src);
			}
			MEMORY_FILL => {
				var mem_index = codeptr.read_uleb31();
				Runtime.MEMORY_FILL(this, frame.func.instance, mem_index);
			}
			TABLE_INIT => {
				var elem_index = codeptr.read_uleb31();
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_INIT(this, frame.func.instance, elem_index, table_index);
			}
			ELEM_DROP => {
				var index = codeptr.read_uleb32();
				frame.func.instance.dropped_elems[index] = true;
			}
			TABLE_COPY => {
				var table_index1 = codeptr.read_uleb31();
				var table_index2 = codeptr.read_uleb31();
				Runtime.TABLE_COPY(this, frame.func.instance, table_index1, table_index2);
			}
			TABLE_GROW => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_GROW(this, frame.func.instance, table_index);
			}
			TABLE_SIZE => {
				var i = frame.func.instance;
				var table = i.tables[codeptr.read_uleb32()];
				pushi(table.elems.length);
			}
			TABLE_FILL => {
				var table_index = codeptr.read_uleb31();
				Runtime.TABLE_FILL(this, frame.func.instance, table_index);
			}
			V128_LOAD => 		doLoad(16, DataReaders.read_range_u128, Value.V128);
			V128_LOAD_64_LANE => 	doLoadLane(8, 3, DataReaders.read_range_u64);
			V128_LOAD_32_LANE => 	doLoadLane(4, 2, DataReaders.read_range_u32);
			V128_LOAD_16_LANE => 	doLoadLane(2, 1, DataReaders.read_range_u32_u16);
			V128_LOAD_8_LANE => 	doLoadLane(1, 0, DataReaders.read_range_u32_u8);
			V128_LOAD_64_SPLAT => 	doLoadSplat(8, 3, DataReaders.read_range_u64);
			V128_LOAD_32_SPLAT => 	doLoadSplat(4, 2, DataReaders.read_range_u32);
			V128_LOAD_16_SPLAT => 	doLoadSplat(2, 1, DataReaders.read_range_u32_u16);
			V128_LOAD_8_SPLAT => 	doLoadSplat(1, 0, DataReaders.read_range_u32_u8);
			V128_LOAD_32_ZERO => 	doLoadZero(4, DataReaders.read_range_u32);
			V128_LOAD_64_ZERO => 	doLoadZero(8, DataReaders.read_range_u64);
			V128_LOAD_8X8_S => 	doLoadExtend(1, i8.view<u64>, i16.view<i8>, u16.view<i16>);
			V128_LOAD_8X8_U => 	doLoadExtend(1, u8.view<u64>, u16.view<u8>, u16.view<u16>);
			V128_LOAD_16X4_S => 	doLoadExtend(2, i16.view<u64>, i32.view<i16>, u32.view<i32>);
			V128_LOAD_16X4_U => 	doLoadExtend(2, u16.view<u64>, u32.view<u16>, u32.view<u32>);
			V128_LOAD_32X2_S => 	doLoadExtend(4, i32.view<u64>, i64.view<i32>, u64.view<i64>);
			V128_LOAD_32X2_U => 	doLoadExtend(4, u32.view<u64>, u64.view<u32>, u64.view<u64>);
			V128_STORE => 		doStore(16, DataWriters.write_range_u128, Values.unbox_s);
			V128_STORE_8_LANE => 	doStoreLane(1, 0, u8.view<u64>, DataWriters.write_range_u8);
			V128_STORE_16_LANE => 	doStoreLane(2, 1, u16.view<u64>, DataWriters.write_range_u16);
			V128_STORE_32_LANE => 	doStoreLane(4, 2, u32.view<u64>, DataWriters.write_range_u32);
			V128_STORE_64_LANE => 	doStoreLane(8, 3, u64.view<u64>, DataWriters.write_range_u64);
			V128_CONST => {
				var low = codeptr.read_u64();
				var high = codeptr.read_u64();
				push(Value.V128(low, high));
			}
			I8X16_SPLAT => 		doSplat(1, 0, u8.view<i32>, popi);
			I16X8_SPLAT => 		doSplat(2, 1, u16.view<i32>, popi);
			I32X4_SPLAT => 		doSplat(4, 2, u32.view<i32>, popi);
			I64X2_SPLAT => 		doSplat(8, 3, u64.view<i64>, popl);
			F32X4_SPLAT => 		doSplat(4, 2, u32.view<float>, popf);
			F64X2_SPLAT => 		doSplat(8, 3, u64.view<double>, popd);
			V128_NOT => 		do_s_s(V3Eval.V128_NOT);
			V128_AND => 		do_ss_s(V3Eval.V128_AND);
			V128_OR => 		do_ss_s(V3Eval.V128_OR);
			V128_XOR => 		do_ss_s(V3Eval.V128_XOR);
			V128_BITSELECT => 	do_sss_s(V3Eval.V128_BITSELECT);
			V128_ANDNOT => 		do_ss_s(V3Eval.V128_ANDNOT);
			V128_ANYTRUE => 	do_s_z(V3Eval.V128_ANYTRUE);
			I8X16_ALLTRUE => 	do_s_z(V3Eval.I8X16_ALLTRUE);
			I16X8_ALLTRUE => 	do_s_z(V3Eval.I16X8_ALLTRUE);
			I32X4_ALLTRUE => 	do_s_z(V3Eval.I32X4_ALLTRUE);
			I64X2_ALLTRUE => 	do_s_z(V3Eval.I64X2_ALLTRUE);
			I8X16_BITMASK => 	do_s_i(V3Eval.I8X16_BITMASK);
			I16X8_BITMASK => 	do_s_i(V3Eval.I16X8_BITMASK);
			I32X4_BITMASK => 	do_s_i(V3Eval.I32X4_BITMASK);
			I64X2_BITMASK => 	do_s_i(V3Eval.I64X2_BITMASK);
			I64X2_ADD => 		do_ss_s(V3Eval.I64X2_ADD);
			I64X2_SUB => 		do_ss_s(V3Eval.I64X2_SUB);
			I64X2_MUL => 		do_ss_s(V3Eval.I64X2_MUL);
			I64X2_NEG => 		do_s_s(V3Eval.I64X2_NEG);
			I64X2_ABS => 		do_s_s(V3Eval.I64X2_ABS);
			I64X2_EQ => 		do_ss_s(V3Eval.I64X2_EQ);
			I64X2_NE => 		do_ss_s(V3Eval.I64X2_NE);
			I64X2_LT_S => 		do_ss_s(V3Eval.I64X2_LT_S);
			I64X2_LE_S => 		do_ss_s(V3Eval.I64X2_LE_S);
			I64X2_GT_S => 		do_ss_s(V3Eval.I64X2_GT_S);
			I64X2_GE_S => 		do_ss_s(V3Eval.I64X2_GE_S);
			I32X4_ADD => 		do_ss_s(V3Eval.I32X4_ADD);
			I32X4_SUB => 		do_ss_s(V3Eval.I32X4_SUB);
			I32X4_MUL => 		do_ss_s(V3Eval.I32X4_MUL);
			I32X4_NEG => 		do_s_s(V3Eval.I32X4_NEG);
			I32X4_DOT_I16X8_S => 	do_ss_s(V3Eval.I32X4_DOT_I16X8_S);
			I32X4_EXTADDPAIRWISE_I16X8_S => do_s_s(V3Eval.I32X4_EXTADDPAIRWISE_I16X8_S);
			I32X4_EXTADDPAIRWISE_I16X8_U => do_s_s(V3Eval.I32X4_EXTADDPAIRWISE_I16X8_U);
			I32X4_MIN_S => 		do_ss_s(V3Eval.I32X4_MIN_S);
			I32X4_MIN_U => 		do_ss_s(V3Eval.I32X4_MIN_U);
			I32X4_MAX_S => 		do_ss_s(V3Eval.I32X4_MAX_S);
			I32X4_MAX_U => 		do_ss_s(V3Eval.I32X4_MAX_U);
			I32X4_ABS => 		do_s_s(V3Eval.I32X4_ABS);
			I32X4_EQ => 		do_ss_s(V3Eval.I32X4_EQ);
			I32X4_NE => 		do_ss_s(V3Eval.I32X4_NE);
			I32X4_LT_S => 		do_ss_s(V3Eval.I32X4_LT_S);
			I32X4_LT_U => 		do_ss_s(V3Eval.I32X4_LT_U);
			I32X4_LE_S => 		do_ss_s(V3Eval.I32X4_LE_S);
			I32X4_LE_U => 		do_ss_s(V3Eval.I32X4_LE_U);
			I32X4_GT_S => 		do_ss_s(V3Eval.I32X4_GT_S);
			I32X4_GT_U => 		do_ss_s(V3Eval.I32X4_GT_U);
			I32X4_GE_S => 		do_ss_s(V3Eval.I32X4_GE_S);
			I32X4_GE_U => 		do_ss_s(V3Eval.I32X4_GE_U);
			I32X4_SHL => 		do_si_s(V3Eval.I32X4_SHL);
			I32X4_SHR_U => 		do_si_s(V3Eval.I32X4_SHR_U);
			I32X4_SHR_S => 		do_si_s(V3Eval.I32X4_SHR_S);
			I16X8_ADD => 		do_ss_s(V3Eval.I16X8_ADD);
			I16X8_SUB => 		do_ss_s(V3Eval.I16X8_SUB);
			I16X8_MUL => 		do_ss_s(V3Eval.I16X8_MUL);
			I16X8_Q15MULRSAT_S => 	do_ss_s(V3Eval.I16X8_Q15MULRSAT_S);
			I16X8_NEG => 		do_s_s(V3Eval.I16X8_NEG);
			I16X8_MIN_S => 		do_ss_s(V3Eval.I16X8_MIN_S);
			I16X8_MIN_U => 		do_ss_s(V3Eval.I16X8_MIN_U);
			I16X8_MAX_S => 		do_ss_s(V3Eval.I16X8_MAX_S);
			I16X8_MAX_U => 		do_ss_s(V3Eval.I16X8_MAX_U);
			I16X8_AVGR_U => 	do_ss_s(V3Eval.I16X8_AVGR_U);
			I16X8_ABS => 		do_s_s(V3Eval.I16X8_ABS);
			I16X8_EQ => 		do_ss_s(V3Eval.I16X8_EQ);
			I16X8_NE => 		do_ss_s(V3Eval.I16X8_NE);
			I16X8_LT_S => 		do_ss_s(V3Eval.I16X8_LT_S);
			I16X8_LT_U => 		do_ss_s(V3Eval.I16X8_LT_U);
			I16X8_LE_S => 		do_ss_s(V3Eval.I16X8_LE_S);
			I16X8_LE_U => 		do_ss_s(V3Eval.I16X8_LE_U);
			I16X8_GT_S => 		do_ss_s(V3Eval.I16X8_GT_S);
			I16X8_GT_U => 		do_ss_s(V3Eval.I16X8_GT_U);
			I16X8_GE_S => 		do_ss_s(V3Eval.I16X8_GE_S);
			I16X8_GE_U => 		do_ss_s(V3Eval.I16X8_GE_U);
			I16X8_ADD_SAT_S => 	do_ss_s(V3Eval.I16X8_ADD_SAT_S);
			I16X8_ADD_SAT_U => 	do_ss_s(V3Eval.I16X8_ADD_SAT_U);
			I16X8_SUB_SAT_S => 	do_ss_s(V3Eval.I16X8_SUB_SAT_S);
			I16X8_SUB_SAT_U => 	do_ss_s(V3Eval.I16X8_SUB_SAT_U);
			I16X8_SHL => 		do_si_s(V3Eval.I16X8_SHL);
			I16X8_SHR_U => 		do_si_s(V3Eval.I16X8_SHR_U);
			I16X8_SHR_S => 		do_si_s(V3Eval.I16X8_SHR_S);
			I8X16_ADD => 		do_ss_s(V3Eval.I8X16_ADD);
			I8X16_SUB => 		do_ss_s(V3Eval.I8X16_SUB);
			I8X16_NEG => 		do_s_s(V3Eval.I8X16_NEG);
			I16X8_EXTADDPAIRWISE_I8X16_S => do_s_s(V3Eval.I16X8_EXTADDPAIRWISE_I8X16_S);
			I16X8_EXTADDPAIRWISE_I8X16_U => do_s_s(V3Eval.I16X8_EXTADDPAIRWISE_I8X16_U);
			I8X16_ADD_SAT_S => 	do_ss_s(V3Eval.I8X16_ADD_SAT_S);
			I8X16_ADD_SAT_U => 	do_ss_s(V3Eval.I8X16_ADD_SAT_U);
			I8X16_SUB_SAT_S => 	do_ss_s(V3Eval.I8X16_SUB_SAT_S);
			I8X16_SUB_SAT_U => 	do_ss_s(V3Eval.I8X16_SUB_SAT_U);
			I8X16_MIN_S => 		do_ss_s(V3Eval.I8X16_MIN_S);
			I8X16_MIN_U => 		do_ss_s(V3Eval.I8X16_MIN_U);
			I8X16_MAX_S => 		do_ss_s(V3Eval.I8X16_MAX_S);
			I8X16_MAX_U => 		do_ss_s(V3Eval.I8X16_MAX_U);
			I8X16_AVGR_U => 	do_ss_s(V3Eval.I8X16_AVGR_U);
			I8X16_ABS => 		do_s_s(V3Eval.I8X16_ABS);
			I8X16_POPCNT => 	do_s_s(V3Eval.I8X16_POPCNT);
			I8X16_EQ => 		do_ss_s(V3Eval.I8X16_EQ);
			I8X16_NE => 		do_ss_s(V3Eval.I8X16_NE);
			I8X16_LT_S => 		do_ss_s(V3Eval.I8X16_LT_S);
			I8X16_LT_U => 		do_ss_s(V3Eval.I8X16_LT_U);
			I8X16_LE_S => 		do_ss_s(V3Eval.I8X16_LE_S);
			I8X16_LE_U => 		do_ss_s(V3Eval.I8X16_LE_U);
			I8X16_GT_S => 		do_ss_s(V3Eval.I8X16_GT_S);
			I8X16_GT_U => 		do_ss_s(V3Eval.I8X16_GT_U);
			I8X16_GE_S => 		do_ss_s(V3Eval.I8X16_GE_S);
			I8X16_GE_U => 		do_ss_s(V3Eval.I8X16_GE_U);
			I8X16_SHL => 		do_si_s(V3Eval.I8X16_SHL);
			I8X16_SHR_U => 		do_si_s(V3Eval.I8X16_SHR_U);
			I8X16_SHR_S => 		do_si_s(V3Eval.I8X16_SHR_S);
			F32X4_ADD => 		do_ss_s(V3Eval.F32X4_ADD);
			F32X4_SUB => 		do_ss_s(V3Eval.F32X4_SUB);
			F32X4_MUL => 		do_ss_s(V3Eval.F32X4_MUL);
			F32X4_DIV => 		do_ss_s(V3Eval.F32X4_DIV);
			F32X4_NEG => 		do_s_s(V3Eval.F32X4_NEG);
			F32X4_SQRT => 		do_s_s(V3Eval.F32X4_SQRT);
			F32X4_CEIL => 		do_s_s(V3Eval.F32X4_CEIL);
			F32X4_FLOOR => 		do_s_s(V3Eval.F32X4_FLOOR);
			F32X4_TRUNC => 		do_s_s(V3Eval.F32X4_TRUNC);
			F32X4_NEAREST => 	do_s_s(V3Eval.F32X4_NEAREST);
			F32X4_EQ => 		do_ss_s(V3Eval.F32X4_EQ);
			F32X4_NE => 		do_ss_s(V3Eval.F32X4_NE);
			F32X4_LT => 		do_ss_s(V3Eval.F32X4_LT);
			F32X4_LE => 		do_ss_s(V3Eval.F32X4_LE);
			F32X4_GT => 		do_ss_s(V3Eval.F32X4_GT);
			F32X4_GE => 		do_ss_s(V3Eval.F32X4_GE);
			F32X4_MIN => 		do_ss_s(V3Eval.F32X4_MIN);
			F32X4_MAX => 		do_ss_s(V3Eval.F32X4_MAX);
			F32X4_ABS => 		do_s_s(V3Eval.F32X4_ABS);
			F32X4_PMIN => 		do_ss_s(V3Eval.F32X4_PMIN);
			F32X4_PMAX => 		do_ss_s(V3Eval.F32X4_PMAX);
			F64X2_ADD => 		do_ss_s(V3Eval.F64X2_ADD);
			F64X2_SUB => 		do_ss_s(V3Eval.F64X2_SUB);
			F64X2_MUL => 		do_ss_s(V3Eval.F64X2_MUL);
			F64X2_DIV => 		do_ss_s(V3Eval.F64X2_DIV);
			F64X2_NEG => 		do_s_s(V3Eval.F64X2_NEG);
			F64X2_SQRT => 		do_s_s(V3Eval.F64X2_SQRT);
			F64X2_CEIL => 		do_s_s(V3Eval.F64X2_CEIL);
			F64X2_FLOOR => 		do_s_s(V3Eval.F64X2_FLOOR);
			F64X2_TRUNC => 		do_s_s(V3Eval.F64X2_TRUNC);
			F64X2_NEAREST => 	do_s_s(V3Eval.F64X2_NEAREST);
			F64X2_EQ => 		do_ss_s(V3Eval.F64X2_EQ);
			F64X2_NE => 		do_ss_s(V3Eval.F64X2_NE);
			F64X2_LT => 		do_ss_s(V3Eval.F64X2_LT);
			F64X2_LE => 		do_ss_s(V3Eval.F64X2_LE);
			F64X2_GT => 		do_ss_s(V3Eval.F64X2_GT);
			F64X2_GE => 		do_ss_s(V3Eval.F64X2_GE);
			F64X2_MIN => 		do_ss_s(V3Eval.F64X2_MIN);
			F64X2_MAX => 		do_ss_s(V3Eval.F64X2_MAX);
			F64X2_ABS => 		do_s_s(V3Eval.F64X2_ABS);
			F64X2_PMIN => 		do_ss_s(V3Eval.F64X2_PMIN);
			F64X2_PMAX => 		do_ss_s(V3Eval.F64X2_PMAX);
			I64X2_SHL => 		do_si_s(V3Eval.I64X2_SHL);
			I64X2_SHR_U => 		do_si_s(V3Eval.I64X2_SHR_U);
			I64X2_SHR_S => 		do_si_s(V3Eval.I64X2_SHR_S);
			I16X8_EXTEND_HIGH_I8X16_S => 	do_s_s(V3Eval.I16X8_EXTEND_HIGH_I8X16_S);
			I16X8_EXTEND_HIGH_I8X16_U => 	do_s_s(V3Eval.I16X8_EXTEND_HIGH_I8X16_U);
			I16X8_EXTEND_LOW_I8X16_S => 	do_s_s(V3Eval.I16X8_EXTEND_LOW_I8X16_S);
			I16X8_EXTEND_LOW_I8X16_U => 	do_s_s(V3Eval.I16X8_EXTEND_LOW_I8X16_U);
			I32X4_EXTEND_HIGH_I16X8_S => 	do_s_s(V3Eval.I32X4_EXTEND_HIGH_I16X8_S);
			I32X4_EXTEND_HIGH_I16X8_U => 	do_s_s(V3Eval.I32X4_EXTEND_HIGH_I16X8_U);
			I32X4_EXTEND_LOW_I16X8_S => 	do_s_s(V3Eval.I32X4_EXTEND_LOW_I16X8_S);
			I32X4_EXTEND_LOW_I16X8_U => 	do_s_s(V3Eval.I32X4_EXTEND_LOW_I16X8_U);
			I64X2_EXTEND_HIGH_I32X4_S => 	do_s_s(V3Eval.I64X2_EXTEND_HIGH_I32X4_S);
			I64X2_EXTEND_HIGH_I32X4_U => 	do_s_s(V3Eval.I64X2_EXTEND_HIGH_I32X4_U);
			I64X2_EXTEND_LOW_I32X4_S => 	do_s_s(V3Eval.I64X2_EXTEND_LOW_I32X4_S);
			I64X2_EXTEND_LOW_I32X4_U => 	do_s_s(V3Eval.I64X2_EXTEND_LOW_I32X4_U);
			I16X8_EXTMUL_LOW_I8X16_S => 	do_ss_s(V3Eval.I16X8_EXTMUL_LOW_I8X16_S);
			I16X8_EXTMUL_HIGH_I8X16_S => 	do_ss_s(V3Eval.I16X8_EXTMUL_HIGH_I8X16_S);
			I16X8_EXTMUL_LOW_I8X16_U => 	do_ss_s(V3Eval.I16X8_EXTMUL_LOW_I8X16_U);
			I16X8_EXTMUL_HIGH_I8X16_U => 	do_ss_s(V3Eval.I16X8_EXTMUL_HIGH_I8X16_U);
			I32X4_EXTMUL_LOW_I16X8_S => 	do_ss_s(V3Eval.I32X4_EXTMUL_LOW_I16X8_S);
			I32X4_EXTMUL_HIGH_I16X8_S => 	do_ss_s(V3Eval.I32X4_EXTMUL_HIGH_I16X8_S);
			I32X4_EXTMUL_LOW_I16X8_U => 	do_ss_s(V3Eval.I32X4_EXTMUL_LOW_I16X8_U);
			I32X4_EXTMUL_HIGH_I16X8_U => 	do_ss_s(V3Eval.I32X4_EXTMUL_HIGH_I16X8_U);
			I64X2_EXTMUL_LOW_I32X4_S => 	do_ss_s(V3Eval.I64X2_EXTMUL_LOW_I32X4_S);
			I64X2_EXTMUL_HIGH_I32X4_S => 	do_ss_s(V3Eval.I64X2_EXTMUL_HIGH_I32X4_S);
			I64X2_EXTMUL_LOW_I32X4_U => 	do_ss_s(V3Eval.I64X2_EXTMUL_LOW_I32X4_U);
			I64X2_EXTMUL_HIGH_I32X4_U => 	do_ss_s(V3Eval.I64X2_EXTMUL_HIGH_I32X4_U);
			I8X16_EXTRACTLANE_S => 		doExtractLane(0, i8.view<u64>, i32.view<i8>, pushi);
			I8X16_EXTRACTLANE_U => 		doExtractLane(0, u8.view<u64>, i32.view<u8>, pushi);
			I16X8_EXTRACTLANE_S => 		doExtractLane(1, i16.view<u64>, i32.view<i16>, pushi);
			I16X8_EXTRACTLANE_U => 		doExtractLane(1, u16.view<u64>, i32.view<u16>, pushi);
			I32X4_EXTRACTLANE => 		doExtractLane(2, i32.view<u64>, i32.view<i32>, pushi);
			I64X2_EXTRACTLANE => 		doExtractLane(3, i64.view<u64>, i64.view<i64>, pushl);
			F32X4_EXTRACTLANE => 		doExtractLane(2, u32.view<u64>, float.view<u32>, pushf);
			F64X2_EXTRACTLANE => 		doExtractLane(3, u64.view<u64>, double.view<u64>, pushd);
			I8X16_REPLACELANE => 		doReplaceLane(0, u8.view<i32>, popi, 0xFFul);
			I16X8_REPLACELANE => 		doReplaceLane(1, u16.view<i32>, popi, 0xFFFFul);
			I32X4_REPLACELANE => 		doReplaceLane(2, u32.view<i32>, popi, 0xFFFFFFFFul);
			I64X2_REPLACELANE => 		doReplaceLane(3, u64.view<i64>, popl, 0xFFFFFFFFFFFFFFFFul);
			F32X4_REPLACELANE => 		doReplaceLane(2, u32.view<float>, popf, 0xFFFFFFFFul);
			F64X2_REPLACELANE => 		doReplaceLane(3, u64.view<double>, popd, 0xFFFFFFFFFFFFFFFFul);
			F32X4_CONVERT_I32X4_S => 	do_s_s(V3Eval.F32X4_CONVERT_I32X4_S);
			F32X4_CONVERT_I32X4_U => 	do_s_s(V3Eval.F32X4_CONVERT_I32X4_U);
			F64X2_CONVERT_LOW_I32X4_S => 	do_s_s(V3Eval.F64X2_CONVERT_LOW_I32X4_S);
			F64X2_CONVERT_LOW_I32X4_U => 	do_s_s(V3Eval.F64X2_CONVERT_LOW_I32X4_U);
			I8X16_NARROW_I16X8_S => 	do_ss_s(V3Eval.I8X16_NARROW_I16X8_S);
			I8X16_NARROW_I16X8_U => 	do_ss_s(V3Eval.I8X16_NARROW_I16X8_U);
			I16X8_NARROW_I32X4_S => 	do_ss_s(V3Eval.I16X8_NARROW_I32X4_S);
			I16X8_NARROW_I32X4_U => 	do_ss_s(V3Eval.I16X8_NARROW_I32X4_U);
			F64X2_PROMOTE_LOW_F32X4 => 	do_s_s(V3Eval.F64X2_PROMOTE_LOW_F32X4);
			F32X4_DEMOTE_F64X2_ZERO => 	do_s_s(V3Eval.F32X4_DEMOTE_F64X2_ZERO);
			I32X4_TRUNC_SAT_F32X4_S => 	do_s_s(V3Eval.I32X4_TRUNC_SAT_F32X4_S);
			I32X4_TRUNC_SAT_F32X4_U => 	do_s_s(V3Eval.I32X4_TRUNC_SAT_F32X4_U);
			I32X4_TRUNC_SAT_F64X2_S_ZERO => do_s_s(V3Eval.I32X4_TRUNC_SAT_F64X2_S_ZERO);
			I32X4_TRUNC_SAT_F64X2_U_ZERO => do_s_s(V3Eval.I32X4_TRUNC_SAT_F64X2_U_ZERO);
			I8X16_SHUFFLE => doShuffle();
			I8X16_SWIZZLE => doSwizzle();
			// ext:typed-continuation
			CONT_NEW => {
				var cont_index = codeptr.read_uleb32();
				var cont_decl = ContDecl.!(frame.func.instance.heaptypes[cont_index]);
				var func = Function.!(Value.Ref.!(pop()).val);
				if (func == null) return void(trap(TrapReason.NULL_DEREF));

				var stack = V3Interpreter.new();
				stack.reset(func);
				var cont = Continuation.new(stack, stack);
				push(Value.Ref(cont));
			}
			CONT_BIND => {
				var in_cont = ContDecl.!(frame.func.instance.heaptypes[codeptr.read_uleb32()]);
				var out_cont = ContDecl.!(frame.func.instance.heaptypes[codeptr.read_uleb32()]);
				var n_binds = in_cont.sig.params.length - out_cont.sig.params.length;

				var cont = Continuation.!(Value.Ref.!(pop()).val);
				if (cont == null) return void(trap(TrapReason.NULL_DEREF));
				if (cont.used) return void(trap(TrapReason.USED_CONTINUATION));
				cont.used = true;

				var new_cont = Continuation.new(cont.top, cont.bottom);
				new_cont.top.bind(values.peekn(n_binds));
        
				cont.used = true;
				values.top -= n_binds;
				push(Value.Ref(new_cont));
			}
			RESUME => {
				var cont_idx = codeptr.read_uleb32();

				var cont_type = ContDecl.!(frame.func.instance.heaptypes[cont_idx]);
				var cont = Continuation.!(Value.Ref.!(pop()).val);
				if (cont == null) return void(trap(TrapReason.NULL_DEREF));
				if (cont.used) return void(trap(TrapReason.USED_CONTINUATION));
				cont.used = true;

				var n_binds = cont_type.sig.params.length;
				cont.top.bind(values.peekn(n_binds));
				values.top -= n_binds;

				prev_resume_pc = frame.pc;
				state_ = StackState.CALL_CHILD;
				stack_switch_info = StackSwitchInfo.RunChildStack(cont);
				return; // skip setting frame.pc = codeptr.pos
			}
			RESUME_THROW => {
				var cont_idx = codeptr.read_uleb32();
				var tag_idx = codeptr.read_uleb32();
				var handlers = codeptr.read_handlers();

				var cont_type = ContDecl.!(frame.func.instance.heaptypes[cont_idx]);
				var cont = Continuation.!(Value.Ref.!(pop()).val);
				if (cont == null) return void(trap(TrapReason.NULL_DEREF));
				if (cont.used) return void(trap(TrapReason.USED_CONTINUATION));

				var exn_tag = frame.func.instance.tags[tag_idx];
				var n_vals = exn_tag.sig.params.length;
				var vals = Ranges.dup(values.peekn(n_vals));
				values.top -= n_vals;
				var throwable = Exception.new(exn_tag, vals, null);

				cont.used = true;
				var res = cont.top.throw(throwable);
				prev_resume_pc = frame.pc;
				state_ = StackState.CALL_CHILD;
				stack_switch_info = StackSwitchInfo.RunChildStack(cont);
			}
			SUSPEND => {
				var tag = frame.func.instance.tags[codeptr.read_uleb32()];
				var n_vals = tag.sig.params.length;
				var range = Ranges.dup(values.peekn(n_vals));
				values.top -= n_vals;

				state_ = StackState.SUSPENDED;
				params_arity = tag.sig.results.length;
				stack_switch_info = StackSwitchInfo.Suspend(this, tag, range);
			}
			INVALID => trap(TrapReason.INVALID_OPCODE);
			_ => {
				trap(TrapReason.UNIMPLEMENTED);
			}
		}
		if (frame != null) frame.pc = codeptr.pos;
	}
	def doLoadReg<T>(size: byte) -> MaybeTrap<Range<byte>> {
		var memarg = codeptr.read_MemArg();
		var memory = frame.func.instance.memories[memarg.memory_index];
		var index = popm(memory);
		if (!u32.?(index)) return MaybeTrap<Range<byte>>(null, TrapReason.MEM_OUT_OF_BOUNDS);
		if (!u32.?(memarg.offset)) return MaybeTrap<Range<byte>>(null, TrapReason.MEM_OUT_OF_BOUNDS);
		return memory.range_oil_32(u32.!(memarg.offset), u32.!(index), size);
	}
	def doLoad<T>(size: byte, read: Range<byte> -> T, box: T -> Value) {
		var t = doLoadReg(size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		else push(box(read(t.result)));
	}
	// Atomic load
	def doAtomicLoadReg<T>(size: byte) -> MaybeTrap<Range<byte>> {
	    	var memarg = codeptr.read_MemArg();
 		var memory = frame.func.instance.memories[memarg.memory_index];
 		var index = popm(memory);
 		if (!u32.?(index)) return MaybeTrap<Range<byte>>(null, TrapReason.MEM_OUT_OF_BOUNDS);
 		if (!u32.?(memarg.offset)) return MaybeTrap<Range<byte>>(null, TrapReason.MEM_OUT_OF_BOUNDS);
 		return memory.range_oil_32(u32.!(memarg.offset), u32.!(index), size);
 	}
 	def doAtomicLoad<T>(size: byte, read: Range<byte> -> T, box: T -> Value) {
 		var t = doAtomicLoadReg(size);
 		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
 		else push(box(read(t.result))); // Suppose "read" function is atomic in Virgil.
 	}
	def doLoadLane<T>(size: byte, log2_size: u3, read: Range<byte> -> T) {
		var v = pops();
		var t = doLoadReg(size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = u64.!(read(t.result));
		var idx = codeptr.read1();
		var low = v.0, high = v.1;
		def half_lanes = 8 >> log2_size;
		if (idx < half_lanes) { // Update a lane in low
			var shift = u6.view(idx << u3.+(log2_size, 3));
			val <<= shift;
			low |= val;
		} else { // Update a lane in high
			var shift = u6.view((idx - half_lanes) << u3.+(log2_size, 3));
			val <<= shift;
			high |= val;
		}
		push(Value.V128(low, high));
	}
	def doLoadZero<T>(size: byte, read: Range<byte> -> T) {
		var t = doLoadReg(size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = u64.!(read(t.result));
		var high = 0ul;
		push(Value.V128(val, high));
	}
	// Tn: narrow source type, Sw: (signed) wide type, Uw: corresponding unsigned wide type
	def doLoadExtend<Tn, Sw, Uw>(size: byte, view: u64 -> Tn, extend: Tn -> Sw, convert: Sw -> Uw) {
		var t = doLoadReg(8);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = DataReaders.read_range_u64(t.result);
		var low = 0ul, high = 0ul;
		def src_shift = u6.view(size << 3);
		def dst_shift = u6.view(src_shift << 1);
		var shift: u6 = 0;
		for (i = 0; i < 4; i += size) {
			var v = u64.!(convert((extend(view(val)))));
			val >>= src_shift;
			low |= (v << shift);
			shift += dst_shift;
		}
		shift = 0;
		for (i = 0; i < 4; i += size) {
			var v = u64.!(convert((extend(view(val)))));
			val >>= src_shift;
			high |= (v << shift);
			shift += dst_shift;
		}
		push(Value.V128(low, high));
	}
	def doReplaceLane<T, S>(log2_size: u3, view: S -> T, stack_pop: void -> S, mask: u64) {
		var val = u64.!(view(stack_pop()));
		var v = pops();
		var idx = codeptr.read1();
		var low = v.0, high = v.1;
		def half_lanes = 8 >> log2_size;
		if (idx < half_lanes) { // Update a lane in low
			var shift = u6.view(idx << u3.+(log2_size, 3));
			mask <<= shift;
			low &= ~mask; // Zero out the target lane in low
			val <<= shift;
			low |= val;
		} else { // Update a lane in high
			var shift = u6.view((idx - half_lanes) << u3.+(log2_size, 3));
			mask <<= shift;
			high &= ~mask; // Zero out the target lane in high
			val <<= shift;
			high |= val;
		}
		push(Value.V128(low, high));
	}
	def doExtractLane<T, S>(log2_size: u3, view: u64 -> T, extend: T -> S, stack_push: S -> void) {
		var v = pops();
		var idx = codeptr.read1();
		var val = doExtractLane0(v, idx, log2_size, view, extend);
		stack_push(S.!(val));
	}
	def doExtractLane0<T, S>(v: (u64, u64), idx: byte, log2_size: u3, view: u64 -> T, extend: T -> S) -> S {
		var low = v.0, high = v.1;
		var val: S;
		def half_lanes = 8 >> log2_size;
		if (idx < half_lanes) { // Extract a lane from low
			var shift = u6.view(idx << u3.+(log2_size, 3));
			val = extend(view(low >> shift));
		} else { // Extract a lane from high
			var shift = u6.view((idx - half_lanes) << u3.+(log2_size, 3));
			val = extend(view(high >> shift));
		}
		return val;
	}
	def doShuffle(){
		var b = pops();
		var a = pops();
		var low = doShuffle0(a, b);
		var high = doShuffle0(a, b);
		push(Value.V128(low, high));
	}
	def doShuffle0(a: (u64, u64), b: (u64, u64)) -> u64 {
		var res = 0ul;
		for (i < 8) {
			var idx = codeptr.read1();
			var val = if (idx < 16, doExtractLane0(a, idx, 0, u8.view<u64>, u8.view<u8>),
									doExtractLane0(b, byte.!(idx - 16), 0, u8.view<u64>, u8.view<u8>));
			res |= u64.view(val) << u6.view(i << 3);
		}
		return res;
	}
	def doSwizzle(){
		var b = pops();
		var a = pops();
		var low = doSwizzle0(a, b.0);
		var high = doSwizzle0(a, b.1);
		push(Value.V128(low, high));
	}
	def doSwizzle0(a: (u64, u64), b: u64) -> u64 {
		var res = 0ul;
		for (i < 8) {
			var idx = u8.view(b);
			// For indices outside of the range the resulting lane is initialized to 0
			var val = if (idx < 16, doExtractLane0(a, idx, 0, u8.view<u64>, u8.view<u8>), 0);
			res |= u64.view(val) << u6.view(i << 3);
			b >>= 8;
		}
		return res;
	}
	def doLoadSplat<T>(size: byte, log2_size: byte, read: Range<byte> -> T) {
		var t = doLoadReg(size);
		if (t.reason != TrapReason.NONE) return void(trap(t.reason));
		var val = u64.!(read(t.result));
		doSplatV(size, log2_size, val);
	}
	def doSplat<T, S>(size: byte, log2_size: byte, view: S -> T, stack_pop: void -> S) {
		var val = u64.!(view((stack_pop())));
		doSplatV(size, log2_size, val);
	}
	def doSplatV(size: byte, log2_size: byte, val: u64) {
		var low = 0ul, high = 0ul;
		def half_lanes = 8 >> log2_size;
		var shift = u6.view(size << 3);
		for (i < half_lanes) {
			low <<= shift;
			low |= val;
			high <<= shift;
			high |= val;
		}
		push(Value.V128(low, high));
	}
	def doStore<T>(size: byte, write: (Range<byte>, T) -> void, unbox: Value -> T) {
		var memarg = codeptr.read_MemArg();
		var memory = frame.func.instance.memories[memarg.memory_index];
		var val = pop();
		var index = popm(memory);
		if (!u32.?(index)) return void(trap(TrapReason.MEM_OUT_OF_BOUNDS));
		if (!u32.?(memarg.offset)) return void(trap(TrapReason.MEM_OUT_OF_BOUNDS));
		var t = memory.range_oil_32(u32.!(memarg.offset), u32.!(index), size);
		if (t.reason != TrapReason.NONE) trap(t.reason);
		else write(t.result, unbox(val));
	}
	def doStoreLane<T>(size: byte, log2_size: u3, view: u64 -> T, write: (Range<byte>, T) -> void) {
		var v = pops();
		// Decode memarg
		var memarg = codeptr.read_MemArg();
		var memory = frame.func.instance.memories[memarg.memory_index];
		var index = popm(memory);
		// Decode immediate
		var idx = codeptr.read1();
		// Extract lane
		var low = v.0, high = v.1;
		var val: T;
		def half_lanes = 8 >> log2_size;
		if (idx < half_lanes) { // Extract a lane from low
			var shift = u6.view(idx << u3.+(log2_size, 3));
			val = view(low >> shift);
		} else { // Extract a lane from high
			var shift = u6.view((idx - half_lanes) << u3.+(log2_size, 3));
			val = view(high >> shift);
		}
		// Write to memory
		var t = memory.range_oil_64(memarg.offset, index, size);
		if (t.reason != TrapReason.NONE) trap(t.reason);
		else write(t.result, val);
	}
	def doFallthru() {
		frame.stp += 4;
	}
	def doBranch(pc: int, cond: bool) -> bool {
		if (cond) {
			codeptr.at(doGoto(pc));
		} else {
			codeptr.skip_label();
			doFallthru();
		}
		return cond;
	}
	def doGoto(pc: int) -> int {
		var stp = frame.stp, sidetable = frame.func.decl.sidetable;
		return doCtlXfer(pc, stp, sidetable);
	}
	def doSwitch(pc: int, key: u32) -> int {
		var stp = frame.stp, sidetable = frame.func.decl.sidetable;
		var max = sidetable.entries[stp];
		var index = if(key >= max, max, 1 + int.!(key));
		stp += index << 2;
		pc += index;
		return doCtlXfer(pc, stp, sidetable);
	}
	def doCtlXfer(pc: int, stp: int, sidetable: Sidetable) -> int {
		var e = sidetable.getBrEntry(stp);
		frame.stp = stp + e.dstp;
		if (e.popcount > 0) {
			copyVals(e.valcount, values.top - int.!(e.popcount + e.valcount));
		}
		return pc + e.dpc;
	}
	def advanceCaller() {
		if (Debug.interpreter) Trace.OUT.put3("advance %q pc=%d codeptr.pos=%d", frame.func.render, frame.pc, codeptr.pos).ln();
		// XXX: use read_opcode_and_skip()
		var opcode = codeptr.read_opcode_but_skip_probe(frame.func.decl);
		match (opcode) {
			CALL, CALL_REF => {
				codeptr.skip_leb();
				frame.pc = codeptr.pos;
			}
			CALL_INDIRECT => {
				codeptr.skip_leb();
				codeptr.skip_leb();
				frame.pc = codeptr.pos;
			}
			_ => {
				fail(Strings.format1("expected call instruction in return, got %s", opcode.name));
			}
		}
	}
	def prepareReturnCall(sig: SigDecl) {
		copyVals(sig.params.length, frame.fp);
		frame = popFrame();
	}
	def lookupIndirect(sig_index: u32, table_index: u32, func_index: u32) -> Function {
		var instance = frame.func.instance;
		var table = instance.tables[table_index];
		if (func_index >= table.elems.length) {
			trap(TrapReason.FUNC_INVALID);
			return null;
		}
		var expected = SigDecl.!(instance.heaptypes[sig_index]);
		var f = table.funcs[func_index];
		if (f == null) { trap(TrapReason.FUNC_INVALID); return null; }
		if (!ValueTypes.isAssignableHeap(f.sig, expected)) { trap(TrapReason.FUNC_SIG_MISMATCH); return null; }
		return f;
	}
	def onChildTerminate(vals: Array<Value>) {
		if (Trace.stack) Trace.OUT.put2("onChildTerminate prev_resume_pc=%d pc=%d", prev_resume_pc, frame.pc).ln();
		values.pusha(vals);
		state_ = StackState.RESUMABLE;
		// advance past resume instruction
		var code = frame.func.decl.cur_bytecode;
		codeptr.reset(code, frame.pc, code.length);
		var opcode = codeptr.read_opcode_and_skip(frame.func.decl);
		// advance past resume sidetable entries
		// XXX: do not use sidetable for this
		var entry = frame.func.decl.sidetable.getResumeEntry(frame.stp);
		frame.stp += Sidetable_ResumeEntry.size / 4;
		frame.stp += entry.nhandlers * Sidetable_SuspendHandlerEntry.size / 4;
		match (opcode) {
			RESUME, RESUME_THROW => ;
			_ => fail(Strings.format1("expected resume instruction in child terminate, got %s", opcode.name));
		}
	}
	// Returns whether the suspend got handled.
	def tryHandleSuspend(cont: Continuation, tag: Tag, vals: Array<Value>) -> bool {
		var handler = frame.func.decl.findResumeHandler(frame.func.instance, tag, prev_resume_pc);
		if (handler.handler_pc < 0) return false;

		prev_resume_pc = -1;
		values.top = frame.fp + handler.val_stack_top + frame.func.decl.num_locals;
		values.pusha(vals);
		values.push(Value.Ref(cont));

		var code = frame.func.decl.cur_bytecode;
		frame.pc = handler.handler_pc;
		frame.stp = handler.sidetable_pos;
		codeptr.reset(code, frame.pc, code.length);

		state_ = StackState.RESUMABLE;
		return true;
	}
	def onChildThrow(t: Throwable) -> Throwable {
		state_ = StackState.RESUMABLE;
		return throw(t);
	}
	def throw(t: Throwable) -> Throwable {
		if (Exception.?(t)) {
			var ex = Exception.!(t);
			for (f = frame; f != null && f.func != null; f = f.prev) {
				var at = if(prev_resume_pc != -1, prev_resume_pc, f.pc);
				prev_resume_pc = -1;
				var handler = f.func.decl.findExHandler(f.func.instance, ex.tag, at);
				if (handler.handler_pc >= 0) {
					frame = f;
					var code = f.func.decl.cur_bytecode;
					f.pc = handler.handler_pc;
					f.stp = handler.sidetable_pos;
					codeptr.reset(code, f.pc, code.length);
					// TODO: clean up frame math here
					values.top = f.fp + handler.val_stack_top + f.func.decl.num_locals + f.func.decl.num_ex_slots;
					for (v in ex.vals) values.push(v);
					if (handler.ex_slot >= 0) {
						if (Trace.exception) Trace.OUT.put2("  set_ex_slot fp=%d, ex_slot=%d", f.fp, handler.ex_slot).ln();
						values.elems[f.fp + f.func.decl.num_locals + handler.ex_slot] = Value.Ref(ex);
					}
					if (handler.push_exnref) {
						if (Trace.exception) Trace.OUT.puts("  push_exnref").ln();
						values.push(Value.Ref(ex));
					}
					frame = f;
					return null;
				}
			}
		}
		var segment = popAllFrames(true);
		if (segment != null) t = t.prependFrames(segment.frames).prependHostFunction(segment.host);
		state_ = StackState.THROWING;
		return thrown = t; // unhandled exception
	}
	def trap(reason: TrapReason) -> Throwable {
		var stacktrace = popAllFrames(true);
		thrown = Trap.new(reason, null, stacktrace);
		state_ = StackState.THROWING;
		return thrown;
	}
	def fail(msg: string) {
		var stacktrace = popAllFrames(true);
		thrown = InternalError.new(msg, stacktrace);
		state_ = StackState.THROWING;
	}
	def pop() -> Value { return values.pop(); }
	def popV(t: ValueType) -> Value { return values.pop(); }
	def popi() -> i32 { return Values.unbox_i(values.pop()); }
	def popu() -> u32 { return Values.unbox_u(values.pop()); }
	def popl() -> i64 { return Values.unbox_l(values.pop()); }
	def popw() -> u64 { return Values.unbox_w(values.pop()); }
	def popf() -> float { return Values.unbox_f(values.pop()); }
	def popd() -> double { return Values.unbox_d(values.pop()); }
	def pops() -> (u64, u64) { return Values.unbox_s(values.pop()); }
	def popr() -> Value.Ref { return Value.Ref.!(values.pop()); } // TODO: i31
	def popObject() -> Object { return Value.Ref.!(values.pop()).val; }
	def push(val: Value) { values.push(val); }
	def pushi(val: i32) { values.push(Value.I32(u32.view(val))); }
	def pushu(val: u32) { values.push(Value.I32(val)); }
	def pushl(val: i64) { values.push(Value.I64(u64.view(val))); }
	def pushw(val: u64) { values.push(Value.I64(val)); }
	def pushf(val: float) { values.push(Value.F32(u32.view(val))); }
	def pushd(val: double) { values.push(Value.F64(u64.view(val))); }
	def pushz(val: bool) { values.push(if(val, Values.I32_1, Values.I32_0)); }
	def popN(count: int) -> Array<Value> {
		var result = Array<Value>.new(count);
		var sp = values.top - count;
		for (i < count) result[i] = values.elems[sp + i];
		values.top = sp;
		return result;
	}
	def traceStep() { // XXX: make this a debug method
		var OUT = Trace.OUT;
		for (i < frame.depth) OUT.sp();
		OUT.put1("+%d: ", codeptr.pos);  // XXX: fixed width decimal offset
		var module = if(frame.func.instance != null, frame.func.instance.module);
		var opcode = codeptr.data[codeptr.pos];
		if (instrTracer == null) instrTracer = InstrTracer.new();
		if (opcode == InternalOpcode.PROBE.code) {
			OUT.puts("<probe> ");
			var prev = (codeptr.data, codeptr.pos, codeptr.limit);
			codeptr.reset(frame.func.decl.orig_bytecode, prev.1, prev.2);
			instrTracer.putInstr(OUT, module, codeptr);
			codeptr.reset(prev.0, prev.1, prev.2);
		} else {
			instrTracer.putInstr(OUT, module, codeptr);
		}
		if (Trace.operands) {
			var locals_end = frame.fp + frame.func.decl.num_locals - 1;
			for (i = frame.fp; i < values.top; i++) {
				var v = values.elems[i];
				OUT.putv(v).sp();
				if (i == locals_end) OUT.puts(" | ");
			}
		}
		OUT.ln();
	}
	// XXX: reduce duplication of d_xx_x methods
	def do_dd_d(f: (double, double) -> double) {
		var y = Values.unbox_d(values.elems[values.top-1]);
		var x = Values.unbox_d(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.F64(u64.view(r));
		values.top--;
	}
	def do_ff_f(f: (float, float) -> float) {
		var y = Values.unbox_f(values.elems[values.top-1]);
		var x = Values.unbox_f(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.F32(u32.view(r));
		values.top--;
	}
	def do_dd_z(f: (double, double) -> bool) {
		var y = Values.unbox_d(values.elems[values.top-1]);
		var x = Values.unbox_d(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ff_z(f: (float, float) -> bool) {
		var y = Values.unbox_f(values.elems[values.top-1]);
		var x = Values.unbox_f(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ii_i(f: (i32, i32) -> i32) {
		var y = Values.unbox_i(values.elems[values.top-1]);
		var x = Values.unbox_i(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I32(u32.view(r));
		values.top--;
	}
	def do_uu_u(f: (u32, u32) -> u32) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I32(r);
		values.top--;
	}
	def do_uu_ut(f: (u32, u32) -> (u32, TrapReason)) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I32(r.0);
		values.top--;
	}
	def do_ii_it(f: (i32, i32) -> (i32, TrapReason)) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(i32.view(x), i32.view(y));
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I32(u32.view(r.0));
		values.top--;
	}
	def do_u_u(f: u32 -> u32) {
		var x = Values.unbox_u(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.I32(r);
	}
	def do_ii_z(f: (i32, i32) -> bool) {
		var y = Values.unbox_i(values.elems[values.top-1]);
		var x = Values.unbox_i(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_uu_z(f: (u32, u32) -> bool) {
		var y = Values.unbox_u(values.elems[values.top-1]);
		var x = Values.unbox_u(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ll_l(f: (i64, i64) -> i64) {
		var y = Values.unbox_l(values.elems[values.top-1]);
		var x = Values.unbox_l(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I64(u64.view(r));
		values.top--;
	}
	def do_ll_lt(f: (i64, i64) -> (i64, TrapReason)) {
		var y = Values.unbox_l(values.elems[values.top-1]);
		var x = Values.unbox_l(values.elems[values.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I64(u64.view(r.0));
		values.top--;
	}
	def do_ww_w(f: (u64, u64) -> u64) {
		var y = Values.unbox_w(values.elems[values.top-1]);
		var x = Values.unbox_w(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.I64(r);
		values.top--;
	}
	def do_ww_wt(f: (u64, u64) -> (u64, TrapReason)) {
		var y = Values.unbox_w(values.elems[values.top-1]);
		var x = Values.unbox_w(values.elems[values.top-2]);
		var r = f(x, y);
		if (r.1 != TrapReason.NONE) return void(trap(r.1));
		values.elems[values.top-2] = Value.I64(r.0);
		values.top--;
	}
	def do_w_w(f: u64 -> u64) {
		var x = Values.unbox_w(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.I64(r);
	}
	def do_ll_z(f: (i64, i64) -> bool) {
		var y = Values.unbox_l(values.elems[values.top-1]);
		var x = Values.unbox_l(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_ww_z(f: (u64, u64) -> bool) {
		var y = Values.unbox_w(values.elems[values.top-1]);
		var x = Values.unbox_w(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = if(r, Values.I32_1, Values.I32_0);
		values.top--;
	}
	def do_s_s(f: (u64, u64) -> (u64, u64)) {
		var x = Values.unbox_s(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.V128(r.0, r.1);
	}
	def do_ss_s(f: ((u64, u64), (u64, u64)) -> (u64, u64)) {
		var y = Values.unbox_s(values.elems[values.top-1]);
		var x = Values.unbox_s(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.V128(r.0, r.1);
		values.top--;
	}
	def do_si_s(f: ((u64, u64), i32) -> (u64, u64)) {
		var y = Values.unbox_i(values.elems[values.top-1]);
		var x = Values.unbox_s(values.elems[values.top-2]);
		var r = f(x, y);
		values.elems[values.top-2] = Value.V128(r.0, r.1);
		values.top--;
	}
	def do_sss_s(f: ((u64, u64), (u64, u64), (u64, u64)) -> (u64, u64)) {
		var z = Values.unbox_s(values.elems[values.top-1]);
		var y = Values.unbox_s(values.elems[values.top-2]);
		var x = Values.unbox_s(values.elems[values.top-3]);
		var r = f(x, y, z);
		values.elems[values.top-3] = Value.V128(r.0, r.1);
		values.top -= 2;
	}
	def do_s_z(f: (u64, u64) -> bool) {
		var x = Values.unbox_s(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = if(r, Values.I32_1, Values.I32_0);
	}
	def do_s_i(f: (u64, u64) -> i32) {
		var x = Values.unbox_s(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.I32(u32.view(r));
	}
	def do_f_f(f: float -> float) {
		var x = Values.unbox_f(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.F32(u32.view(r));
	}
	def do_d_d(f: double -> double) {
		var x = Values.unbox_d(values.elems[values.top-1]);
		var r = f(x);
		values.elems[values.top-1] = Value.F64(u64.view(r));
	}
	def traceStack() {
		var out = Trace.OUT;
		var last_fp = values.top;
		for (f = frame; f != null; f = f.prev) {
			out.puts("  ===={ ");
			f.func.render(out);
			out.put1(" @ %d }====", f.pc).ln();
			var num_locals = f.func.decl.num_locals;
			var num_params = f.func.sig.params.length;
			for (i = last_fp - 1; i >= f.fp; i--) {
				var index = i - f.fp;
				if (index == (num_locals - 1)) out.put1("  ----- locals = %d -----", f.func.decl.num_locals).ln();
				if (index < num_locals) out.puts("  ").mark().putd(index).rjustify_mark(5).puts(" | ");
				else out.puts("        | ");
				Values.render(values.elems[i], out);
				out.ln();
			}
			out.ln();
			last_fp = f.fp;
		}
	}
}

class V3Frame {
	// state for managing the doubly-linked list
	def stack: V3Interpreter;
	def prev: V3Frame;
	def depth: int = if(prev != null, 1 + prev.depth);
	def var next: V3Frame;

	// state for the current activation
	var func: WasmFunction;		// wasm function
	var fp: int;			// frame pointer; i.e. base of locals
	var pc: int;			// program counter
	var stp: int;			// sidetable pointer
	var accessor: V3FrameAccessor;	// accessor, if any

	new(stack, prev) {
		if (prev != null) prev.next = this;
	}
}

private class V3HostFrame(prev: V3Frame) extends HostFrame {
	def caller() -> FrameLoc {
		return if(prev != null, FrameLoc.Wasm(prev.func, prev.pc, TargetFrame(prev)));
	}
}

class V3FrameAccessor(frame: V3Frame) extends FrameAccessor {
	var writer: V3FrameWriter;

	// Returns {true} if this frame has been unwound, either due to returning, a trap, or exception.
	def isUnwound() -> bool {
		return frame.accessor != this;
	}
	// Returns the Wasm function in this frame.
	def func() -> WasmFunction {
		checkNotUnwound();
		return frame.func;
	}
	// Returns the current program counter.
	def pc() -> int {
		checkNotUnwound();
		return frame.pc;
	}
	// Returns {true} if this frame is currently the top executing frame, {false} if the
	// frame has called another function or been unwound.
	private def isTop() -> bool {
		return if(!isUnwound(), frame.stack.frame == frame);
	}
	// Returns the call depth of this frame within its segment, with the bottom frame being #0.
	def depth() -> int {
		return frame.depth;
	}
	// Get the caller frame, either a wasm or host function. If none, then {Frame.func} will be {null}.
	def caller() -> FrameLoc {
		checkNotUnwound();
		var p = frame.prev;
		if (p == null) return FrameLoc.None;
		return FrameLoc.Wasm(p.func, p.pc, TargetFrame(p));
	}
	// Returns the current program counter.
	def stp() -> int {
		checkNotUnwound();
		return frame.stp;
	}
	// Get the number of local variables in this frame.
	def numLocals() -> int {
		checkNotUnwound();
		return frame.func.decl.num_locals;
	}
	// Get the value of local variable {i}.
	def getLocal(i: int) -> Value {
		checkNotUnwound();
		if (u32.view(i) >= frame.func.decl.num_locals) fatal("local index out-of-bounds");
		return frame.stack.values.elems[frame.fp + i];
	}
	// Get the number of operand stack elements.
	def numOperands() -> int {
		checkNotUnwound();
		if (!isTop()) fatal("numOperands only supported for top frame"); // TODO
		return frame.stack.values.top - (frame.fp + frame.func.decl.num_locals);
	}
	// Get operand at depth {i}, with 0 being the top of the stack, -1 being one lower, etc.
	def getOperand(i: int) -> Value {
		checkNotUnwound();
		if (!isTop()) fatal("numOperands only supported for top frame"); // TODO
		return frame.stack.values.elems[frame.stack.values.top + i - 1]; // TODO: bounds check
	}
	// Get the frame writer.
	def getWriter() -> V3FrameWriter {
		return if(writer != null, writer, writer = V3FrameWriter.new(this));
	}

	private def checkNotUnwound() {
		if (isUnwound()) fatal("frame has been unwound");
	}
}

private class V3FrameWriter extends FrameWriter {
	private def accessor: V3FrameAccessor;

	new(accessor) { }

	// Set the value of a local variable. (dynamically typechecked).
	def setLocal(i: int, v: Value) {
		// TODO: dynamically typecheck
		accessor.checkNotUnwound();
		if (u32.view(i) >= accessor.frame.func.decl.num_locals) fatal("local index out-of-bounds");
		accessor.frame.stack.values.elems[accessor.frame.fp + i] = v;
	}
}
def fatal = System.error("V3InterpreterError", _);
