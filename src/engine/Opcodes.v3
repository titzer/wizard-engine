// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def sig: SigCache;
def sig_v_v = SigCache.v_v; // XXX: needed to force initialization
def imm: ImmSigs;
// An enumeration of the WebAssembly opcodes, including their mnenomic names,
// the kind of immediate expected, and the (monomorphic) operator signature.
enum Opcode(prefix: u8, code: u8, mnemonic: string, imms: Array<ImmKind>, sig: SigDecl) {
	// Default, invalid opcode.
	INVALID			(0x00, 0xFF, "<invalid>", imm.NONE, null),
	// Wizard-specific opcode to induce a VM-level crash when executed.
	CRASH_EXEC		(0x00, 0xF0, "<crash-execution>", imm.NONE, null),
	// Wizard-specific opcode to induce a VM-level crash when compiled.
	CRASH_COMPILER		(0x00, 0xF1, "<crash-compiler>", imm.NONE, null),
	// Control and calls.
	UNREACHABLE		(0x00, 0x00, "unreachable", imm.NONE, null),
	NOP			(0x00, 0x01, "nop", imm.NONE, sig.v_v),
	BLOCK			(0x00, 0x02, "block", imm.BLOCKT, null),
	LOOP			(0x00, 0x03, "loop", imm.BLOCKT, null),
	IF			(0x00, 0x04, "if", imm.BLOCKT, null),
	ELSE			(0x00, 0x05, "else", imm.NONE, null),
	TRY			(0x00, 0x06, "try", imm.BLOCKT, null),
	CATCH			(0x00, 0x07, "catch", imm.TAG, null),
	THROW			(0x00, 0x08, "throw", imm.TAG, null),
	RETHROW			(0x00, 0x09, "rethrow", imm.LABEL, null),
	THROW_REF		(0x00, 0x0A, "throw_ref", imm.NONE, null),
	END			(0x00, 0x0B, "end", imm.NONE, null),
	BR			(0x00, 0x0C, "br", imm.LABEL, null),
	BR_IF			(0x00, 0x0D, "br_if", imm.LABEL, null),
	BR_TABLE		(0x00, 0x0E, "br_table", imm.LABELS, null),
	RETURN			(0x00, 0x0F, "return", imm.NONE, null),
	CALL			(0x00, 0x10, "call", imm.FUNC, null),
	CALL_INDIRECT		(0x00, 0x11, "call_indirect", imm.SIG_TABLE, null),
	RETURN_CALL		(0x00, 0x12, "return_call", imm.FUNC, null),
	RETURN_CALL_INDIRECT	(0x00, 0x13, "return_call_indirect", imm.SIG_TABLE, null),
	CALL_REF		(0x00, 0x14, "call_ref", imm.SIG, null),
	RETURN_CALL_REF		(0x00, 0x15, "return_call_ref", imm.SIG, null),
	DELEGATE		(0x00, 0x18, "delegate", imm.LABEL, null),
	CATCH_ALL		(0x00, 0x19, "catch_all", imm.NONE, null),
	DROP			(0x00, 0x1A, "drop", imm.NONE, null),
	SELECT			(0x00, 0x1B, "select", imm.NONE, null),
	SELECT_T		(0x00, 0x1C, "select", imm.VALTS, null),
	TRY_TABLE		(0x00, 0x1F, "try_table", imm.BLOCKT_CATCHES, null),
	// Locals.
	LOCAL_GET		(0x00, 0x20, "local.get", imm.LOCAL, null),
	LOCAL_SET		(0x00, 0x21, "local.set", imm.LOCAL, null),
	LOCAL_TEE		(0x00, 0x22, "local.tee", imm.LOCAL, null),
	// Globals.
	GLOBAL_GET		(0x00, 0x23, "global.get", imm.GLOBAL, null),
	GLOBAL_SET		(0x00, 0x24, "global.set", imm.GLOBAL, null),
	// Table elems.
	TABLE_GET		(0x00, 0x25, "table.get", imm.TABLE, null),
	TABLE_SET		(0x00, 0x26, "table.set", imm.TABLE, null),
	// Loads and stores.
	I32_LOAD		(0x00, 0x28, "i32.load", imm.MEMARG, sig.i_i),
	I64_LOAD		(0x00, 0x29, "i64.load", imm.MEMARG, sig.i_l),
	F32_LOAD		(0x00, 0x2A, "f32.load", imm.MEMARG, sig.i_f),
	F64_LOAD		(0x00, 0x2B, "f64.load", imm.MEMARG, sig.i_d),
	I32_LOAD8_S		(0x00, 0x2C, "i32.load8_s", imm.MEMARG, sig.i_i),
	I32_LOAD8_U		(0x00, 0x2D, "i32.load8_u", imm.MEMARG, sig.i_i),
	I32_LOAD16_S		(0x00, 0x2E, "i32.load16_s", imm.MEMARG, sig.i_i),
	I32_LOAD16_U		(0x00, 0x2F, "i32.load16_u", imm.MEMARG, sig.i_i),
	I64_LOAD8_S		(0x00, 0x30, "i64.load8_s", imm.MEMARG, sig.i_l),
	I64_LOAD8_U		(0x00, 0x31, "i64.load8_u", imm.MEMARG, sig.i_l),
	I64_LOAD16_S		(0x00, 0x32, "i64.load16_s", imm.MEMARG, sig.i_l),
	I64_LOAD16_U		(0x00, 0x33, "i64.load16_u", imm.MEMARG, sig.i_l),
	I64_LOAD32_S		(0x00, 0x34, "i64.load32_s", imm.MEMARG, sig.i_l),
	I64_LOAD32_U		(0x00, 0x35, "i64.load32_u", imm.MEMARG, sig.i_l),
	I32_STORE		(0x00, 0x36, "i32.store", imm.MEMARG, sig.ii_v),
	I64_STORE		(0x00, 0x37, "i64.store", imm.MEMARG, sig.il_v),
	F32_STORE		(0x00, 0x38, "f32.store", imm.MEMARG, sig.if_v),
	F64_STORE		(0x00, 0x39, "f64.store", imm.MEMARG, sig.id_v),
	I32_STORE8		(0x00, 0x3A, "i32.store8", imm.MEMARG, sig.ii_v),
	I32_STORE16		(0x00, 0x3B, "i32.store16", imm.MEMARG, sig.ii_v),
	I64_STORE8		(0x00, 0x3C, "i64.store8", imm.MEMARG, sig.il_v),
	I64_STORE16		(0x00, 0x3D, "i64.store16", imm.MEMARG, sig.il_v),
	I64_STORE32		(0x00, 0x3E, "i64.store32", imm.MEMARG, sig.il_v),
	// Misc memory.
	MEMORY_SIZE		(0x00, 0x3F, "memory.size", imm.MEMORY, sig.v_i),
	MEMORY_GROW		(0x00, 0x40, "memory.grow", imm.MEMORY, sig.i_i),
	// Constants.
	I32_CONST		(0x00, 0x41, "i32.const", imm.I32, sig.v_i),
	I64_CONST		(0x00, 0x42, "i64.const", imm.I64, sig.v_l),
	F32_CONST		(0x00, 0x43, "f32.const", imm.F32, sig.v_f),
	F64_CONST		(0x00, 0x44, "f64.const", imm.F64, sig.v_d),
	// Comparisons.
	I32_EQZ			(0x00, 0x45, "i32.eqz", imm.NONE, sig.i_i),
	I32_EQ			(0x00, 0x46, "i32.eq", imm.NONE, sig.ii_i),
	I32_NE			(0x00, 0x47, "i32.ne", imm.NONE, sig.ii_i),
	I32_LT_S		(0x00, 0x48, "i32.lt_s", imm.NONE, sig.ii_i),
	I32_LT_U		(0x00, 0x49, "i32.lt_u", imm.NONE, sig.ii_i),
	I32_GT_S		(0x00, 0x4A, "i32.gt_s", imm.NONE, sig.ii_i),
	I32_GT_U		(0x00, 0x4B, "i32.gt_u", imm.NONE, sig.ii_i),
	I32_LE_S		(0x00, 0x4C, "i32.le_s", imm.NONE, sig.ii_i),
	I32_LE_U		(0x00, 0x4D, "i32.le_u", imm.NONE, sig.ii_i),
	I32_GE_S		(0x00, 0x4E, "i32.ge_s", imm.NONE, sig.ii_i),
	I32_GE_U		(0x00, 0x4F, "i32.ge_u", imm.NONE, sig.ii_i),
	I64_EQZ			(0x00, 0x50, "i64.eqz", imm.NONE, sig.l_i),
	I64_EQ			(0x00, 0x51, "i64.eq", imm.NONE, sig.ll_i),
	I64_NE			(0x00, 0x52, "i64.ne", imm.NONE, sig.ll_i),
	I64_LT_S		(0x00, 0x53, "i64.lt_s", imm.NONE, sig.ll_i),
	I64_LT_U		(0x00, 0x54, "i64.lt_u", imm.NONE, sig.ll_i),
	I64_GT_S		(0x00, 0x55, "i64.gt_s", imm.NONE, sig.ll_i),
	I64_GT_U		(0x00, 0x56, "i64.gt_u", imm.NONE, sig.ll_i),
	I64_LE_S		(0x00, 0x57, "i64.le_s", imm.NONE, sig.ll_i),
	I64_LE_U		(0x00, 0x58, "i64.le_u", imm.NONE, sig.ll_i),
	I64_GE_S		(0x00, 0x59, "i64.ge_s", imm.NONE, sig.ll_i),
	I64_GE_U		(0x00, 0x5A, "i64.ge_u", imm.NONE, sig.ll_i),
	F32_EQ			(0x00, 0x5B, "f32.eq", imm.NONE, sig.ff_i),
	F32_NE			(0x00, 0x5C, "f32.ne", imm.NONE, sig.ff_i),
	F32_LT			(0x00, 0x5D, "f32.lt", imm.NONE, sig.ff_i),
	F32_GT			(0x00, 0x5E, "f32.gt", imm.NONE, sig.ff_i),
	F32_LE			(0x00, 0x5F, "f32.le", imm.NONE, sig.ff_i),
	F32_GE			(0x00, 0x60, "f32.ge", imm.NONE, sig.ff_i),
	F64_EQ			(0x00, 0x61, "f64.eq", imm.NONE, sig.dd_i),
	F64_NE			(0x00, 0x62, "f64.ne", imm.NONE, sig.dd_i),
	F64_LT			(0x00, 0x63, "f64.lt", imm.NONE, sig.dd_i),
	F64_GT			(0x00, 0x64, "f64.gt", imm.NONE, sig.dd_i),
	F64_LE			(0x00, 0x65, "f64.le", imm.NONE, sig.dd_i),
	F64_GE			(0x00, 0x66, "f64.ge", imm.NONE, sig.dd_i),
	// I32 arithmetic.
	I32_CLZ			(0x00, 0x67, "i32.clz", imm.NONE, sig.i_i),
	I32_CTZ			(0x00, 0x68, "i32.ctz", imm.NONE, sig.i_i),
	I32_POPCNT		(0x00, 0x69, "i32.popcnt", imm.NONE, sig.i_i),
	I32_ADD			(0x00, 0x6A, "i32.add", imm.NONE, sig.ii_i),
	I32_SUB			(0x00, 0x6B, "i32.sub", imm.NONE, sig.ii_i),
	I32_MUL			(0x00, 0x6C, "i32.mul", imm.NONE, sig.ii_i),
	I32_DIV_S		(0x00, 0x6D, "i32.div_s", imm.NONE, sig.ii_i),
	I32_DIV_U		(0x00, 0x6E, "i32.div_u", imm.NONE, sig.ii_i),
	I32_REM_S		(0x00, 0x6F, "i32.rem_s", imm.NONE, sig.ii_i),
	I32_REM_U		(0x00, 0x70, "i32.rem_u", imm.NONE, sig.ii_i),
	I32_AND			(0x00, 0x71, "i32.and", imm.NONE, sig.ii_i),
	I32_OR			(0x00, 0x72, "i32.or", imm.NONE, sig.ii_i),
	I32_XOR			(0x00, 0x73, "i32.xor", imm.NONE, sig.ii_i),
	I32_SHL			(0x00, 0x74, "i32.shl", imm.NONE, sig.ii_i),
	I32_SHR_S		(0x00, 0x75, "i32.shr_s", imm.NONE, sig.ii_i),
	I32_SHR_U		(0x00, 0x76, "i32.shr_u", imm.NONE, sig.ii_i),
	I32_ROTL		(0x00, 0x77, "i32.rotl", imm.NONE, sig.ii_i),
	I32_ROTR		(0x00, 0x78, "i32.rotr", imm.NONE, sig.ii_i),
	// I64 arithmetic.
	I64_CLZ			(0x00, 0x79, "i64.clz", imm.NONE, sig.l_l),
	I64_CTZ			(0x00, 0x7A, "i64.ctz", imm.NONE, sig.l_l),
	I64_POPCNT		(0x00, 0x7B, "i64.popcnt", imm.NONE, sig.l_l),
	I64_ADD			(0x00, 0x7C, "i64.add", imm.NONE, sig.ll_l),
	I64_SUB			(0x00, 0x7D, "i64.sub", imm.NONE, sig.ll_l),
	I64_MUL			(0x00, 0x7E, "i64.mul", imm.NONE, sig.ll_l),
	I64_DIV_S		(0x00, 0x7F, "i64.div_s", imm.NONE, sig.ll_l),
	I64_DIV_U		(0x00, 0x80, "i64.div_u", imm.NONE, sig.ll_l),
	I64_REM_S		(0x00, 0x81, "i64.rem_s", imm.NONE, sig.ll_l),
	I64_REM_U		(0x00, 0x82, "i64.rem_u", imm.NONE, sig.ll_l),
	I64_AND			(0x00, 0x83, "i64.and", imm.NONE, sig.ll_l),
	I64_OR			(0x00, 0x84, "i64.or", imm.NONE, sig.ll_l),
	I64_XOR			(0x00, 0x85, "i64.xor", imm.NONE, sig.ll_l),
	I64_SHL			(0x00, 0x86, "i64.shl", imm.NONE, sig.ll_l),
	I64_SHR_S		(0x00, 0x87, "i64.shr_s", imm.NONE, sig.ll_l),
	I64_SHR_U		(0x00, 0x88, "i64.shr_u", imm.NONE, sig.ll_l),
	I64_ROTL		(0x00, 0x89, "i64.rotl", imm.NONE, sig.ll_l),
	I64_ROTR		(0x00, 0x8A, "i64.rotr", imm.NONE, sig.ll_l),
	// F32 arithmetic.
	F32_ABS			(0x00, 0x8B, "f32.abs", imm.NONE, sig.f_f),
	F32_NEG			(0x00, 0x8C, "f32.neg", imm.NONE, sig.f_f),
	F32_CEIL		(0x00, 0x8D, "f32.ceil", imm.NONE, sig.f_f),
	F32_FLOOR		(0x00, 0x8E, "f32.floor", imm.NONE, sig.f_f),
	F32_TRUNC		(0x00, 0x8F, "f32.trunc", imm.NONE, sig.f_f),
	F32_NEAREST		(0x00, 0x90, "f32.nearest", imm.NONE, sig.f_f),
	F32_SQRT		(0x00, 0x91, "f32.sqrt", imm.NONE, sig.f_f),
	F32_ADD			(0x00, 0x92, "f32.add", imm.NONE, sig.ff_f),
	F32_SUB			(0x00, 0x93, "f32.sub", imm.NONE, sig.ff_f),
	F32_MUL			(0x00, 0x94, "f32.mul", imm.NONE, sig.ff_f),
	F32_DIV			(0x00, 0x95, "f32.div", imm.NONE, sig.ff_f),
	F32_MIN			(0x00, 0x96, "f32.min", imm.NONE, sig.ff_f),
	F32_MAX			(0x00, 0x97, "f32.max", imm.NONE, sig.ff_f),
	F32_COPYSIGN		(0x00, 0x98, "f32.copysign", imm.NONE, sig.ff_f),
	// F64 arithmetic.
	F64_ABS			(0x00, 0x99, "f64.abs", imm.NONE, sig.d_d),
	F64_NEG			(0x00, 0x9A, "f64.neg", imm.NONE, sig.d_d),
	F64_CEIL		(0x00, 0x9B, "f64.ceil", imm.NONE, sig.d_d),
	F64_FLOOR		(0x00, 0x9C, "f64.floor", imm.NONE, sig.d_d),
	F64_TRUNC		(0x00, 0x9D, "f64.trunc", imm.NONE, sig.d_d),
	F64_NEAREST		(0x00, 0x9E, "f64.nearest", imm.NONE, sig.d_d),
	F64_SQRT		(0x00, 0x9F, "f64.sqrt", imm.NONE, sig.d_d),
	F64_ADD			(0x00, 0xA0, "f64.add", imm.NONE, sig.dd_d),
	F64_SUB			(0x00, 0xA1, "f64.sub", imm.NONE, sig.dd_d),
	F64_MUL			(0x00, 0xA2, "f64.mul", imm.NONE, sig.dd_d),
	F64_DIV			(0x00, 0xA3, "f64.div", imm.NONE, sig.dd_d),
	F64_MIN			(0x00, 0xA4, "f64.min", imm.NONE, sig.dd_d),
	F64_MAX			(0x00, 0xA5, "f64.max", imm.NONE, sig.dd_d),
	F64_COPYSIGN		(0x00, 0xA6, "f64.copysign", imm.NONE, sig.dd_d),
	// Conversions and casts.
	I32_WRAP_I64		(0x00, 0xA7, "i32.wrap_i64", imm.NONE, sig.l_i),
	I32_TRUNC_F32_S		(0x00, 0xA8, "i32.trunc_f32_s", imm.NONE, sig.f_i),
	I32_TRUNC_F32_U		(0x00, 0xA9, "i32.trunc_f32_u", imm.NONE, sig.f_i),
	I32_TRUNC_F64_S		(0x00, 0xAA, "i32.trunc_f64_s", imm.NONE, sig.d_i),
	I32_TRUNC_F64_U		(0x00, 0xAB, "i32.trunc_f64_u", imm.NONE, sig.d_i),
	I64_EXTEND_I32_S	(0x00, 0xAC, "i64.extend_i32_s", imm.NONE, sig.i_l),
	I64_EXTEND_I32_U	(0x00, 0xAD, "i64.extend_i32_u", imm.NONE, sig.i_l),
	I64_TRUNC_F32_S		(0x00, 0xAE, "i64.trunc_f32_s", imm.NONE, sig.f_l),
	I64_TRUNC_F32_U		(0x00, 0xAF, "i64.trunc_f32_u", imm.NONE, sig.f_l),
	I64_TRUNC_F64_S		(0x00, 0xB0, "i64.trunc_f64_s", imm.NONE, sig.d_l),
	I64_TRUNC_F64_U		(0x00, 0xB1, "i64.trunc_f64_u", imm.NONE, sig.d_l),
	F32_CONVERT_I32_S	(0x00, 0xB2, "f32.convert_i32_s", imm.NONE, sig.i_f),
	F32_CONVERT_I32_U	(0x00, 0xB3, "f32.convert_i32_u", imm.NONE, sig.i_f),
	F32_CONVERT_I64_S	(0x00, 0xB4, "f32.convert_i64_s", imm.NONE, sig.l_f),
	F32_CONVERT_I64_U	(0x00, 0xB5, "f32.convert_i64_u", imm.NONE, sig.l_f),
	F32_DEMOTE_F64		(0x00, 0xB6, "f32.demote_f64", imm.NONE, sig.d_f),
	F64_CONVERT_I32_S	(0x00, 0xB7, "f64.convert_i32_s", imm.NONE, sig.i_d),
	F64_CONVERT_I32_U	(0x00, 0xB8, "f64.convert_i32_u", imm.NONE, sig.i_d),
	F64_CONVERT_I64_S	(0x00, 0xB9, "f64.convert_i64_s", imm.NONE, sig.l_d),
	F64_CONVERT_I64_U	(0x00, 0xBA, "f64.convert_i64_u", imm.NONE, sig.l_d),
	F64_PROMOTE_F32		(0x00, 0xBB, "f64.promote_f32", imm.NONE, sig.f_d),
	I32_REINTERPRET_F32	(0x00, 0xBC, "i32.reinterpret_f32", imm.NONE, sig.f_i),
	I64_REINTERPRET_F64	(0x00, 0xBD, "i64.reinterpret_f64", imm.NONE, sig.d_l),
	F32_REINTERPRET_I32	(0x00, 0xBE, "f32.reinterpret_i32", imm.NONE, sig.i_f),
	F64_REINTERPRET_I64	(0x00, 0xBF, "f64.reinterpret_i64", imm.NONE, sig.l_d),
	// Sign extensions.
	I32_EXTEND8_S		(0x00, 0xC0, "i32.extend8_s", imm.NONE, sig.i_i),
	I32_EXTEND16_S		(0x00, 0xC1, "i32.extend16_s", imm.NONE, sig.i_i),
	I64_EXTEND8_S		(0x00, 0xC2, "i64.extend8_s", imm.NONE, sig.l_l),
	I64_EXTEND16_S		(0x00, 0xC3, "i64.extend16_s", imm.NONE, sig.l_l),
	I64_EXTEND32_S		(0x00, 0xC4, "i64.extend32_s", imm.NONE, sig.l_l),
	// Reference instructions.
	REF_NULL		(0x00, 0xD0, "ref.null", imm.HEAPT, null),
	REF_IS_NULL		(0x00, 0xD1, "ref.is_null", imm.NONE, null),
	REF_FUNC		(0x00, 0xD2, "ref.func", imm.FUNC, null),
	REF_EQ			(0x00, 0xD3, "ref.eq", imm.NONE, null),
	REF_AS_NON_NULL		(0x00, 0xD4, "ref.as_non_null", imm.NONE, null),
	BR_ON_NULL		(0x00, 0xD5, "br_on_null", imm.LABEL, null),
	BR_ON_NON_NULL		(0x00, 0xD6, "br_on_non_null", imm.LABEL, null),
	// 0xFB prefix: gc proposal opcodes.
	STRUCT_NEW			(0xFB, 0x00, "struct.new", imm.STRUCTT, null),
	STRUCT_NEW_DEFAULT		(0xFB, 0x01, "struct.new_default", imm.STRUCTT, null),
	STRUCT_GET			(0xFB, 0x02, "struct.get", imm.STRUCTT_FIELD, null),
	STRUCT_GET_S			(0xFB, 0x03, "struct.get_s", imm.STRUCTT_FIELD, null),
	STRUCT_GET_U			(0xFB, 0x04, "struct.get_u", imm.STRUCTT_FIELD, null),
	STRUCT_SET			(0xFB, 0x05, "struct.set", imm.STRUCTT_FIELD, null),
	ARRAY_NEW			(0xFB, 0x06, "array.new", imm.ARRAYT, null),
	ARRAY_NEW_DEFAULT		(0xFB, 0x07, "array.new_default", imm.ARRAYT, null),
	ARRAY_NEW_FIXED			(0xFB, 0x08, "array.new_fixed", imm.ARRAYT_U32, null),
	ARRAY_NEW_DATA			(0xFB, 0x09, "array.new_data", imm.ARRAYT_DATA, null),
	ARRAY_NEW_ELEM			(0xFB, 0x0A, "array.new_elem", imm.ARRAYT_ELEM, null),
	
	ARRAY_GET			(0xFB, 0x0B, "array.get", imm.ARRAYT, null),
	ARRAY_GET_S			(0xFB, 0x0C, "array.get_s", imm.ARRAYT, null),
	ARRAY_GET_U			(0xFB, 0x0D, "array.get_u", imm.ARRAYT, null),
	ARRAY_SET			(0xFB, 0x0E, "array.set", imm.ARRAYT, null),
	ARRAY_LEN			(0xFB, 0x0F, "array.len", imm.NONE, null),
	ARRAY_FILL			(0xFB, 0x10, "array.fill", imm.ARRAYT, null),
	ARRAY_COPY			(0xFB, 0x11, "array.copy", imm.ARRAYT_ARRAYT, null),
	ARRAY_INIT_DATA			(0xFB, 0x12, "array.init_data", imm.ARRAYT_DATA, null),
	ARRAY_INIT_ELEM			(0xFB, 0x13, "array.init_elem", imm.ARRAYT_ELEM, null),
	REF_TEST			(0xFB, 0x14, "ref.test", imm.HEAPT, null),
	REF_TEST_NULL			(0xFB, 0x15, "ref.test null", imm.HEAPT, null),
	REF_CAST			(0xFB, 0x16, "ref.cast", imm.HEAPT, null),
	REF_CAST_NULL			(0xFB, 0x17, "ref.cast null", imm.HEAPT, null),
	BR_ON_CAST			(0xFB, 0x18, "br_on_cast", imm.BR_CAST_ARG, null),
	BR_ON_CAST_FAIL			(0xFB, 0x19, "br_on_cast_fail", imm.BR_CAST_ARG, null),
	ANY_CONVERT_EXTERN		(0xFB, 0x1A, "any.convert_extern", imm.NONE, null),
	EXTERN_CONVERT_ANY		(0xFB, 0x1B, "extern.convert_any", imm.NONE, null),
	REF_I31				(0xFB, 0x1C, "ref.i31", imm.NONE, null),
	I31_GET_S			(0xFB, 0x1D, "i31.get_s", imm.NONE, null),
	I31_GET_U			(0xFB, 0x1E, "i31.get_u", imm.NONE, null),
	// 0xFC prefix: saturating truncations.
	I32_TRUNC_SAT_F32_S	(0xFC, 0x00, "i32.trunc_sat_f32_s", imm.NONE, sig.f_i),
	I32_TRUNC_SAT_F32_U	(0xFC, 0x01, "i32.trunc_sat_f32_u", imm.NONE, sig.f_i),
	I32_TRUNC_SAT_F64_S	(0xFC, 0x02, "i32.trunc_sat_f64_s", imm.NONE, sig.d_i),
	I32_TRUNC_SAT_F64_U	(0xFC, 0x03, "i32.trunc_sat_f64_u", imm.NONE, sig.d_i),
	I64_TRUNC_SAT_F32_S	(0xFC, 0x04, "i64.trunc_sat_f32_s", imm.NONE, sig.f_l),
	I64_TRUNC_SAT_F32_U	(0xFC, 0x05, "i64.trunc_sat_f32_u", imm.NONE, sig.f_l),
	I64_TRUNC_SAT_F64_S	(0xFC, 0x06, "i64.trunc_sat_f64_s", imm.NONE, sig.d_l),
	I64_TRUNC_SAT_F64_U	(0xFC, 0x07, "i64.trunc_sat_f64_u", imm.NONE, sig.d_l),
	// 0xFC prefix: bulk-memory and references.
	MEMORY_INIT		(0xFC, 0x08, "memory.init", imm.DATA_MEMORY, sig.iii_v),
	DATA_DROP		(0xFC, 0x09, "data.drop", imm.DATA, sig.v_v),
	MEMORY_COPY		(0xFC, 0x0A, "memory.copy", imm.MEMORY_MEMORY, sig.iii_v),
	MEMORY_FILL		(0xFC, 0x0B, "memory.fill", imm.MEMORY, sig.iii_v),
	TABLE_INIT		(0xFC, 0x0C, "table.init", imm.ELEM_TABLE, sig.iii_v),
	ELEM_DROP		(0xFC, 0x0D, "elem.drop", imm.ELEM, sig.v_v),
	TABLE_COPY		(0xFC, 0x0E, "table.copy", imm.TABLE_TABLE, sig.iii_v),
	TABLE_GROW		(0xFC, 0x0F, "table.grow", imm.TABLE, null),
	TABLE_SIZE		(0xFC, 0x10, "table.size", imm.TABLE, sig.v_i),
	TABLE_FILL		(0xFC, 0x11, "table.fill", imm.TABLE, null),
	// 0xFD prefix: vector instructions.
	V128_LOAD			(0xFD, 0, "v128.load", imm.MEMARG, sig.i_s),
	V128_LOAD_8X8_S			(0xFD, 1, "v128.load_8x8_s", imm.MEMARG, sig.i_s),
	V128_LOAD_8X8_U			(0xFD, 2, "v128.load_8x8_u", imm.MEMARG, sig.i_s),
	V128_LOAD_16X4_S		(0xFD, 3, "v128.load_16x4_s", imm.MEMARG, sig.i_s),
	V128_LOAD_16X4_U		(0xFD, 4, "v128.load_16x4_u", imm.MEMARG, sig.i_s),
	V128_LOAD_32X2_S		(0xFD, 5, "v128.load_32x2_s", imm.MEMARG, sig.i_s),
	V128_LOAD_32X2_U		(0xFD, 6, "v128.load_32x2_u", imm.MEMARG, sig.i_s),
	V128_LOAD_8_SPLAT		(0xFD, 7, "v128.load_8_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_16_SPLAT		(0xFD, 8, "v128.load_16_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_32_SPLAT		(0xFD, 9, "v128.load_32_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_64_SPLAT		(0xFD, 10, "v128.load_64_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_32_ZERO		(0xFD, 92, "v128.load_32_zero", imm.MEMARG, sig.i_s),
	V128_LOAD_64_ZERO		(0xFD, 93, "v128.load_64_zero", imm.MEMARG, sig.i_s),
	V128_STORE			(0xFD, 11, "v128.store", imm.MEMARG, sig.is_v),
	V128_LOAD_8_LANE		(0xFD, 84, "v128.load_8_lane", imm.MEMARG_LANE, sig.is_s),
	V128_LOAD_16_LANE		(0xFD, 85, "v128.load_16_lane", imm.MEMARG_LANE, sig.is_s),
	V128_LOAD_32_LANE		(0xFD, 86, "v128.load_32_lane", imm.MEMARG_LANE, sig.is_s),
	V128_LOAD_64_LANE		(0xFD, 87, "v128.load_64_lane", imm.MEMARG_LANE, sig.is_s),
	V128_STORE_8_LANE		(0xFD, 88, "v128.store_8_lane", imm.MEMARG_LANE, sig.is_v),
	V128_STORE_16_LANE		(0xFD, 89, "v128.store_16_lane", imm.MEMARG_LANE, sig.is_v),
	V128_STORE_32_LANE		(0xFD, 90, "v128.store_32_lane", imm.MEMARG_LANE, sig.is_v),
	V128_STORE_64_LANE		(0xFD, 91, "v128.store_64_lane", imm.MEMARG_LANE, sig.is_v),
	V128_CONST			(0xFD, 12, "v128.const", imm.V128, sig.v_s),
	I8X16_SHUFFLE			(0xFD, 13, "i8x16.shuffle", imm.LANEx16, sig.ss_s),
	I8X16_EXTRACTLANE_S		(0xFD, 21, "i8x16.extractlane_s", imm.LANE, sig.s_i),
	I8X16_EXTRACTLANE_U		(0xFD, 22, "i8x16.extractlane_u", imm.LANE, sig.s_i),
	I8X16_REPLACELANE		(0xFD, 23, "i8x16.replacelane", imm.LANE, sig.si_s),
	I16X8_EXTRACTLANE_S		(0xFD, 24, "i16x8.extractlane_s", imm.LANE, sig.s_i),
	I16X8_EXTRACTLANE_U		(0xFD, 25, "i16x8.extractlane_u", imm.LANE, sig.s_i),
	I16X8_REPLACELANE		(0xFD, 26, "i16x8.replacelane", imm.LANE, sig.si_s),
	I32X4_EXTRACTLANE		(0xFD, 27, "i32x4.extractlane", imm.LANE, sig.s_i),
	I32X4_REPLACELANE		(0xFD, 28, "i32x4.replacelane", imm.LANE, sig.si_s),
	I64X2_EXTRACTLANE		(0xFD, 29, "i64x2.extractlane", imm.LANE, sig.s_l),
	I64X2_REPLACELANE		(0xFD, 30, "i64x2.replacelane", imm.LANE, sig.sl_s),
	F32X4_EXTRACTLANE		(0xFD, 31, "f32x4.extractlane", imm.LANE, sig.s_f),
	F32X4_REPLACELANE		(0xFD, 32, "f32x4.replacelane", imm.LANE, sig.sf_s),
	F64X2_EXTRACTLANE		(0xFD, 33, "f64x2.extractlane", imm.LANE, sig.s_d),
	F64X2_REPLACELANE		(0xFD, 34, "f64x2.replacelane", imm.LANE, sig.sd_s),
	I8X16_SWIZZLE			(0xFD, 14, "i8x16.swizzle", imm.NONE, sig.ss_s),
	I8X16_SPLAT			(0xFD, 15, "i8x16.splat", imm.NONE, sig.i_s),
	I16X8_SPLAT			(0xFD, 16, "i16x8.splat", imm.NONE, sig.i_s),
	I32X4_SPLAT			(0xFD, 17, "i32x4.splat", imm.NONE, sig.i_s),
	I64X2_SPLAT			(0xFD, 18, "i64x2.splat", imm.NONE, sig.l_s),
	F32X4_SPLAT			(0xFD, 19, "f32x4.splat", imm.NONE, sig.f_s),
	F64X2_SPLAT			(0xFD, 20, "f64x2.splat", imm.NONE, sig.d_s),
	I8X16_EQ			(0xFD, 35, "i8x16.eq", imm.NONE, sig.ss_s),
	I8X16_NE			(0xFD, 36, "i8x16.ne", imm.NONE, sig.ss_s),
	I8X16_LT_S			(0xFD, 37, "i8x16.lt_s", imm.NONE, sig.ss_s),
	I8X16_LT_U			(0xFD, 38, "i8x16.lt_u", imm.NONE, sig.ss_s),
	I8X16_GT_S			(0xFD, 39, "i8x16.gt_s", imm.NONE, sig.ss_s),
	I8X16_GT_U			(0xFD, 40, "i8x16.gt_u", imm.NONE, sig.ss_s),
	I8X16_LE_S			(0xFD, 41, "i8x16.le_s", imm.NONE, sig.ss_s),
	I8X16_LE_U			(0xFD, 42, "i8x16.le_u", imm.NONE, sig.ss_s),
	I8X16_GE_S			(0xFD, 43, "i8x16.ge_s", imm.NONE, sig.ss_s),
	I8X16_GE_U			(0xFD, 44, "i8x16.ge_u", imm.NONE, sig.ss_s),
	I16X8_EQ			(0xFD, 45, "i16x8.eq", imm.NONE, sig.ss_s),
	I16X8_NE			(0xFD, 46, "i16x8.ne", imm.NONE, sig.ss_s),
	I16X8_LT_S			(0xFD, 47, "i16x8.lt_s", imm.NONE, sig.ss_s),
	I16X8_LT_U			(0xFD, 48, "i16x8.lt_u", imm.NONE, sig.ss_s),
	I16X8_GT_S			(0xFD, 49, "i16x8.gt_s", imm.NONE, sig.ss_s),
	I16X8_GT_U			(0xFD, 50, "i16x8.gt_u", imm.NONE, sig.ss_s),
	I16X8_LE_S			(0xFD, 51, "i16x8.le_s", imm.NONE, sig.ss_s),
	I16X8_LE_U			(0xFD, 52, "i16x8.le_u", imm.NONE, sig.ss_s),
	I16X8_GE_S			(0xFD, 53, "i16x8.ge_s", imm.NONE, sig.ss_s),
	I16X8_GE_U			(0xFD, 54, "i16x8.ge_u", imm.NONE, sig.ss_s),
	I32X4_EQ			(0xFD, 55, "i32x4.eq", imm.NONE, sig.ss_s),
	I32X4_NE			(0xFD, 56, "i32x4.ne", imm.NONE, sig.ss_s),
	I32X4_LT_S			(0xFD, 57, "i32x4.lt_s", imm.NONE, sig.ss_s),
	I32X4_LT_U			(0xFD, 58, "i32x4.lt_u", imm.NONE, sig.ss_s),
	I32X4_GT_S			(0xFD, 59, "i32x4.gt_s", imm.NONE, sig.ss_s),
	I32X4_GT_U			(0xFD, 60, "i32x4.gt_u", imm.NONE, sig.ss_s),
	I32X4_LE_S			(0xFD, 61, "i32x4.le_s", imm.NONE, sig.ss_s),
	I32X4_LE_U			(0xFD, 62, "i32x4.le_u", imm.NONE, sig.ss_s),
	I32X4_GE_S			(0xFD, 63, "i32x4.ge_s", imm.NONE, sig.ss_s),
	I32X4_GE_U			(0xFD, 64, "i32x4.ge_u", imm.NONE, sig.ss_s),
	I64X2_EQ			(0xFD, 214, "i64x2.eq", imm.NONE, sig.ss_s),
	I64X2_NE			(0xFD, 215, "i64x2.ne", imm.NONE, sig.ss_s),
	I64X2_LT_S			(0xFD, 216, "i64x2.lt_s", imm.NONE, sig.ss_s),
	I64X2_GT_S			(0xFD, 217, "i64x2.gt_s", imm.NONE, sig.ss_s),
	I64X2_LE_S			(0xFD, 218, "i64x2.le_s", imm.NONE, sig.ss_s),
	I64X2_GE_S			(0xFD, 219, "i64x2.ge_s", imm.NONE, sig.ss_s),
	F32X4_EQ			(0xFD, 65, "f32x4.eq", imm.NONE, sig.ss_s),
	F32X4_NE			(0xFD, 66, "f32x4.ne", imm.NONE, sig.ss_s),
	F32X4_LT			(0xFD, 67, "f32x4.lt", imm.NONE, sig.ss_s),
	F32X4_GT			(0xFD, 68, "f32x4.gt", imm.NONE, sig.ss_s),
	F32X4_LE			(0xFD, 69, "f32x4.le", imm.NONE, sig.ss_s),
	F32X4_GE			(0xFD, 70, "f32x4.ge", imm.NONE, sig.ss_s),
	F64X2_EQ			(0xFD, 71, "f64x2.eq", imm.NONE, sig.ss_s),
	F64X2_NE			(0xFD, 72, "f64x2.ne", imm.NONE, sig.ss_s),
	F64X2_LT			(0xFD, 73, "f64x2.lt", imm.NONE, sig.ss_s),
	F64X2_GT			(0xFD, 74, "f64x2.gt", imm.NONE, sig.ss_s),
	F64X2_LE			(0xFD, 75, "f64x2.le", imm.NONE, sig.ss_s),
	F64X2_GE			(0xFD, 76, "f64x2.ge", imm.NONE, sig.ss_s),
	V128_NOT			(0xFD, 77, "v128.not", imm.NONE, sig.s_s),
	V128_AND			(0xFD, 78, "v128.and", imm.NONE, sig.ss_s),
	V128_ANDNOT			(0xFD, 79, "v128.andnot", imm.NONE, sig.ss_s),
	V128_OR				(0xFD, 80, "v128.or", imm.NONE, sig.ss_s),
	V128_XOR			(0xFD, 81, "v128.xor", imm.NONE, sig.ss_s),
	V128_BITSELECT			(0xFD, 82, "v128.bitselect", imm.NONE, sig.sss_s),
	V128_ANYTRUE			(0xFD, 83, "v128.anytrue", imm.NONE, sig.s_i),
	I8X16_ABS			(0xFD, 96, "i8x16.abs", imm.NONE, sig.s_s),
	I8X16_NEG			(0xFD, 97, "i8x16.neg", imm.NONE, sig.s_s),
	I8X16_POPCNT			(0xFD, 98, "i8x16.popcnt", imm.NONE, sig.s_s),
	I8X16_ALLTRUE			(0xFD, 99, "i8x16.alltrue", imm.NONE, sig.s_i),
	I8X16_BITMASK			(0xFD, 100, "i8x16.bitmask", imm.NONE, sig.s_i),
	I8X16_NARROW_I16X8_S		(0xFD, 101, "i8x16.narrow_i16x8_s", imm.NONE, sig.ss_s),
	I8X16_NARROW_I16X8_U		(0xFD, 102, "i8x16.narrow_i16x8_u", imm.NONE, sig.ss_s),
	I8X16_SHL			(0xFD, 107, "i8x16.shl", imm.NONE, sig.si_s),
	I8X16_SHR_S			(0xFD, 108, "i8x16.shr_s", imm.NONE, sig.si_s),
	I8X16_SHR_U			(0xFD, 109, "i8x16.shr_u", imm.NONE, sig.si_s),
	I8X16_ADD			(0xFD, 110, "i8x16.add", imm.NONE, sig.ss_s),
	I8X16_ADD_SAT_S			(0xFD, 111, "i8x16.add_sat_s", imm.NONE, sig.ss_s),
	I8X16_ADD_SAT_U			(0xFD, 112, "i8x16.add_sat_u", imm.NONE, sig.ss_s),
	I8X16_SUB			(0xFD, 113, "i8x16.sub", imm.NONE, sig.ss_s),
	I8X16_SUB_SAT_S			(0xFD, 114, "i8x16.sub_sat_s", imm.NONE, sig.ss_s),
	I8X16_SUB_SAT_U			(0xFD, 115, "i8x16.sub_sat_u", imm.NONE, sig.ss_s),
	I8X16_MIN_S			(0xFD, 118, "i8x16.min_s", imm.NONE, sig.ss_s),
	I8X16_MIN_U			(0xFD, 119, "i8x16.min_u", imm.NONE, sig.ss_s),
	I8X16_MAX_S			(0xFD, 120, "i8x16.max_s", imm.NONE, sig.ss_s),
	I8X16_MAX_U			(0xFD, 121, "i8x16.max_u", imm.NONE, sig.ss_s),
	I8X16_AVGR_U			(0xFD, 123, "i8x16.avgr_u", imm.NONE, sig.ss_s),
	I16X8_EXTADDPAIRWISE_I8X16_S	(0xFD, 124, "i16x8.extaddpairwise_i8x16_s", imm.NONE, sig.s_s),
	I16X8_EXTADDPAIRWISE_I8X16_U	(0xFD, 125, "i16x8.extaddpairwise_i8x16_u", imm.NONE, sig.s_s),
	I16X8_ABS			(0xFD, 128, "i16x8.abs", imm.NONE, sig.s_s),
	I16X8_NEG			(0xFD, 129, "i16x8.neg", imm.NONE, sig.s_s),
	I16X8_Q15MULRSAT_S		(0xFD, 130, "i16x8.q15mulrsat_s", imm.NONE, sig.ss_s),
	I16X8_ALLTRUE			(0xFD, 131, "i16x8.alltrue", imm.NONE, sig.s_i),
	I16X8_BITMASK			(0xFD, 132, "i16x8.bitmask", imm.NONE, sig.s_i),
	I16X8_NARROW_I32X4_S		(0xFD, 133, "i16x8.narrow_i32x4_s", imm.NONE, sig.ss_s),
	I16X8_NARROW_I32X4_U		(0xFD, 134, "i16x8.narrow_i32x4_u", imm.NONE, sig.ss_s),
	I16X8_EXTEND_LOW_I8X16_S	(0xFD, 135, "i16x8.extend_low_i8x16_s", imm.NONE, sig.s_s),
	I16X8_EXTEND_HIGH_I8X16_S	(0xFD, 136, "i16x8.extend_high_i8x16_s", imm.NONE, sig.s_s),
	I16X8_EXTEND_LOW_I8X16_U	(0xFD, 137, "i16x8.extend_low_i8x16_u", imm.NONE, sig.s_s),
	I16X8_EXTEND_HIGH_I8X16_U	(0xFD, 138, "i16x8.extend_high_i8x16_u", imm.NONE, sig.s_s),
	I16X8_SHL			(0xFD, 139, "i16x8.shl", imm.NONE, sig.si_s),
	I16X8_SHR_S			(0xFD, 140, "i16x8.shr_s", imm.NONE, sig.si_s),
	I16X8_SHR_U			(0xFD, 141, "i16x8.shr_u", imm.NONE, sig.si_s),
	I16X8_ADD			(0xFD, 142, "i16x8.add", imm.NONE, sig.ss_s),
	I16X8_ADD_SAT_S			(0xFD, 143, "i16x8.add_sat_s", imm.NONE, sig.ss_s),
	I16X8_ADD_SAT_U			(0xFD, 144, "i16x8.add_sat_u", imm.NONE, sig.ss_s),
	I16X8_SUB			(0xFD, 145, "i16x8.sub", imm.NONE, sig.ss_s),
	I16X8_SUB_SAT_S			(0xFD, 146, "i16x8.sub_sat_s", imm.NONE, sig.ss_s),
	I16X8_SUB_SAT_U			(0xFD, 147, "i16x8.sub_sat_u", imm.NONE, sig.ss_s),
	I16X8_MUL			(0xFD, 149, "i16x8.mul", imm.NONE, sig.ss_s),
	I16X8_MIN_S			(0xFD, 150, "i16x8.min_s", imm.NONE, sig.ss_s),
	I16X8_MIN_U			(0xFD, 151, "i16x8.min_u", imm.NONE, sig.ss_s),
	I16X8_MAX_S			(0xFD, 152, "i16x8.max_s", imm.NONE, sig.ss_s),
	I16X8_MAX_U			(0xFD, 153, "i16x8.max_u", imm.NONE, sig.ss_s),
	I16X8_AVGR_U			(0xFD, 155, "i16x8.avgr_u", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_LOW_I8X16_S	(0xFD, 156, "i16x8.extmul_low_i8x16_s", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_HIGH_I8X16_S	(0xFD, 157, "i16x8.extmul_high_i8x16_s", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_LOW_I8X16_U	(0xFD, 158, "i16x8.extmul_low_i8x16_u", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_HIGH_I8X16_U	(0xFD, 159, "i16x8.extmul_high_i8x16_u", imm.NONE, sig.ss_s),
	I32X4_EXTADDPAIRWISE_I16X8_S	(0xFD, 126, "i32x4.extaddpairwise_i16x8_s", imm.NONE, sig.s_s),
	I32X4_EXTADDPAIRWISE_I16X8_U	(0xFD, 127, "i32x4.extaddpairwise_i16x8_u", imm.NONE, sig.s_s),
	I32X4_ABS			(0xFD, 160, "i32x4.abs", imm.NONE, sig.s_s),
	I32X4_NEG			(0xFD, 161, "i32x4.neg", imm.NONE, sig.s_s),
	I32X4_ALLTRUE			(0xFD, 163, "i32x4.alltrue", imm.NONE, sig.s_i),
	I32X4_BITMASK			(0xFD, 164, "i32x4.bitmask", imm.NONE, sig.s_i),
	I32X4_EXTEND_LOW_I16X8_S	(0xFD, 167, "i32x4.extend_low_i16x8_s", imm.NONE, sig.s_s),
	I32X4_EXTEND_HIGH_I16X8_S	(0xFD, 168, "i32x4.extend_high_i16x8_s", imm.NONE, sig.s_s),
	I32X4_EXTEND_LOW_I16X8_U	(0xFD, 169, "i32x4.extend_low_i16x8_u", imm.NONE, sig.s_s),
	I32X4_EXTEND_HIGH_I16X8_U	(0xFD, 170, "i32x4.extend_high_i16x8_u", imm.NONE, sig.s_s),
	I32X4_SHL			(0xFD, 171, "i32x4.shl", imm.NONE, sig.si_s),
	I32X4_SHR_S			(0xFD, 172, "i32x4.shr_s", imm.NONE, sig.si_s),
	I32X4_SHR_U			(0xFD, 173, "i32x4.shr_u", imm.NONE, sig.si_s),
	I32X4_ADD			(0xFD, 174, "i32x4.add", imm.NONE, sig.ss_s),
	I32X4_SUB			(0xFD, 177, "i32x4.sub", imm.NONE, sig.ss_s),
	I32X4_MUL			(0xFD, 181, "i32x4.mul", imm.NONE, sig.ss_s),
	I32X4_MIN_S			(0xFD, 182, "i32x4.min_s", imm.NONE, sig.ss_s),
	I32X4_MIN_U			(0xFD, 183, "i32x4.min_u", imm.NONE, sig.ss_s),
	I32X4_MAX_S			(0xFD, 184, "i32x4.max_s", imm.NONE, sig.ss_s),
	I32X4_MAX_U			(0xFD, 185, "i32x4.max_u", imm.NONE, sig.ss_s),
	I32X4_DOT_I16X8_S		(0xFD, 186, "i32x4.dot_i16x8_s", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_LOW_I16X8_S	(0xFD, 188, "i32x4.extmul_low_i16x8_s", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_HIGH_I16X8_S	(0xFD, 189, "i32x4.extmul_high_i16x8_s", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_LOW_I16X8_U	(0xFD, 190, "i32x4.extmul_low_i16x8_u", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_HIGH_I16X8_U	(0xFD, 191, "i32x4.extmul_high_i16x8_u", imm.NONE, sig.ss_s),
	I64X2_ABS			(0xFD, 192, "i64x2.abs", imm.NONE, sig.s_s),
	I64X2_NEG			(0xFD, 193, "i64x2.neg", imm.NONE, sig.s_s),
	I64X2_ALLTRUE			(0xFD, 195, "i64x2.alltrue", imm.NONE, sig.s_i),
	I64X2_BITMASK			(0xFD, 196, "i64x2.bitmask", imm.NONE, sig.s_i),
	I64X2_EXTEND_LOW_I32X4_S	(0xFD, 199, "i64x2.extend_low_i32x4_s", imm.NONE, sig.s_s),
	I64X2_EXTEND_HIGH_I32X4_S	(0xFD, 200, "i64x2.extend_high_i32x4_s", imm.NONE, sig.s_s),
	I64X2_EXTEND_LOW_I32X4_U	(0xFD, 201, "i64x2.extend_low_i32x4_u", imm.NONE, sig.s_s),
	I64X2_EXTEND_HIGH_I32X4_U	(0xFD, 202, "i64x2.extend_high_i32x4_u", imm.NONE, sig.s_s),
	I64X2_SHL			(0xFD, 203, "i64x2.shl", imm.NONE, sig.si_s),
	I64X2_SHR_S			(0xFD, 204, "i64x2.shr_s", imm.NONE, sig.si_s),
	I64X2_SHR_U			(0xFD, 205, "i64x2.shr_u", imm.NONE, sig.si_s),
	I64X2_ADD			(0xFD, 206, "i64x2.add", imm.NONE, sig.ss_s),
	I64X2_SUB			(0xFD, 209, "i64x2.sub", imm.NONE, sig.ss_s),
	I64X2_MUL			(0xFD, 213, "i64x2.mul", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_LOW_I32X4_S	(0xFD, 220, "i64x2.extmul_low_i32x4_s", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_HIGH_I32X4_S	(0xFD, 221, "i64x2.extmul_high_i32x4_s", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_LOW_I32X4_U	(0xFD, 222, "i64x2.extmul_low_i32x4_u", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_HIGH_I32X4_U	(0xFD, 223, "i64x2.extmul_high_i32x4_u", imm.NONE, sig.ss_s),
	F32X4_CEIL			(0xFD, 103, "f32x4.ceil", imm.NONE, sig.s_s),
	F32X4_FLOOR			(0xFD, 104, "f32x4.floor", imm.NONE, sig.s_s),
	F32X4_TRUNC			(0xFD, 105, "f32x4.trunc", imm.NONE, sig.s_s),
	F32X4_NEAREST			(0xFD, 106, "f32x4.nearest", imm.NONE, sig.s_s),
	F32X4_ABS			(0xFD, 224, "f32x4.abs", imm.NONE, sig.s_s),
	F32X4_NEG			(0xFD, 225, "f32x4.neg", imm.NONE, sig.s_s),
	F32X4_SQRT			(0xFD, 227, "f32x4.sqrt", imm.NONE, sig.s_s),
	F32X4_ADD			(0xFD, 228, "f32x4.add", imm.NONE, sig.ss_s),
	F32X4_SUB			(0xFD, 229, "f32x4.sub", imm.NONE, sig.ss_s),
	F32X4_MUL			(0xFD, 230, "f32x4.mul", imm.NONE, sig.ss_s),
	F32X4_DIV			(0xFD, 231, "f32x4.div", imm.NONE, sig.ss_s),
	F32X4_MIN			(0xFD, 232, "f32x4.min", imm.NONE, sig.ss_s),
	F32X4_MAX			(0xFD, 233, "f32x4.max", imm.NONE, sig.ss_s),
	F32X4_PMIN			(0xFD, 234, "f32x4.pmin", imm.NONE, sig.ss_s),
	F32X4_PMAX			(0xFD, 235, "f32x4.pmax", imm.NONE, sig.ss_s),
	F64X2_CEIL			(0xFD, 116, "f64x2.ceil", imm.NONE, sig.s_s),
	F64X2_FLOOR			(0xFD, 117, "f64x2.floor", imm.NONE, sig.s_s),
	F64X2_TRUNC			(0xFD, 122, "f64x2.trunc", imm.NONE, sig.s_s),
	F64X2_NEAREST			(0xFD, 148, "f64x2.nearest", imm.NONE, sig.s_s),
	F64X2_ABS			(0xFD, 236, "f64x2.abs", imm.NONE, sig.s_s),
	F64X2_NEG			(0xFD, 237, "f64x2.neg", imm.NONE, sig.s_s),
	F64X2_SQRT			(0xFD, 239, "f64x2.sqrt", imm.NONE, sig.s_s),
	F64X2_ADD			(0xFD, 240, "f64x2.add", imm.NONE, sig.ss_s),
	F64X2_SUB			(0xFD, 241, "f64x2.sub", imm.NONE, sig.ss_s),
	F64X2_MUL			(0xFD, 242, "f64x2.mul", imm.NONE, sig.ss_s),
	F64X2_DIV			(0xFD, 243, "f64x2.div", imm.NONE, sig.ss_s),
	F64X2_MIN			(0xFD, 244, "f64x2.min", imm.NONE, sig.ss_s),
	F64X2_MAX			(0xFD, 245, "f64x2.max", imm.NONE, sig.ss_s),
	F64X2_PMIN			(0xFD, 246, "f64x2.pmin", imm.NONE, sig.ss_s),
	F64X2_PMAX			(0xFD, 247, "f64x2.pmax", imm.NONE, sig.ss_s),
	I32X4_TRUNC_SAT_F32X4_S		(0xFD, 248, "i32x4.trunc_sat_f32x4_s", imm.NONE, sig.s_s),
	I32X4_TRUNC_SAT_F32X4_U		(0xFD, 249, "i32x4.trunc_sat_f32x4_u", imm.NONE, sig.s_s),
	F32X4_CONVERT_I32X4_S		(0xFD, 250, "f32x4.convert_i32x4_s", imm.NONE, sig.s_s),
	F32X4_CONVERT_I32X4_U		(0xFD, 251, "f32x4.convert_i32x4_u", imm.NONE, sig.s_s),
	I32X4_TRUNC_SAT_F64X2_S_ZERO	(0xFD, 252, "i32x4.trunc_sat_f64x2_s_zero", imm.NONE, sig.s_s),
	I32X4_TRUNC_SAT_F64X2_U_ZERO	(0xFD, 253, "i32x4.trunc_sat_f64x2_u_zero", imm.NONE, sig.s_s),
	F64X2_CONVERT_LOW_I32X4_S	(0xFD, 254, "f64x2.convert_low_i32x4_s", imm.NONE, sig.s_s),
	F64X2_CONVERT_LOW_I32X4_U	(0xFD, 255, "f64x2.convert_low_i32x4_u", imm.NONE, sig.s_s),
	F32X4_DEMOTE_F64X2_ZERO		(0xFD, 94, "f32x4.demote_f64x2_zero", imm.NONE, sig.s_s),
	F64X2_PROMOTE_LOW_F32X4		(0xFD, 95, "f64x2.promote_low_f32x4", imm.NONE, sig.s_s),
	// 0xFE prefix: atomics.
	MEMORY_ATOMIC_NOTIFY		(0xFE, 0x00, "memory.atomic.notify", imm.MEMARG, sig.ii_i),
	MEMORY_ATOMIC_WAIT32		(0xFE, 0x01, "memory.atomic.wait32", imm.MEMARG, sig.iil_i),
	MEMORY_ATOMIC_WAIT64		(0xFE, 0x02, "memory.atomic.wait64", imm.MEMARG, sig.ill_i),
	ATOMIC_FENCE			(0xFE, 0x03, "atomic.fence", imm.ZEROB, sig.v_v),
	I32_ATOMIC_LOAD			(0xFE, 0x10, "i32.atomic.load", imm.MEMARG, sig.i_i),
	I64_ATOMIC_LOAD			(0xFE, 0x11, "i64.atomic.load", imm.MEMARG, sig.i_l),
	I32_ATOMIC_LOAD8_U		(0xFE, 0x12, "i32.atomic.load8_u", imm.MEMARG, sig.i_i),
	I32_ATOMIC_LOAD16_U		(0xFE, 0x13, "i32.atomic.load16_u", imm.MEMARG, sig.i_i),
	I64_ATOMIC_LOAD8_U		(0xFE, 0x14, "i64.atomic.load8_u", imm.MEMARG, sig.i_l),
	I64_ATOMIC_LOAD16_U		(0xFE, 0x15, "i64.atomic.load16_u", imm.MEMARG, sig.i_l),
	I64_ATOMIC_LOAD32_U		(0xFE, 0x16, "i64.atomic.load32_u", imm.MEMARG, sig.i_l),
	I32_ATOMIC_STORE		(0xFE, 0x17, "i32.atomic.store", imm.MEMARG, sig.ii_v),
	I64_ATOMIC_STORE		(0xFE, 0x18, "i64.atomic.store", imm.MEMARG, sig.il_v),
	I32_ATOMIC_STORE8		(0xFE, 0x19, "i32.atomic.store8", imm.MEMARG, sig.ii_v),
	I32_ATOMIC_STORE16		(0xFE, 0x1A, "i32.atomic.store16", imm.MEMARG, sig.ii_v),
	I64_ATOMIC_STORE8		(0xFE, 0x1B, "i64.atomic.store8", imm.MEMARG, sig.il_v),
	I64_ATOMIC_STORE16		(0xFE, 0x1C, "i64.atomic.store16", imm.MEMARG, sig.il_v),
	I64_ATOMIC_STORE32		(0xFE, 0x1D, "i64.atomic.store32", imm.MEMARG, sig.il_v),
	I32_ATOMIC_RMW_ADD		(0xFE, 0x1E, "i32.atomic.rmw.add", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_ADD		(0xFE, 0x1F, "i64.atomic.rmw.add", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_ADD_U		(0xFE, 0x20, "i32.atomic.rmw8.add_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_ADD_U		(0xFE, 0x21, "i32.atomic.rmw16.add_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_ADD_U		(0xFE, 0x22, "i64.atomic.rmw8.add_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_ADD_U		(0xFE, 0x23, "i64.atomic.rmw16.add_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_ADD_U		(0xFE, 0x24, "i64.atomic.rmw32.add_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_SUB		(0xFE, 0x25, "i32.atomic.rmw.sub", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_SUB		(0xFE, 0x26, "i64.atomic.rmw.sub", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_SUB_U		(0xFE, 0x27, "i32.atomic.rmw8.sub_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_SUB_U		(0xFE, 0x28, "i32.atomic.rmw16.sub_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_SUB_U		(0xFE, 0x29, "i64.atomic.rmw8.sub_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_SUB_U		(0xFE, 0x2A, "i64.atomic.rmw16.sub_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_SUB_U		(0xFE, 0x2B, "i64.atomic.rmw32.sub_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_AND		(0xFE, 0x2C, "i32.atomic.rmw.and", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_AND		(0xFE, 0x2D, "i64.atomic.rmw.and", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_AND_U		(0xFE, 0x2E, "i32.atomic.rmw8.and_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_AND_U		(0xFE, 0x2F, "i32.atomic.rmw16.and_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_AND_U		(0xFE, 0x30, "i64.atomic.rmw8.and_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_AND_U		(0xFE, 0x31, "i64.atomic.rmw16.and_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_AND_U		(0xFE, 0x32, "i64.atomic.rmw32.and_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_OR		(0xFE, 0x33, "i32.atomic.rmw.or", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_OR		(0xFE, 0x34, "i64.atomic.rmw.or", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_OR_U		(0xFE, 0x35, "i32.atomic.rmw8.or_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_OR_U		(0xFE, 0x36, "i32.atomic.rmw16.or_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_OR_U		(0xFE, 0x37, "i64.atomic.rmw8.or_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_OR_U		(0xFE, 0x38, "i64.atomic.rmw16.or_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_OR_U		(0xFE, 0x39, "i64.atomic.rmw32.or_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_XOR		(0xFE, 0x3A, "i32.atomic.rmw.xor", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_XOR		(0xFE, 0x3B, "i64.atomic.rmw.xor", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_XOR_U		(0xFE, 0x3C, "i32.atomic.rmw8.xor_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_XOR_U		(0xFE, 0x3D, "i32.atomic.rmw16.xor_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_XOR_U		(0xFE, 0x3E, "i64.atomic.rmw8.xor_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_XOR_U		(0xFE, 0x3F, "i64.atomic.rmw16.xor_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_XOR_U		(0xFE, 0x40, "i64.atomic.rmw32.xor_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_XCHG		(0xFE, 0x41, "i32.atomic.rmw.xchg", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_XCHG		(0xFE, 0x42, "i64.atomic.rmw.xchg", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_XCHG_U		(0xFE, 0x43, "i32.atomic.rmw8.xchg_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_XCHG_U		(0xFE, 0x44, "i32.atomic.rmw16.xchg_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_XCHG_U		(0xFE, 0x45, "i64.atomic.rmw8.xchg_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_XCHG_U		(0xFE, 0x46, "i64.atomic.rmw16.xchg_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_XCHG_U		(0xFE, 0x47, "i64.atomic.rmw32.xchg_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_CMPXCHG		(0xFE, 0x48, "i32.atomic.rmw.cmpxchg", imm.MEMARG, sig.iii_i),
	I64_ATOMIC_RMW_CMPXCHG		(0xFE, 0x49, "i64.atomic.rmw.cmpxchg", imm.MEMARG, sig.ill_l),
	I32_ATOMIC_RMW8_CMPXCHG_U	(0xFE, 0x4A, "i32.atomic.rmw8.cmpxchg_u", imm.MEMARG, sig.iii_i),
	I32_ATOMIC_RMW16_CMPXCHG_U	(0xFE, 0x4B, "i32.atomic.rmw16.cmpxchg_u", imm.MEMARG, sig.iii_i),
	I64_ATOMIC_RMW8_CMPXCHG_U	(0xFE, 0x4C, "i64.atomic.rmw8.cmpxchg_u", imm.MEMARG, sig.ill_l),
	I64_ATOMIC_RMW16_CMPXCHG_U	(0xFE, 0x4D, "i64.atomic.rmw16.cmpxchg_u", imm.MEMARG, sig.ill_l),
	I64_ATOMIC_RMW32_CMPXCHG_U	(0xFE, 0x4E, "i64.atomic.rmw32.cmpxchg_u", imm.MEMARG, sig.ill_l),

	CONT_NEW			(0x00, 0xE0, "cont.new", imm.CONT, null),
	CONT_BIND			(0x00, 0xE1, "cont.bind", imm.CONT_CONT, null),
	SUSPEND				(0x00, 0xE2, "suspend", imm.TAG, null),
	RESUME				(0x00, 0xE3, "resume", imm.CONT_HANDLE, null),
	RESUME_THROW			(0x00, 0xE4, "resume.throw", imm.CONT_TAG_HANDLE, null)
}

// Enumeration of the different kinds of immediates to opcodes.
enum ImmKind {
	ARRAY_TYPE_INDEX,	// ARRAYT
	BLOCK_TYPE,		// BLOCKT
	DATA_INDEX,		// DATA
	ELEM_INDEX,		// ELEM
	TAG_INDEX,		// TAG
	FIELD_INDEX,		// FIELD
	FUNC_INDEX,		// FUNC
	GLOBAL_INDEX,		// GLOBAL
	LABEL,			// LABEL
	LABELS,			// LABELs
	LOCAL_INDEX,		// LOCAL
	MEMARG,			// MEMARG
	MEMORY_INDEX,		// MEMORY
	HEAP_TYPE,		// HEAPT
	SIG_INDEX,		// SIG
	STRUCT_TYPE_INDEX,	// STRUCTT
	TABLE_INDEX,		// TABLE
	VALUE_TYPES,		// VALTs
	ZERO_BYTE,		// ZEROB
	U32,			// U32
	I32,			// I32
	I64,			// I64
	F32,			// F32
	F64,			// F64
	V128,			// V128
	LANE_INDEX,		// LANE
	BR_CAST,		// BR_CAST
	CATCHES,		// CATCH
	CONT_INDEX,		// CONT
	HANDLERS		// HANDLERS
}
// Cached immediate signatures
component ImmSigs {
	def NONE = Array<ImmKind>.new(0);
	// Singleton immediate signatures.
	def BLOCKT = [ImmKind.BLOCK_TYPE];
	def DATA = [ImmKind.DATA_INDEX];
	def ELEM = [ImmKind.ELEM_INDEX];
	def TAG = [ImmKind.TAG_INDEX];
	def FUNC = [ImmKind.FUNC_INDEX];
	def GLOBAL = [ImmKind.GLOBAL_INDEX];
	def LABEL = [ImmKind.LABEL];
	def LABELS = [ImmKind.LABELS];
	def LOCAL = [ImmKind.LOCAL_INDEX];
	def MEMARG = [ImmKind.MEMARG];
	def MEMORY = [ImmKind.MEMORY_INDEX];
	def SIG = [ImmKind.SIG_INDEX];
	def HEAPT = [ImmKind.HEAP_TYPE];
	def ARRAYT = [ImmKind.ARRAY_TYPE_INDEX];
	def STRUCTT = [ImmKind.STRUCT_TYPE_INDEX];
	def TABLE = [ImmKind.TABLE_INDEX];
	def VALTS = [ImmKind.VALUE_TYPES];
	def ZEROB = [ImmKind.ZERO_BYTE];
	def I32 = [ImmKind.I32];
	def I64 = [ImmKind.I64];
	def F32 = [ImmKind.F32];
	def F64 = [ImmKind.F64];
	def V128 = [ImmKind.V128];
	def LANE = [ImmKind.LANE_INDEX];
	def BLOCKT_CATCHES = [ImmKind.BLOCK_TYPE, ImmKind.CATCHES];
	// Combination signatures.
	def STRUCTT_FIELD = [ImmKind.STRUCT_TYPE_INDEX, ImmKind.FIELD_INDEX];
	def DATA_MEMORY = [ImmKind.DATA_INDEX, ImmKind.MEMORY_INDEX];
	def ELEM_TABLE = [ImmKind.ELEM_INDEX, ImmKind.TABLE_INDEX];
	def MEMORY_MEMORY = [ImmKind.MEMORY_INDEX, ImmKind.MEMORY_INDEX];
	def TABLE_TABLE = [ImmKind.TABLE_INDEX, ImmKind.TABLE_INDEX];
	def SIG_TABLE = [ImmKind.SIG_INDEX, ImmKind.TABLE_INDEX];
	def ARRAYT_U32 = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.U32];
	def ARRAYT_DATA = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.DATA_INDEX];
	def ARRAYT_ELEM = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.ELEM_INDEX];
	def BR_CAST_ARG = [ImmKind.BR_CAST];
	private def L = ImmKind.LANE_INDEX;
	def LANEx16 = [L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L];
	def MEMARG_LANE = [ImmKind.MEMARG, ImmKind.LANE_INDEX];
	def ARRAYT_ARRAYT = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.ARRAY_TYPE_INDEX];
	// Continuation operation signatures.
	def CONT = [ImmKind.CONT_INDEX];
	def CONT_CONT = [ImmKind.CONT_INDEX, ImmKind.CONT_INDEX];
	def CONT_HANDLE = [ImmKind.CONT_INDEX, ImmKind.HANDLERS];
	def CONT_TAG_HANDLE = [ImmKind.CONT_INDEX, ImmKind.TAG_INDEX, ImmKind.HANDLERS];
}

// Internal opcodes used by the interpreter.
enum InternalOpcode(code: u8) {
	PROBE(0x1E),	// Used to overwrite a bytecode where a probe has been inserted
	//PROBE_COUNTER
	//PROBE_COUNTER_n
	//PROBE_TOS_i
	//PROBE_WASM
	//PROBE_SAMPLE
	//PROBE_LIMIT
}
// Various computed attributes about opcodes.
enum OpcodeAttribute {
	SHORT_OP,
	PREFIX,
	INTERNAL,
	VALID
}
// A 256-entry page for dealing with prefixed opcodes.
class OpcodePage(prefix: byte) {
	private def valid = Array<u32>.new(8);  // bitmap for valid
	def opcodes = Array<Opcode>.new(256);
	var oneByte = true;

	def put(opcode: Opcode) {
		valid[opcode.code >> 5] |= 1u << u5.view(opcode.code);
		opcodes[opcode.code] = opcode;
		if (prefix != 0 && opcode.code >= 128) oneByte = false; // need full LEB decoding for this page
	}
	def isValid(code: u32) -> bool {
		if (code >= opcodes.length) return false;
		var entry = valid[u8.view(code >> 5)];
		return (entry & (1u << u5.view(code))) != 0;
	}
	def [code: u32] -> Opcode {
		if (code >= opcodes.length) return Opcode.UNREACHABLE;
		return opcodes[u8.view(code)];
	}
}

// Utilities for Wasm opcodes.
component Opcodes {
	// attributes, signatures, and opcode for non-prefixed opcodes
	def signatures = Array<SigDecl>.new(256);
	def attributes = Array<OpcodeAttribute.set>.new(256);
	def opcodes = Array<Opcode>.new(256);
	// Prefixed opcodes each get their own page.
	def page_FB = OpcodePage.new(0xFB);
	def page_FC = OpcodePage.new(0xFC);
	def page_FD = OpcodePage.new(0xFD);
	def page_FE = OpcodePage.new(0xFE);
	def code_pages = [page_FB, page_FC, page_FD, page_FE];
	def var longestName: int;
	def var count: int;
	private var nameMap: HashMap<string, Opcode>;

	new() {
		for (op in Opcode) init(op);
		for (op in [Opcode.INVALID, Opcode.CRASH_EXEC, Opcode.CRASH_COMPILER]) {
			attributes[op.code] |= OpcodeAttribute.INTERNAL;
		}
		for (op in InternalOpcode) {
			attributes[op.code] |= OpcodeAttribute.INTERNAL;
		}
	}
	def init(opcode: Opcode) {
		if (opcode.tag > count) count = 1 + int.!(opcode.tag);
		if (opcode.mnemonic.length > longestName) longestName = opcode.mnemonic.length;
		if (opcode.prefix == 0) {
			if (opcode == Opcode.INVALID) return; // skip invalid
			// Record non-prefixed opcode
			var c = opcode.code;
			signatures[c] = opcode.sig;
			opcodes[c] = opcode;
			attributes[c] |= OpcodeAttribute.VALID;
			if (opcode.sig != null && opcode.imms.length == 0) attributes[c] |= OpcodeAttribute.SHORT_OP;
			return;
		}
		attributes[opcode.prefix] |= OpcodeAttribute.PREFIX;
		for (page in code_pages) {
			if (page.prefix == opcode.prefix) return page.put(opcode);
		}
		System.error("OpcodesInitError", Strings.format2("no page found for %s, prefix=%x", opcode.name, opcode.prefix));
	}

	// Render a single-byte opcode.
	def render(buf: StringBuilder, code: byte) -> StringBuilder {
		if (attributes[code].VALID) {
			return buf.puts(opcodes[code].mnemonic);
		} else if (attributes[code].PREFIX) {
			return buf.put1("%x (prefix)", code);
		} else {
			return buf.put1("%x (invalid)", code);
		}
	}
	// Lookup an opcode, if it exists. Returns {Opcode.INVALID} if not.
	def find(prefix: byte, code: u32) -> Opcode {
		if (prefix == 0) return opcodes[code];
		for (page in code_pages) {
			if (page.prefix == prefix) return page[code];
		}
		return Opcode.INVALID;
	}
	// Look up an opcode by its mnemonic. Returns {Opcode.INVALID} if not found.
	def findByName(str: string) -> Opcode {
		if (nameMap == null) {
			nameMap = Strings.newMap<Opcode>();
			for (op in Opcode) {
				if (op != Opcode.SELECT_T) nameMap[op.mnemonic] = op;
			}
		}
		return nameMap[str];
	}
	// Parse and match opcode by its mnemonic. Returns {Opcode.INVALID} if not found.
	def parseName(str: Range<byte>) -> Opcode {
		var p = 0;
		for (i = 0; p < str.length; p++) {
			var ch = str[p];
			if (ch >= 'a' && ch <= 'z') continue;
			if (ch >= 'A' && ch <= 'Z') continue;
			if (ch >= '0' && ch <= '9') continue;
			if (ch == '_') continue;
			if (ch == '.') continue;
			if (ch == ' ') continue; // TODO: handles ref.test null
			break;
		}
		if (p > 0) return findByName(Ranges.dup(str[0 ... p]));
		return Opcode.INVALID;
	}
	def isInternal(op: Opcode) -> bool {
		if (op.prefix != 0) return false; // all internal bytecodes are 1-byte
		return attributes[op.code].INTERNAL;
	}
}

// Renders instructions as text.
class InstrTracer {
	def err = ErrorGen.new("");
	def codeptr = CodePtr.new([]);
	def all = Extension.set.all;
	def limits = Limits.new().set(Extension.set.all);
	var parser: WasmParser;

	def putInstr(out: StringBuilder, module: Module, d: DataReader) -> this {
		codeptr.reset(d.data, d.pos, d.limit);
		d = null;

		if (parser == null || parser.module != module) {
			// TODO: instr tracer leaks last module
			parser = WasmParser.new(all, limits, module, err, codeptr);
		}

		var b = codeptr.read1();
		var opcode: Opcode;
		if (Opcodes.attributes[b].PREFIX) {
			var b2 = codeptr.read_uleb32();
			opcode = Opcodes.find(b, b2);
			if (opcode == Opcode.INVALID) out.put2("%x %x <invalid>", b, b2);
			else out.puts(opcode.mnemonic);
		} else if (Opcodes.attributes[b].VALID) {
			opcode = Opcodes.opcodes[b];
			out.puts(opcode.mnemonic);
		} else if (b == InternalOpcode.PROBE.code) {
			out.put1("<probe>", b);
			return;
		} else {
			out.put1("%x <invalid>", b);
			return;
		}

		if (opcode.imms.length > 0) out.putc('[');
		var imms = opcode.imms;
		for (i < imms.length) {
			if (i > 0) out.putc(',');
			match (imms[i]) {
				BLOCK_TYPE => {
					var pr = parser.readBlockType();
					var pl = pr.0.length, rl = pr.1.length;
					if (pl == 0 && rl == 0) {
						// do nothing
					} else if (pl == 0 && rl == 1) {
						pr.1[0].render(out);
					} else {
						SigDecl.new(true, null, pr.0, pr.1).render(out);
					}
				}
				LABEL => out.put1("depth=%d", parser.readLabel());
				LABELS => {
					var labels = parser.readLabels();
					out.put1("%d...", labels.length);
				}
				HANDLERS => {
					var handlers = parser.readHandlers();
					out.put1("%d...", handlers.length);
				}
				CATCHES => {
					var catches = parser.readCatches();
					out.put1("%d...", catches.length);
				}
				VALUE_TYPES => {
					var at = parser.readValueTypes("select count", u32.max);
					for (i < at.length) {
						if (i > 0) out.puts(" ");
						at[i].render(out);
					}
				}
				HEAP_TYPE => {
					var ht = parser.readHeapType();
					ht.render(out);
				}
				FUNC_INDEX => out.put1("func=%d", codeptr.read_uleb32());
				TABLE_INDEX => out.put1("table=%d", codeptr.read_uleb32());
				LOCAL_INDEX,
				GLOBAL_INDEX => out.put1("%d", codeptr.read_uleb32());
				MEMORY_INDEX => out.put1("mem=%d", codeptr.read_uleb32());
				ELEM_INDEX => out.put1("elem=%d", codeptr.read_uleb32());
				TAG_INDEX => out.put1("tag=%d", codeptr.read_uleb32());
				DATA_INDEX => out.put1("data=%d", codeptr.read_uleb32());
				LANE_INDEX => out.put1("lane=%d", codeptr.read1());
				U32 => out.put1("%d", codeptr.read_uleb32());
				I32 => out.put1("%d", codeptr.read_sleb32());
				I64 => out.put1("%d", codeptr.read_sleb64());
				F32 => out.put1("0x%x", parser.readF32());
				F64 => out.put1("0x%x", parser.readF64());
				V128 => {
					var low = parser.readF64();
					var high = parser.readF64();
					out.puts("0x").putx_64(high).putx_64(low);
				}
				MEMARG => {
					var memarg = parser.readMemoryArg();
					var align = 1 << byte.!(memarg.flags >> 1);
					if (memarg.memory_index > 0) out.put1("memory=%d,", memarg.memory_index);
					out.put2("align=%d,offset=%d", align, memarg.offset);
				}
				FIELD_INDEX => out.put1("field=%d", codeptr.read_uleb32());
				SIG_INDEX => out.put1("sig=%d", codeptr.read_uleb32());
				STRUCT_TYPE_INDEX,
				ARRAY_TYPE_INDEX => out.put1("type=%d", codeptr.read_uleb32()); // XXX: render heap type ref?
				ZERO_BYTE => codeptr.read1();
				BR_CAST => {
					var t = parser.readBrCastImms(), depth = t.0, t1 = t.1, t2 = t.2;
					out.put3("depth=%d %q to %q", depth, t1.render, t2.render);
				}
				CONT_INDEX => out.put1("cont=%d", codeptr.read_uleb32());
			}
		}
		if (opcode.imms.length > 0) out.putc(']');
	}
}
