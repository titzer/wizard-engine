// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def sig: SigCache;
def sig_v_v = SigCache.v_v; // XXX: needed to force initialization
def imm: ImmSigs;
// An enumeration of the WebAssembly opcodes, including their mnenomic names,
// the kind of immediate expected, and the (monomorphic) operator signature.
enum Opcode(prefix: u8, code: u8, mnemonic: string, imms: Array<ImmKind>, sig: SigDecl) {
	// Default, invalid opcode.
	INVALID			(0x00, 0xFF, "<invalid>", imm.NONE, null),
	// Control and calls.
	UNREACHABLE		(0x00, 0x00, "unreachable", imm.NONE, null),
	NOP			(0x00, 0x01, "nop", imm.NONE, sig.v_v),
	BLOCK			(0x00, 0x02, "block", imm.BLOCKT, null),
	LOOP			(0x00, 0x03, "loop", imm.BLOCKT, null),
	IF			(0x00, 0x04, "if", imm.BLOCKT, null),
	ELSE			(0x00, 0x05, "else", imm.NONE, null),
	TRY			(0x00, 0x06, "try", imm.BLOCKT, null),
	CATCH			(0x00, 0x07, "catch", imm.TAG, null),
	THROW			(0x00, 0x08, "throw", imm.TAG, null),
	RETHROW			(0x00, 0x09, "rethrow", imm.LABEL, null),
	THROW_REF		(0x00, 0x0A, "throw_ref", imm.NONE, null),
	END			(0x00, 0x0B, "end", imm.NONE, null),
	BR			(0x00, 0x0C, "br", imm.LABEL, null),
	BR_IF			(0x00, 0x0D, "br_if", imm.LABEL, null),
	BR_TABLE		(0x00, 0x0E, "br_table", imm.LABELS, null),
	RETURN			(0x00, 0x0F, "return", imm.NONE, null),
	CALL			(0x00, 0x10, "call", imm.FUNC, null),
	CALL_INDIRECT		(0x00, 0x11, "call_indirect", imm.SIG_TABLE, null),
	RETURN_CALL		(0x00, 0x12, "return_call", imm.FUNC, null),
	RETURN_CALL_INDIRECT	(0x00, 0x13, "return_call_indirect", imm.SIG_TABLE, null),
	CALL_REF		(0x00, 0x14, "call_ref", imm.SIG, null),
	RETURN_CALL_REF		(0x00, 0x15, "return_call_ref", imm.SIG, null),
	DELEGATE		(0x00, 0x18, "delegate", imm.LABEL, null),
	CATCH_ALL		(0x00, 0x19, "catch_all", imm.NONE, null),
	DROP			(0x00, 0x1A, "drop", imm.NONE, null),
	SELECT			(0x00, 0x1B, "select", imm.NONE, null),
	SELECT_T		(0x00, 0x1C, "select", imm.VALTS, null),
	TRY_TABLE		(0x00, 0x1F, "try_table", imm.BLOCKT_CATCHES, null),
	// Locals.
	LOCAL_GET		(0x00, 0x20, "local.get", imm.LOCAL, null),
	LOCAL_SET		(0x00, 0x21, "local.set", imm.LOCAL, null),
	LOCAL_TEE		(0x00, 0x22, "local.tee", imm.LOCAL, null),
	// Globals.
	GLOBAL_GET		(0x00, 0x23, "global.get", imm.GLOBAL, null),
	GLOBAL_SET		(0x00, 0x24, "global.set", imm.GLOBAL, null),
	// Table elems.
	TABLE_GET		(0x00, 0x25, "table.get", imm.TABLE, null),
	TABLE_SET		(0x00, 0x26, "table.set", imm.TABLE, null),
	// Loads and stores.
	I32_LOAD		(0x00, 0x28, "i32.load", imm.MEMARG, sig.i_i),
	I64_LOAD		(0x00, 0x29, "i64.load", imm.MEMARG, sig.i_l),
	F32_LOAD		(0x00, 0x2A, "f32.load", imm.MEMARG, sig.i_f),
	F64_LOAD		(0x00, 0x2B, "f64.load", imm.MEMARG, sig.i_d),
	I32_LOAD8_S		(0x00, 0x2C, "i32.load8_s", imm.MEMARG, sig.i_i),
	I32_LOAD8_U		(0x00, 0x2D, "i32.load8_u", imm.MEMARG, sig.i_i),
	I32_LOAD16_S		(0x00, 0x2E, "i32.load16_s", imm.MEMARG, sig.i_i),
	I32_LOAD16_U		(0x00, 0x2F, "i32.load16_u", imm.MEMARG, sig.i_i),
	I64_LOAD8_S		(0x00, 0x30, "i64.load8_s", imm.MEMARG, sig.i_l),
	I64_LOAD8_U		(0x00, 0x31, "i64.load8_u", imm.MEMARG, sig.i_l),
	I64_LOAD16_S		(0x00, 0x32, "i64.load16_s", imm.MEMARG, sig.i_l),
	I64_LOAD16_U		(0x00, 0x33, "i64.load16_u", imm.MEMARG, sig.i_l),
	I64_LOAD32_S		(0x00, 0x34, "i64.load32_s", imm.MEMARG, sig.i_l),
	I64_LOAD32_U		(0x00, 0x35, "i64.load32_u", imm.MEMARG, sig.i_l),
	I32_STORE		(0x00, 0x36, "i32.store", imm.MEMARG, sig.ii_v),
	I64_STORE		(0x00, 0x37, "i64.store", imm.MEMARG, sig.il_v),
	F32_STORE		(0x00, 0x38, "f32.store", imm.MEMARG, sig.if_v),
	F64_STORE		(0x00, 0x39, "f64.store", imm.MEMARG, sig.id_v),
	I32_STORE8		(0x00, 0x3A, "i32.store8", imm.MEMARG, sig.ii_v),
	I32_STORE16		(0x00, 0x3B, "i32.store16", imm.MEMARG, sig.ii_v),
	I64_STORE8		(0x00, 0x3C, "i64.store8", imm.MEMARG, sig.il_v),
	I64_STORE16		(0x00, 0x3D, "i64.store16", imm.MEMARG, sig.il_v),
	I64_STORE32		(0x00, 0x3E, "i64.store32", imm.MEMARG, sig.il_v),
	// Misc memory.
	MEMORY_SIZE		(0x00, 0x3F, "memory.size", imm.MEMORY, sig.v_i),
	MEMORY_GROW		(0x00, 0x40, "memory.grow", imm.MEMORY, sig.i_i),
	// Constants.
	I32_CONST		(0x00, 0x41, "i32.const", imm.I32, sig.v_i),
	I64_CONST		(0x00, 0x42, "i64.const", imm.I64, sig.v_l),
	F32_CONST		(0x00, 0x43, "f32.const", imm.F32, sig.v_f),
	F64_CONST		(0x00, 0x44, "f64.const", imm.F64, sig.v_d),
	// Comparisons.
	I32_EQZ			(0x00, 0x45, "i32.eqz", imm.NONE, sig.i_i),
	I32_EQ			(0x00, 0x46, "i32.eq", imm.NONE, sig.ii_i),
	I32_NE			(0x00, 0x47, "i32.ne", imm.NONE, sig.ii_i),
	I32_LT_S		(0x00, 0x48, "i32.lt_s", imm.NONE, sig.ii_i),
	I32_LT_U		(0x00, 0x49, "i32.lt_u", imm.NONE, sig.ii_i),
	I32_GT_S		(0x00, 0x4A, "i32.gt_s", imm.NONE, sig.ii_i),
	I32_GT_U		(0x00, 0x4B, "i32.gt_u", imm.NONE, sig.ii_i),
	I32_LE_S		(0x00, 0x4C, "i32.le_s", imm.NONE, sig.ii_i),
	I32_LE_U		(0x00, 0x4D, "i32.le_u", imm.NONE, sig.ii_i),
	I32_GE_S		(0x00, 0x4E, "i32.ge_s", imm.NONE, sig.ii_i),
	I32_GE_U		(0x00, 0x4F, "i32.ge_u", imm.NONE, sig.ii_i),
	I64_EQZ			(0x00, 0x50, "i64.eqz", imm.NONE, sig.l_i),
	I64_EQ			(0x00, 0x51, "i64.eq", imm.NONE, sig.ll_i),
	I64_NE			(0x00, 0x52, "i64.ne", imm.NONE, sig.ll_i),
	I64_LT_S		(0x00, 0x53, "i64.lt_s", imm.NONE, sig.ll_i),
	I64_LT_U		(0x00, 0x54, "i64.lt_u", imm.NONE, sig.ll_i),
	I64_GT_S		(0x00, 0x55, "i64.gt_s", imm.NONE, sig.ll_i),
	I64_GT_U		(0x00, 0x56, "i64.gt_u", imm.NONE, sig.ll_i),
	I64_LE_S		(0x00, 0x57, "i64.le_s", imm.NONE, sig.ll_i),
	I64_LE_U		(0x00, 0x58, "i64.le_u", imm.NONE, sig.ll_i),
	I64_GE_S		(0x00, 0x59, "i64.ge_s", imm.NONE, sig.ll_i),
	I64_GE_U		(0x00, 0x5A, "i64.ge_u", imm.NONE, sig.ll_i),
	F32_EQ			(0x00, 0x5B, "f32.eq", imm.NONE, sig.ff_i),
	F32_NE			(0x00, 0x5C, "f32.ne", imm.NONE, sig.ff_i),
	F32_LT			(0x00, 0x5D, "f32.lt", imm.NONE, sig.ff_i),
	F32_GT			(0x00, 0x5E, "f32.gt", imm.NONE, sig.ff_i),
	F32_LE			(0x00, 0x5F, "f32.le", imm.NONE, sig.ff_i),
	F32_GE			(0x00, 0x60, "f32.ge", imm.NONE, sig.ff_i),
	F64_EQ			(0x00, 0x61, "f64.eq", imm.NONE, sig.dd_i),
	F64_NE			(0x00, 0x62, "f64.ne", imm.NONE, sig.dd_i),
	F64_LT			(0x00, 0x63, "f64.lt", imm.NONE, sig.dd_i),
	F64_GT			(0x00, 0x64, "f64.gt", imm.NONE, sig.dd_i),
	F64_LE			(0x00, 0x65, "f64.le", imm.NONE, sig.dd_i),
	F64_GE			(0x00, 0x66, "f64.ge", imm.NONE, sig.dd_i),
	// I32 arithmetic.
	I32_CLZ			(0x00, 0x67, "i32.clz", imm.NONE, sig.i_i),
	I32_CTZ			(0x00, 0x68, "i32.ctz", imm.NONE, sig.i_i),
	I32_POPCNT		(0x00, 0x69, "i32.popcnt", imm.NONE, sig.i_i),
	I32_ADD			(0x00, 0x6A, "i32.add", imm.NONE, sig.ii_i),
	I32_SUB			(0x00, 0x6B, "i32.sub", imm.NONE, sig.ii_i),
	I32_MUL			(0x00, 0x6C, "i32.mul", imm.NONE, sig.ii_i),
	I32_DIV_S		(0x00, 0x6D, "i32.div_s", imm.NONE, sig.ii_i),
	I32_DIV_U		(0x00, 0x6E, "i32.div_u", imm.NONE, sig.ii_i),
	I32_REM_S		(0x00, 0x6F, "i32.rem_s", imm.NONE, sig.ii_i),
	I32_REM_U		(0x00, 0x70, "i32.rem_u", imm.NONE, sig.ii_i),
	I32_AND			(0x00, 0x71, "i32.and", imm.NONE, sig.ii_i),
	I32_OR			(0x00, 0x72, "i32.or", imm.NONE, sig.ii_i),
	I32_XOR			(0x00, 0x73, "i32.xor", imm.NONE, sig.ii_i),
	I32_SHL			(0x00, 0x74, "i32.shl", imm.NONE, sig.ii_i),
	I32_SHR_S		(0x00, 0x75, "i32.shr_s", imm.NONE, sig.ii_i),
	I32_SHR_U		(0x00, 0x76, "i32.shr_u", imm.NONE, sig.ii_i),
	I32_ROTL		(0x00, 0x77, "i32.rotl", imm.NONE, sig.ii_i),
	I32_ROTR		(0x00, 0x78, "i32.rotr", imm.NONE, sig.ii_i),
	// I64 arithmetic.
	I64_CLZ			(0x00, 0x79, "i64.clz", imm.NONE, sig.l_l),
	I64_CTZ			(0x00, 0x7A, "i64.ctz", imm.NONE, sig.l_l),
	I64_POPCNT		(0x00, 0x7B, "i64.popcnt", imm.NONE, sig.l_l),
	I64_ADD			(0x00, 0x7C, "i64.add", imm.NONE, sig.ll_l),
	I64_SUB			(0x00, 0x7D, "i64.sub", imm.NONE, sig.ll_l),
	I64_MUL			(0x00, 0x7E, "i64.mul", imm.NONE, sig.ll_l),
	I64_DIV_S		(0x00, 0x7F, "i64.div_s", imm.NONE, sig.ll_l),
	I64_DIV_U		(0x00, 0x80, "i64.div_u", imm.NONE, sig.ll_l),
	I64_REM_S		(0x00, 0x81, "i64.rem_s", imm.NONE, sig.ll_l),
	I64_REM_U		(0x00, 0x82, "i64.rem_u", imm.NONE, sig.ll_l),
	I64_AND			(0x00, 0x83, "i64.and", imm.NONE, sig.ll_l),
	I64_OR			(0x00, 0x84, "i64.or", imm.NONE, sig.ll_l),
	I64_XOR			(0x00, 0x85, "i64.xor", imm.NONE, sig.ll_l),
	I64_SHL			(0x00, 0x86, "i64.shl", imm.NONE, sig.ll_l),
	I64_SHR_S		(0x00, 0x87, "i64.shr_s", imm.NONE, sig.ll_l),
	I64_SHR_U		(0x00, 0x88, "i64.shr_u", imm.NONE, sig.ll_l),
	I64_ROTL		(0x00, 0x89, "i64.rotl", imm.NONE, sig.ll_l),
	I64_ROTR		(0x00, 0x8A, "i64.rotr", imm.NONE, sig.ll_l),
	// F32 arithmetic.
	F32_ABS			(0x00, 0x8B, "f32.abs", imm.NONE, sig.f_f),
	F32_NEG			(0x00, 0x8C, "f32.neg", imm.NONE, sig.f_f),
	F32_CEIL		(0x00, 0x8D, "f32.ceil", imm.NONE, sig.f_f),
	F32_FLOOR		(0x00, 0x8E, "f32.floor", imm.NONE, sig.f_f),
	F32_TRUNC		(0x00, 0x8F, "f32.trunc", imm.NONE, sig.f_f),
	F32_NEAREST		(0x00, 0x90, "f32.nearest", imm.NONE, sig.f_f),
	F32_SQRT		(0x00, 0x91, "f32.sqrt", imm.NONE, sig.f_f),
	F32_ADD			(0x00, 0x92, "f32.add", imm.NONE, sig.ff_f),
	F32_SUB			(0x00, 0x93, "f32.sub", imm.NONE, sig.ff_f),
	F32_MUL			(0x00, 0x94, "f32.mul", imm.NONE, sig.ff_f),
	F32_DIV			(0x00, 0x95, "f32.div", imm.NONE, sig.ff_f),
	F32_MIN			(0x00, 0x96, "f32.min", imm.NONE, sig.ff_f),
	F32_MAX			(0x00, 0x97, "f32.max", imm.NONE, sig.ff_f),
	F32_COPYSIGN		(0x00, 0x98, "f32.copysign", imm.NONE, sig.ff_f),
	// F64 arithmetic.
	F64_ABS			(0x00, 0x99, "f64.abs", imm.NONE, sig.d_d),
	F64_NEG			(0x00, 0x9A, "f64.neg", imm.NONE, sig.d_d),
	F64_CEIL		(0x00, 0x9B, "f64.ceil", imm.NONE, sig.d_d),
	F64_FLOOR		(0x00, 0x9C, "f64.floor", imm.NONE, sig.d_d),
	F64_TRUNC		(0x00, 0x9D, "f64.trunc", imm.NONE, sig.d_d),
	F64_NEAREST		(0x00, 0x9E, "f64.nearest", imm.NONE, sig.d_d),
	F64_SQRT		(0x00, 0x9F, "f64.sqrt", imm.NONE, sig.d_d),
	F64_ADD			(0x00, 0xA0, "f64.add", imm.NONE, sig.dd_d),
	F64_SUB			(0x00, 0xA1, "f64.sub", imm.NONE, sig.dd_d),
	F64_MUL			(0x00, 0xA2, "f64.mul", imm.NONE, sig.dd_d),
	F64_DIV			(0x00, 0xA3, "f64.div", imm.NONE, sig.dd_d),
	F64_MIN			(0x00, 0xA4, "f64.min", imm.NONE, sig.dd_d),
	F64_MAX			(0x00, 0xA5, "f64.max", imm.NONE, sig.dd_d),
	F64_COPYSIGN		(0x00, 0xA6, "f64.copysign", imm.NONE, sig.dd_d),
	// Conversions and casts.
	I32_WRAP_I64		(0x00, 0xA7, "i32.wrap_i64", imm.NONE, sig.l_i),
	I32_TRUNC_F32_S		(0x00, 0xA8, "i32.trunc_f32_s", imm.NONE, sig.f_i),
	I32_TRUNC_F32_U		(0x00, 0xA9, "i32.trunc_f32_u", imm.NONE, sig.f_i),
	I32_TRUNC_F64_S		(0x00, 0xAA, "i32.trunc_f64_s", imm.NONE, sig.d_i),
	I32_TRUNC_F64_U		(0x00, 0xAB, "i32.trunc_f64_u", imm.NONE, sig.d_i),
	I64_EXTEND_I32_S	(0x00, 0xAC, "i64.extend_i32_s", imm.NONE, sig.i_l),
	I64_EXTEND_I32_U	(0x00, 0xAD, "i64.extend_i32_u", imm.NONE, sig.i_l),
	I64_TRUNC_F32_S		(0x00, 0xAE, "i64.trunc_f32_s", imm.NONE, sig.f_l),
	I64_TRUNC_F32_U		(0x00, 0xAF, "i64.trunc_f32_u", imm.NONE, sig.f_l),
	I64_TRUNC_F64_S		(0x00, 0xB0, "i64.trunc_f64_s", imm.NONE, sig.d_l),
	I64_TRUNC_F64_U		(0x00, 0xB1, "i64.trunc_f64_u", imm.NONE, sig.d_l),
	F32_CONVERT_I32_S	(0x00, 0xB2, "f32.convert_i32_s", imm.NONE, sig.i_f),
	F32_CONVERT_I32_U	(0x00, 0xB3, "f32.convert_i32_u", imm.NONE, sig.i_f),
	F32_CONVERT_I64_S	(0x00, 0xB4, "f32.convert_i64_s", imm.NONE, sig.l_f),
	F32_CONVERT_I64_U	(0x00, 0xB5, "f32.convert_i64_u", imm.NONE, sig.l_f),
	F32_DEMOTE_F64		(0x00, 0xB6, "f32.demote_f64", imm.NONE, sig.d_f),
	F64_CONVERT_I32_S	(0x00, 0xB7, "f64.convert_i32_s", imm.NONE, sig.i_d),
	F64_CONVERT_I32_U	(0x00, 0xB8, "f64.convert_i32_u", imm.NONE, sig.i_d),
	F64_CONVERT_I64_S	(0x00, 0xB9, "f64.convert_i64_s", imm.NONE, sig.l_d),
	F64_CONVERT_I64_U	(0x00, 0xBA, "f64.convert_i64_u", imm.NONE, sig.l_d),
	F64_PROMOTE_F32		(0x00, 0xBB, "f64.promote_f32", imm.NONE, sig.f_d),
	I32_REINTERPRET_F32	(0x00, 0xBC, "i32.reinterpret_f32", imm.NONE, sig.f_i),
	I64_REINTERPRET_F64	(0x00, 0xBD, "i64.reinterpret_f64", imm.NONE, sig.d_l),
	F32_REINTERPRET_I32	(0x00, 0xBE, "f32.reinterpret_i32", imm.NONE, sig.i_f),
	F64_REINTERPRET_I64	(0x00, 0xBF, "f64.reinterpret_i64", imm.NONE, sig.l_d),
	// Sign extensions.
	I32_EXTEND8_S		(0x00, 0xC0, "i32.extend8_s", imm.NONE, sig.i_i),
	I32_EXTEND16_S		(0x00, 0xC1, "i32.extend16_s", imm.NONE, sig.i_i),
	I64_EXTEND8_S		(0x00, 0xC2, "i64.extend8_s", imm.NONE, sig.l_l),
	I64_EXTEND16_S		(0x00, 0xC3, "i64.extend16_s", imm.NONE, sig.l_l),
	I64_EXTEND32_S		(0x00, 0xC4, "i64.extend32_s", imm.NONE, sig.l_l),
	// Reference instructions.
	REF_NULL		(0x00, 0xD0, "ref.null", imm.HEAPT, null),
	REF_IS_NULL		(0x00, 0xD1, "ref.is_null", imm.NONE, null),
	REF_FUNC		(0x00, 0xD2, "ref.func", imm.FUNC, null),
	REF_EQ			(0x00, 0xD3, "ref.eq", imm.NONE, null),
	REF_AS_NON_NULL		(0x00, 0xD4, "ref.as_non_null", imm.NONE, null),
	BR_ON_NULL		(0x00, 0xD5, "br_on_null", imm.LABEL, null),
	BR_ON_NON_NULL		(0x00, 0xD6, "br_on_non_null", imm.LABEL, null),
	// 0xFB prefix: gc proposal opcodes.
	STRUCT_NEW			(0xFB, 0x00, "struct.new", imm.STRUCTT, null),
	STRUCT_NEW_DEFAULT		(0xFB, 0x01, "struct.new_default", imm.STRUCTT, null),
	STRUCT_GET			(0xFB, 0x02, "struct.get", imm.STRUCTT_FIELD, null),
	STRUCT_GET_S			(0xFB, 0x03, "struct.get_s", imm.STRUCTT_FIELD, null),
	STRUCT_GET_U			(0xFB, 0x04, "struct.get_u", imm.STRUCTT_FIELD, null),
	STRUCT_SET			(0xFB, 0x05, "struct.set", imm.STRUCTT_FIELD, null),
	ARRAY_NEW			(0xFB, 0x06, "array.new", imm.ARRAYT, null),
	ARRAY_NEW_DEFAULT		(0xFB, 0x07, "array.new_default", imm.ARRAYT, null),
	ARRAY_NEW_FIXED			(0xFB, 0x08, "array.new_fixed", imm.ARRAYT_U32, null),
	ARRAY_NEW_DATA			(0xFB, 0x09, "array.new_data", imm.ARRAYT_DATA, null),
	ARRAY_NEW_ELEM			(0xFB, 0x0A, "array.new_elem", imm.ARRAYT_ELEM, null),
	ARRAY_GET			(0xFB, 0x0B, "array.get", imm.ARRAYT, null),
	ARRAY_GET_S			(0xFB, 0x0C, "array.get_s", imm.ARRAYT, null),
	ARRAY_GET_U			(0xFB, 0x0D, "array.get_u", imm.ARRAYT, null),
	ARRAY_SET			(0xFB, 0x0E, "array.set", imm.ARRAYT, null),
	ARRAY_LEN			(0xFB, 0x0F, "array.len", imm.NONE, null),
	ARRAY_FILL			(0xFB, 0x10, "array.fill", imm.ARRAYT, null),
	ARRAY_COPY			(0xFB, 0x11, "array.copy", imm.ARRAYT_ARRAYT, null),
	ARRAY_INIT_DATA			(0xFB, 0x12, "array.init_data", imm.ARRAYT_DATA, null),
	ARRAY_INIT_ELEM			(0xFB, 0x13, "array.init_elem", imm.ARRAYT_ELEM, null),
	REF_TEST			(0xFB, 0x14, "ref.test", imm.HEAPT, null),
	REF_TEST_NULL			(0xFB, 0x15, "ref.test null", imm.HEAPT, null),
	REF_CAST			(0xFB, 0x16, "ref.cast", imm.HEAPT, null),
	REF_CAST_NULL			(0xFB, 0x17, "ref.cast null", imm.HEAPT, null),
	BR_ON_CAST			(0xFB, 0x18, "br_on_cast", imm.BR_CAST_ARG, null),
	BR_ON_CAST_FAIL			(0xFB, 0x19, "br_on_cast_fail", imm.BR_CAST_ARG, null),
	ANY_CONVERT_EXTERN		(0xFB, 0x1A, "any.convert_extern", imm.NONE, null), // XXX: could have sig
	EXTERN_CONVERT_ANY		(0xFB, 0x1B, "extern.convert_any", imm.NONE, null), // XXX: could have sig
	REF_I31				(0xFB, 0x1C, "ref.i31", imm.NONE, null), // XXX: could have sig
	I31_GET_S			(0xFB, 0x1D, "i31.get_s", imm.NONE, null), // XXX: could have sig
	I31_GET_U			(0xFB, 0x1E, "i31.get_u", imm.NONE, null), // XXX: could have sig
	// 0xFC prefix: saturating truncations.
	I32_TRUNC_SAT_F32_S	(0xFC, 0x00, "i32.trunc_sat_f32_s", imm.NONE, sig.f_i),
	I32_TRUNC_SAT_F32_U	(0xFC, 0x01, "i32.trunc_sat_f32_u", imm.NONE, sig.f_i),
	I32_TRUNC_SAT_F64_S	(0xFC, 0x02, "i32.trunc_sat_f64_s", imm.NONE, sig.d_i),
	I32_TRUNC_SAT_F64_U	(0xFC, 0x03, "i32.trunc_sat_f64_u", imm.NONE, sig.d_i),
	I64_TRUNC_SAT_F32_S	(0xFC, 0x04, "i64.trunc_sat_f32_s", imm.NONE, sig.f_l),
	I64_TRUNC_SAT_F32_U	(0xFC, 0x05, "i64.trunc_sat_f32_u", imm.NONE, sig.f_l),
	I64_TRUNC_SAT_F64_S	(0xFC, 0x06, "i64.trunc_sat_f64_s", imm.NONE, sig.d_l),
	I64_TRUNC_SAT_F64_U	(0xFC, 0x07, "i64.trunc_sat_f64_u", imm.NONE, sig.d_l),
	// 0xFC prefix: bulk-memory and references.
	MEMORY_INIT		(0xFC, 0x08, "memory.init", imm.DATA_MEMORY, sig.iii_v),
	DATA_DROP		(0xFC, 0x09, "data.drop", imm.DATA, sig.v_v),
	MEMORY_COPY		(0xFC, 0x0A, "memory.copy", imm.MEMORY_MEMORY, sig.iii_v),
	MEMORY_FILL		(0xFC, 0x0B, "memory.fill", imm.MEMORY, sig.iii_v),
	TABLE_INIT		(0xFC, 0x0C, "table.init", imm.ELEM_TABLE, sig.iii_v),
	ELEM_DROP		(0xFC, 0x0D, "elem.drop", imm.ELEM, sig.v_v),
	TABLE_COPY		(0xFC, 0x0E, "table.copy", imm.TABLE_TABLE, sig.iii_v),
	TABLE_GROW		(0xFC, 0x0F, "table.grow", imm.TABLE, null),
	TABLE_SIZE		(0xFC, 0x10, "table.size", imm.TABLE, sig.v_i),
	TABLE_FILL		(0xFC, 0x11, "table.fill", imm.TABLE, null),
	// 0xFD prefix: vector instructions.
	V128_LOAD			(0xFD, 0, "v128.load", imm.MEMARG, sig.i_s),
	V128_LOAD_8X8_S			(0xFD, 1, "v128.load_8x8_s", imm.MEMARG, sig.i_s),
	V128_LOAD_8X8_U			(0xFD, 2, "v128.load_8x8_u", imm.MEMARG, sig.i_s),
	V128_LOAD_16X4_S		(0xFD, 3, "v128.load_16x4_s", imm.MEMARG, sig.i_s),
	V128_LOAD_16X4_U		(0xFD, 4, "v128.load_16x4_u", imm.MEMARG, sig.i_s),
	V128_LOAD_32X2_S		(0xFD, 5, "v128.load_32x2_s", imm.MEMARG, sig.i_s),
	V128_LOAD_32X2_U		(0xFD, 6, "v128.load_32x2_u", imm.MEMARG, sig.i_s),
	V128_LOAD_8_SPLAT		(0xFD, 7, "v128.load_8_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_16_SPLAT		(0xFD, 8, "v128.load_16_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_32_SPLAT		(0xFD, 9, "v128.load_32_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_64_SPLAT		(0xFD, 10, "v128.load_64_splat", imm.MEMARG, sig.i_s),
	V128_LOAD_32_ZERO		(0xFD, 92, "v128.load_32_zero", imm.MEMARG, sig.i_s),
	V128_LOAD_64_ZERO		(0xFD, 93, "v128.load_64_zero", imm.MEMARG, sig.i_s),
	V128_STORE			(0xFD, 11, "v128.store", imm.MEMARG, sig.is_v),
	V128_LOAD_8_LANE		(0xFD, 84, "v128.load_8_lane", imm.MEMARG_LANE, sig.is_s),
	V128_LOAD_16_LANE		(0xFD, 85, "v128.load_16_lane", imm.MEMARG_LANE, sig.is_s),
	V128_LOAD_32_LANE		(0xFD, 86, "v128.load_32_lane", imm.MEMARG_LANE, sig.is_s),
	V128_LOAD_64_LANE		(0xFD, 87, "v128.load_64_lane", imm.MEMARG_LANE, sig.is_s),
	V128_STORE_8_LANE		(0xFD, 88, "v128.store_8_lane", imm.MEMARG_LANE, sig.is_v),
	V128_STORE_16_LANE		(0xFD, 89, "v128.store_16_lane", imm.MEMARG_LANE, sig.is_v),
	V128_STORE_32_LANE		(0xFD, 90, "v128.store_32_lane", imm.MEMARG_LANE, sig.is_v),
	V128_STORE_64_LANE		(0xFD, 91, "v128.store_64_lane", imm.MEMARG_LANE, sig.is_v),
	V128_CONST			(0xFD, 12, "v128.const", imm.V128, sig.v_s),
	I8X16_SHUFFLE			(0xFD, 13, "i8x16.shuffle", imm.LANEx16, sig.ss_s),
	I8X16_EXTRACTLANE_S		(0xFD, 21, "i8x16.extractlane_s", imm.LANE, sig.s_i),
	I8X16_EXTRACTLANE_U		(0xFD, 22, "i8x16.extractlane_u", imm.LANE, sig.s_i),
	I8X16_REPLACELANE		(0xFD, 23, "i8x16.replacelane", imm.LANE, sig.si_s),
	I16X8_EXTRACTLANE_S		(0xFD, 24, "i16x8.extractlane_s", imm.LANE, sig.s_i),
	I16X8_EXTRACTLANE_U		(0xFD, 25, "i16x8.extractlane_u", imm.LANE, sig.s_i),
	I16X8_REPLACELANE		(0xFD, 26, "i16x8.replacelane", imm.LANE, sig.si_s),
	I32X4_EXTRACTLANE		(0xFD, 27, "i32x4.extractlane", imm.LANE, sig.s_i),
	I32X4_REPLACELANE		(0xFD, 28, "i32x4.replacelane", imm.LANE, sig.si_s),
	I64X2_EXTRACTLANE		(0xFD, 29, "i64x2.extractlane", imm.LANE, sig.s_l),
	I64X2_REPLACELANE		(0xFD, 30, "i64x2.replacelane", imm.LANE, sig.sl_s),
	F32X4_EXTRACTLANE		(0xFD, 31, "f32x4.extractlane", imm.LANE, sig.s_f),
	F32X4_REPLACELANE		(0xFD, 32, "f32x4.replacelane", imm.LANE, sig.sf_s),
	F64X2_EXTRACTLANE		(0xFD, 33, "f64x2.extractlane", imm.LANE, sig.s_d),
	F64X2_REPLACELANE		(0xFD, 34, "f64x2.replacelane", imm.LANE, sig.sd_s),
	I8X16_SWIZZLE			(0xFD, 14, "i8x16.swizzle", imm.NONE, sig.ss_s),
	I8X16_SPLAT			(0xFD, 15, "i8x16.splat", imm.NONE, sig.i_s),
	I16X8_SPLAT			(0xFD, 16, "i16x8.splat", imm.NONE, sig.i_s),
	I32X4_SPLAT			(0xFD, 17, "i32x4.splat", imm.NONE, sig.i_s),
	I64X2_SPLAT			(0xFD, 18, "i64x2.splat", imm.NONE, sig.l_s),
	F32X4_SPLAT			(0xFD, 19, "f32x4.splat", imm.NONE, sig.f_s),
	F64X2_SPLAT			(0xFD, 20, "f64x2.splat", imm.NONE, sig.d_s),
	I8X16_EQ			(0xFD, 35, "i8x16.eq", imm.NONE, sig.ss_s),
	I8X16_NE			(0xFD, 36, "i8x16.ne", imm.NONE, sig.ss_s),
	I8X16_LT_S			(0xFD, 37, "i8x16.lt_s", imm.NONE, sig.ss_s),
	I8X16_LT_U			(0xFD, 38, "i8x16.lt_u", imm.NONE, sig.ss_s),
	I8X16_GT_S			(0xFD, 39, "i8x16.gt_s", imm.NONE, sig.ss_s),
	I8X16_GT_U			(0xFD, 40, "i8x16.gt_u", imm.NONE, sig.ss_s),
	I8X16_LE_S			(0xFD, 41, "i8x16.le_s", imm.NONE, sig.ss_s),
	I8X16_LE_U			(0xFD, 42, "i8x16.le_u", imm.NONE, sig.ss_s),
	I8X16_GE_S			(0xFD, 43, "i8x16.ge_s", imm.NONE, sig.ss_s),
	I8X16_GE_U			(0xFD, 44, "i8x16.ge_u", imm.NONE, sig.ss_s),
	I16X8_EQ			(0xFD, 45, "i16x8.eq", imm.NONE, sig.ss_s),
	I16X8_NE			(0xFD, 46, "i16x8.ne", imm.NONE, sig.ss_s),
	I16X8_LT_S			(0xFD, 47, "i16x8.lt_s", imm.NONE, sig.ss_s),
	I16X8_LT_U			(0xFD, 48, "i16x8.lt_u", imm.NONE, sig.ss_s),
	I16X8_GT_S			(0xFD, 49, "i16x8.gt_s", imm.NONE, sig.ss_s),
	I16X8_GT_U			(0xFD, 50, "i16x8.gt_u", imm.NONE, sig.ss_s),
	I16X8_LE_S			(0xFD, 51, "i16x8.le_s", imm.NONE, sig.ss_s),
	I16X8_LE_U			(0xFD, 52, "i16x8.le_u", imm.NONE, sig.ss_s),
	I16X8_GE_S			(0xFD, 53, "i16x8.ge_s", imm.NONE, sig.ss_s),
	I16X8_GE_U			(0xFD, 54, "i16x8.ge_u", imm.NONE, sig.ss_s),
	I32X4_EQ			(0xFD, 55, "i32x4.eq", imm.NONE, sig.ss_s),
	I32X4_NE			(0xFD, 56, "i32x4.ne", imm.NONE, sig.ss_s),
	I32X4_LT_S			(0xFD, 57, "i32x4.lt_s", imm.NONE, sig.ss_s),
	I32X4_LT_U			(0xFD, 58, "i32x4.lt_u", imm.NONE, sig.ss_s),
	I32X4_GT_S			(0xFD, 59, "i32x4.gt_s", imm.NONE, sig.ss_s),
	I32X4_GT_U			(0xFD, 60, "i32x4.gt_u", imm.NONE, sig.ss_s),
	I32X4_LE_S			(0xFD, 61, "i32x4.le_s", imm.NONE, sig.ss_s),
	I32X4_LE_U			(0xFD, 62, "i32x4.le_u", imm.NONE, sig.ss_s),
	I32X4_GE_S			(0xFD, 63, "i32x4.ge_s", imm.NONE, sig.ss_s),
	I32X4_GE_U			(0xFD, 64, "i32x4.ge_u", imm.NONE, sig.ss_s),
	I64X2_EQ			(0xFD, 214, "i64x2.eq", imm.NONE, sig.ss_s),
	I64X2_NE			(0xFD, 215, "i64x2.ne", imm.NONE, sig.ss_s),
	I64X2_LT_S			(0xFD, 216, "i64x2.lt_s", imm.NONE, sig.ss_s),
	I64X2_GT_S			(0xFD, 217, "i64x2.gt_s", imm.NONE, sig.ss_s),
	I64X2_LE_S			(0xFD, 218, "i64x2.le_s", imm.NONE, sig.ss_s),
	I64X2_GE_S			(0xFD, 219, "i64x2.ge_s", imm.NONE, sig.ss_s),
	F32X4_EQ			(0xFD, 65, "f32x4.eq", imm.NONE, sig.ss_s),
	F32X4_NE			(0xFD, 66, "f32x4.ne", imm.NONE, sig.ss_s),
	F32X4_LT			(0xFD, 67, "f32x4.lt", imm.NONE, sig.ss_s),
	F32X4_GT			(0xFD, 68, "f32x4.gt", imm.NONE, sig.ss_s),
	F32X4_LE			(0xFD, 69, "f32x4.le", imm.NONE, sig.ss_s),
	F32X4_GE			(0xFD, 70, "f32x4.ge", imm.NONE, sig.ss_s),
	F64X2_EQ			(0xFD, 71, "f64x2.eq", imm.NONE, sig.ss_s),
	F64X2_NE			(0xFD, 72, "f64x2.ne", imm.NONE, sig.ss_s),
	F64X2_LT			(0xFD, 73, "f64x2.lt", imm.NONE, sig.ss_s),
	F64X2_GT			(0xFD, 74, "f64x2.gt", imm.NONE, sig.ss_s),
	F64X2_LE			(0xFD, 75, "f64x2.le", imm.NONE, sig.ss_s),
	F64X2_GE			(0xFD, 76, "f64x2.ge", imm.NONE, sig.ss_s),
	V128_NOT			(0xFD, 77, "v128.not", imm.NONE, sig.s_s),
	V128_AND			(0xFD, 78, "v128.and", imm.NONE, sig.ss_s),
	V128_ANDNOT			(0xFD, 79, "v128.andnot", imm.NONE, sig.ss_s),
	V128_OR				(0xFD, 80, "v128.or", imm.NONE, sig.ss_s),
	V128_XOR			(0xFD, 81, "v128.xor", imm.NONE, sig.ss_s),
	V128_BITSELECT			(0xFD, 82, "v128.bitselect", imm.NONE, sig.sss_s),
	V128_ANYTRUE			(0xFD, 83, "v128.anytrue", imm.NONE, sig.s_i),
	I8X16_ABS			(0xFD, 96, "i8x16.abs", imm.NONE, sig.s_s),
	I8X16_NEG			(0xFD, 97, "i8x16.neg", imm.NONE, sig.s_s),
	I8X16_POPCNT			(0xFD, 98, "i8x16.popcnt", imm.NONE, sig.s_s),
	I8X16_ALLTRUE			(0xFD, 99, "i8x16.alltrue", imm.NONE, sig.s_i),
	I8X16_BITMASK			(0xFD, 100, "i8x16.bitmask", imm.NONE, sig.s_i),
	I8X16_NARROW_I16X8_S		(0xFD, 101, "i8x16.narrow_i16x8_s", imm.NONE, sig.ss_s),
	I8X16_NARROW_I16X8_U		(0xFD, 102, "i8x16.narrow_i16x8_u", imm.NONE, sig.ss_s),
	I8X16_SHL			(0xFD, 107, "i8x16.shl", imm.NONE, sig.si_s),
	I8X16_SHR_S			(0xFD, 108, "i8x16.shr_s", imm.NONE, sig.si_s),
	I8X16_SHR_U			(0xFD, 109, "i8x16.shr_u", imm.NONE, sig.si_s),
	I8X16_ADD			(0xFD, 110, "i8x16.add", imm.NONE, sig.ss_s),
	I8X16_ADD_SAT_S			(0xFD, 111, "i8x16.add_sat_s", imm.NONE, sig.ss_s),
	I8X16_ADD_SAT_U			(0xFD, 112, "i8x16.add_sat_u", imm.NONE, sig.ss_s),
	I8X16_SUB			(0xFD, 113, "i8x16.sub", imm.NONE, sig.ss_s),
	I8X16_SUB_SAT_S			(0xFD, 114, "i8x16.sub_sat_s", imm.NONE, sig.ss_s),
	I8X16_SUB_SAT_U			(0xFD, 115, "i8x16.sub_sat_u", imm.NONE, sig.ss_s),
	I8X16_MIN_S			(0xFD, 118, "i8x16.min_s", imm.NONE, sig.ss_s),
	I8X16_MIN_U			(0xFD, 119, "i8x16.min_u", imm.NONE, sig.ss_s),
	I8X16_MAX_S			(0xFD, 120, "i8x16.max_s", imm.NONE, sig.ss_s),
	I8X16_MAX_U			(0xFD, 121, "i8x16.max_u", imm.NONE, sig.ss_s),
	I8X16_AVGR_U			(0xFD, 123, "i8x16.avgr_u", imm.NONE, sig.ss_s),
	I16X8_EXTADDPAIRWISE_I8X16_S	(0xFD, 124, "i16x8.extaddpairwise_i8x16_s", imm.NONE, sig.s_s),
	I16X8_EXTADDPAIRWISE_I8X16_U	(0xFD, 125, "i16x8.extaddpairwise_i8x16_u", imm.NONE, sig.s_s),
	I16X8_ABS			(0xFD, 128, "i16x8.abs", imm.NONE, sig.s_s),
	I16X8_NEG			(0xFD, 129, "i16x8.neg", imm.NONE, sig.s_s),
	I16X8_Q15MULRSAT_S		(0xFD, 130, "i16x8.q15mulrsat_s", imm.NONE, sig.ss_s),
	I16X8_ALLTRUE			(0xFD, 131, "i16x8.alltrue", imm.NONE, sig.s_i),
	I16X8_BITMASK			(0xFD, 132, "i16x8.bitmask", imm.NONE, sig.s_i),
	I16X8_NARROW_I32X4_S		(0xFD, 133, "i16x8.narrow_i32x4_s", imm.NONE, sig.ss_s),
	I16X8_NARROW_I32X4_U		(0xFD, 134, "i16x8.narrow_i32x4_u", imm.NONE, sig.ss_s),
	I16X8_EXTEND_LOW_I8X16_S	(0xFD, 135, "i16x8.extend_low_i8x16_s", imm.NONE, sig.s_s),
	I16X8_EXTEND_HIGH_I8X16_S	(0xFD, 136, "i16x8.extend_high_i8x16_s", imm.NONE, sig.s_s),
	I16X8_EXTEND_LOW_I8X16_U	(0xFD, 137, "i16x8.extend_low_i8x16_u", imm.NONE, sig.s_s),
	I16X8_EXTEND_HIGH_I8X16_U	(0xFD, 138, "i16x8.extend_high_i8x16_u", imm.NONE, sig.s_s),
	I16X8_SHL			(0xFD, 139, "i16x8.shl", imm.NONE, sig.si_s),
	I16X8_SHR_S			(0xFD, 140, "i16x8.shr_s", imm.NONE, sig.si_s),
	I16X8_SHR_U			(0xFD, 141, "i16x8.shr_u", imm.NONE, sig.si_s),
	I16X8_ADD			(0xFD, 142, "i16x8.add", imm.NONE, sig.ss_s),
	I16X8_ADD_SAT_S			(0xFD, 143, "i16x8.add_sat_s", imm.NONE, sig.ss_s),
	I16X8_ADD_SAT_U			(0xFD, 144, "i16x8.add_sat_u", imm.NONE, sig.ss_s),
	I16X8_SUB			(0xFD, 145, "i16x8.sub", imm.NONE, sig.ss_s),
	I16X8_SUB_SAT_S			(0xFD, 146, "i16x8.sub_sat_s", imm.NONE, sig.ss_s),
	I16X8_SUB_SAT_U			(0xFD, 147, "i16x8.sub_sat_u", imm.NONE, sig.ss_s),
	I16X8_MUL			(0xFD, 149, "i16x8.mul", imm.NONE, sig.ss_s),
	I16X8_MIN_S			(0xFD, 150, "i16x8.min_s", imm.NONE, sig.ss_s),
	I16X8_MIN_U			(0xFD, 151, "i16x8.min_u", imm.NONE, sig.ss_s),
	I16X8_MAX_S			(0xFD, 152, "i16x8.max_s", imm.NONE, sig.ss_s),
	I16X8_MAX_U			(0xFD, 153, "i16x8.max_u", imm.NONE, sig.ss_s),
	I16X8_AVGR_U			(0xFD, 155, "i16x8.avgr_u", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_LOW_I8X16_S	(0xFD, 156, "i16x8.extmul_low_i8x16_s", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_HIGH_I8X16_S	(0xFD, 157, "i16x8.extmul_high_i8x16_s", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_LOW_I8X16_U	(0xFD, 158, "i16x8.extmul_low_i8x16_u", imm.NONE, sig.ss_s),
	I16X8_EXTMUL_HIGH_I8X16_U	(0xFD, 159, "i16x8.extmul_high_i8x16_u", imm.NONE, sig.ss_s),
	I32X4_EXTADDPAIRWISE_I16X8_S	(0xFD, 126, "i32x4.extaddpairwise_i16x8_s", imm.NONE, sig.s_s),
	I32X4_EXTADDPAIRWISE_I16X8_U	(0xFD, 127, "i32x4.extaddpairwise_i16x8_u", imm.NONE, sig.s_s),
	I32X4_ABS			(0xFD, 160, "i32x4.abs", imm.NONE, sig.s_s),
	I32X4_NEG			(0xFD, 161, "i32x4.neg", imm.NONE, sig.s_s),
	I32X4_ALLTRUE			(0xFD, 163, "i32x4.alltrue", imm.NONE, sig.s_i),
	I32X4_BITMASK			(0xFD, 164, "i32x4.bitmask", imm.NONE, sig.s_i),
	I32X4_EXTEND_LOW_I16X8_S	(0xFD, 167, "i32x4.extend_low_i16x8_s", imm.NONE, sig.s_s),
	I32X4_EXTEND_HIGH_I16X8_S	(0xFD, 168, "i32x4.extend_high_i16x8_s", imm.NONE, sig.s_s),
	I32X4_EXTEND_LOW_I16X8_U	(0xFD, 169, "i32x4.extend_low_i16x8_u", imm.NONE, sig.s_s),
	I32X4_EXTEND_HIGH_I16X8_U	(0xFD, 170, "i32x4.extend_high_i16x8_u", imm.NONE, sig.s_s),
	I32X4_SHL			(0xFD, 171, "i32x4.shl", imm.NONE, sig.si_s),
	I32X4_SHR_S			(0xFD, 172, "i32x4.shr_s", imm.NONE, sig.si_s),
	I32X4_SHR_U			(0xFD, 173, "i32x4.shr_u", imm.NONE, sig.si_s),
	I32X4_ADD			(0xFD, 174, "i32x4.add", imm.NONE, sig.ss_s),
	I32X4_SUB			(0xFD, 177, "i32x4.sub", imm.NONE, sig.ss_s),
	I32X4_MUL			(0xFD, 181, "i32x4.mul", imm.NONE, sig.ss_s),
	I32X4_MIN_S			(0xFD, 182, "i32x4.min_s", imm.NONE, sig.ss_s),
	I32X4_MIN_U			(0xFD, 183, "i32x4.min_u", imm.NONE, sig.ss_s),
	I32X4_MAX_S			(0xFD, 184, "i32x4.max_s", imm.NONE, sig.ss_s),
	I32X4_MAX_U			(0xFD, 185, "i32x4.max_u", imm.NONE, sig.ss_s),
	I32X4_DOT_I16X8_S		(0xFD, 186, "i32x4.dot_i16x8_s", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_LOW_I16X8_S	(0xFD, 188, "i32x4.extmul_low_i16x8_s", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_HIGH_I16X8_S	(0xFD, 189, "i32x4.extmul_high_i16x8_s", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_LOW_I16X8_U	(0xFD, 190, "i32x4.extmul_low_i16x8_u", imm.NONE, sig.ss_s),
	I32X4_EXTMUL_HIGH_I16X8_U	(0xFD, 191, "i32x4.extmul_high_i16x8_u", imm.NONE, sig.ss_s),
	I64X2_ABS			(0xFD, 192, "i64x2.abs", imm.NONE, sig.s_s),
	I64X2_NEG			(0xFD, 193, "i64x2.neg", imm.NONE, sig.s_s),
	I64X2_ALLTRUE			(0xFD, 195, "i64x2.alltrue", imm.NONE, sig.s_i),
	I64X2_BITMASK			(0xFD, 196, "i64x2.bitmask", imm.NONE, sig.s_i),
	I64X2_EXTEND_LOW_I32X4_S	(0xFD, 199, "i64x2.extend_low_i32x4_s", imm.NONE, sig.s_s),
	I64X2_EXTEND_HIGH_I32X4_S	(0xFD, 200, "i64x2.extend_high_i32x4_s", imm.NONE, sig.s_s),
	I64X2_EXTEND_LOW_I32X4_U	(0xFD, 201, "i64x2.extend_low_i32x4_u", imm.NONE, sig.s_s),
	I64X2_EXTEND_HIGH_I32X4_U	(0xFD, 202, "i64x2.extend_high_i32x4_u", imm.NONE, sig.s_s),
	I64X2_SHL			(0xFD, 203, "i64x2.shl", imm.NONE, sig.si_s),
	I64X2_SHR_S			(0xFD, 204, "i64x2.shr_s", imm.NONE, sig.si_s),
	I64X2_SHR_U			(0xFD, 205, "i64x2.shr_u", imm.NONE, sig.si_s),
	I64X2_ADD			(0xFD, 206, "i64x2.add", imm.NONE, sig.ss_s),
	I64X2_SUB			(0xFD, 209, "i64x2.sub", imm.NONE, sig.ss_s),
	I64X2_MUL			(0xFD, 213, "i64x2.mul", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_LOW_I32X4_S	(0xFD, 220, "i64x2.extmul_low_i32x4_s", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_HIGH_I32X4_S	(0xFD, 221, "i64x2.extmul_high_i32x4_s", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_LOW_I32X4_U	(0xFD, 222, "i64x2.extmul_low_i32x4_u", imm.NONE, sig.ss_s),
	I64X2_EXTMUL_HIGH_I32X4_U	(0xFD, 223, "i64x2.extmul_high_i32x4_u", imm.NONE, sig.ss_s),
	F32X4_CEIL			(0xFD, 103, "f32x4.ceil", imm.NONE, sig.s_s),
	F32X4_FLOOR			(0xFD, 104, "f32x4.floor", imm.NONE, sig.s_s),
	F32X4_TRUNC			(0xFD, 105, "f32x4.trunc", imm.NONE, sig.s_s),
	F32X4_NEAREST			(0xFD, 106, "f32x4.nearest", imm.NONE, sig.s_s),
	F32X4_ABS			(0xFD, 224, "f32x4.abs", imm.NONE, sig.s_s),
	F32X4_NEG			(0xFD, 225, "f32x4.neg", imm.NONE, sig.s_s),
	F32X4_SQRT			(0xFD, 227, "f32x4.sqrt", imm.NONE, sig.s_s),
	F32X4_ADD			(0xFD, 228, "f32x4.add", imm.NONE, sig.ss_s),
	F32X4_SUB			(0xFD, 229, "f32x4.sub", imm.NONE, sig.ss_s),
	F32X4_MUL			(0xFD, 230, "f32x4.mul", imm.NONE, sig.ss_s),
	F32X4_DIV			(0xFD, 231, "f32x4.div", imm.NONE, sig.ss_s),
	F32X4_MIN			(0xFD, 232, "f32x4.min", imm.NONE, sig.ss_s),
	F32X4_MAX			(0xFD, 233, "f32x4.max", imm.NONE, sig.ss_s),
	F32X4_PMIN			(0xFD, 234, "f32x4.pmin", imm.NONE, sig.ss_s),
	F32X4_PMAX			(0xFD, 235, "f32x4.pmax", imm.NONE, sig.ss_s),
	F64X2_CEIL			(0xFD, 116, "f64x2.ceil", imm.NONE, sig.s_s),
	F64X2_FLOOR			(0xFD, 117, "f64x2.floor", imm.NONE, sig.s_s),
	F64X2_TRUNC			(0xFD, 122, "f64x2.trunc", imm.NONE, sig.s_s),
	F64X2_NEAREST			(0xFD, 148, "f64x2.nearest", imm.NONE, sig.s_s),
	F64X2_ABS			(0xFD, 236, "f64x2.abs", imm.NONE, sig.s_s),
	F64X2_NEG			(0xFD, 237, "f64x2.neg", imm.NONE, sig.s_s),
	F64X2_SQRT			(0xFD, 239, "f64x2.sqrt", imm.NONE, sig.s_s),
	F64X2_ADD			(0xFD, 240, "f64x2.add", imm.NONE, sig.ss_s),
	F64X2_SUB			(0xFD, 241, "f64x2.sub", imm.NONE, sig.ss_s),
	F64X2_MUL			(0xFD, 242, "f64x2.mul", imm.NONE, sig.ss_s),
	F64X2_DIV			(0xFD, 243, "f64x2.div", imm.NONE, sig.ss_s),
	F64X2_MIN			(0xFD, 244, "f64x2.min", imm.NONE, sig.ss_s),
	F64X2_MAX			(0xFD, 245, "f64x2.max", imm.NONE, sig.ss_s),
	F64X2_PMIN			(0xFD, 246, "f64x2.pmin", imm.NONE, sig.ss_s),
	F64X2_PMAX			(0xFD, 247, "f64x2.pmax", imm.NONE, sig.ss_s),
	I32X4_TRUNC_SAT_F32X4_S		(0xFD, 248, "i32x4.trunc_sat_f32x4_s", imm.NONE, sig.s_s),
	I32X4_TRUNC_SAT_F32X4_U		(0xFD, 249, "i32x4.trunc_sat_f32x4_u", imm.NONE, sig.s_s),
	F32X4_CONVERT_I32X4_S		(0xFD, 250, "f32x4.convert_i32x4_s", imm.NONE, sig.s_s),
	F32X4_CONVERT_I32X4_U		(0xFD, 251, "f32x4.convert_i32x4_u", imm.NONE, sig.s_s),
	I32X4_TRUNC_SAT_F64X2_S_ZERO	(0xFD, 252, "i32x4.trunc_sat_f64x2_s_zero", imm.NONE, sig.s_s),
	I32X4_TRUNC_SAT_F64X2_U_ZERO	(0xFD, 253, "i32x4.trunc_sat_f64x2_u_zero", imm.NONE, sig.s_s),
	F64X2_CONVERT_LOW_I32X4_S	(0xFD, 254, "f64x2.convert_low_i32x4_s", imm.NONE, sig.s_s),
	F64X2_CONVERT_LOW_I32X4_U	(0xFD, 255, "f64x2.convert_low_i32x4_u", imm.NONE, sig.s_s),
	F32X4_DEMOTE_F64X2_ZERO		(0xFD, 94, "f32x4.demote_f64x2_zero", imm.NONE, sig.s_s),
	F64X2_PROMOTE_LOW_F32X4		(0xFD, 95, "f64x2.promote_low_f32x4", imm.NONE, sig.s_s),
	// 0xFE prefix: atomics.
	MEMORY_ATOMIC_NOTIFY		(0xFE, 0x00, "memory.atomic.notify", imm.MEMARG, sig.ii_i),
	MEMORY_ATOMIC_WAIT32		(0xFE, 0x01, "memory.atomic.wait32", imm.MEMARG, sig.iil_i),
	MEMORY_ATOMIC_WAIT64		(0xFE, 0x02, "memory.atomic.wait64", imm.MEMARG, sig.ill_i),
	ATOMIC_FENCE			(0xFE, 0x03, "atomic.fence", imm.ZEROB, sig.v_v),
	I32_ATOMIC_LOAD			(0xFE, 0x10, "i32.atomic.load", imm.MEMARG, sig.i_i),
	I64_ATOMIC_LOAD			(0xFE, 0x11, "i64.atomic.load", imm.MEMARG, sig.i_l),
	I32_ATOMIC_LOAD8_U		(0xFE, 0x12, "i32.atomic.load8_u", imm.MEMARG, sig.i_i),
	I32_ATOMIC_LOAD16_U		(0xFE, 0x13, "i32.atomic.load16_u", imm.MEMARG, sig.i_i),
	I64_ATOMIC_LOAD8_U		(0xFE, 0x14, "i64.atomic.load8_u", imm.MEMARG, sig.i_l),
	I64_ATOMIC_LOAD16_U		(0xFE, 0x15, "i64.atomic.load16_u", imm.MEMARG, sig.i_l),
	I64_ATOMIC_LOAD32_U		(0xFE, 0x16, "i64.atomic.load32_u", imm.MEMARG, sig.i_l),
	I32_ATOMIC_STORE		(0xFE, 0x17, "i32.atomic.store", imm.MEMARG, sig.ii_v),
	I64_ATOMIC_STORE		(0xFE, 0x18, "i64.atomic.store", imm.MEMARG, sig.il_v),
	I32_ATOMIC_STORE8		(0xFE, 0x19, "i32.atomic.store8", imm.MEMARG, sig.ii_v),
	I32_ATOMIC_STORE16		(0xFE, 0x1A, "i32.atomic.store16", imm.MEMARG, sig.ii_v),
	I64_ATOMIC_STORE8		(0xFE, 0x1B, "i64.atomic.store8", imm.MEMARG, sig.il_v),
	I64_ATOMIC_STORE16		(0xFE, 0x1C, "i64.atomic.store16", imm.MEMARG, sig.il_v),
	I64_ATOMIC_STORE32		(0xFE, 0x1D, "i64.atomic.store32", imm.MEMARG, sig.il_v),
	I32_ATOMIC_RMW_ADD		(0xFE, 0x1E, "i32.atomic.rmw.add", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_ADD		(0xFE, 0x1F, "i64.atomic.rmw.add", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_ADD_U		(0xFE, 0x20, "i32.atomic.rmw8.add_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_ADD_U		(0xFE, 0x21, "i32.atomic.rmw16.add_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_ADD_U		(0xFE, 0x22, "i64.atomic.rmw8.add_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_ADD_U		(0xFE, 0x23, "i64.atomic.rmw16.add_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_ADD_U		(0xFE, 0x24, "i64.atomic.rmw32.add_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_SUB		(0xFE, 0x25, "i32.atomic.rmw.sub", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_SUB		(0xFE, 0x26, "i64.atomic.rmw.sub", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_SUB_U		(0xFE, 0x27, "i32.atomic.rmw8.sub_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_SUB_U		(0xFE, 0x28, "i32.atomic.rmw16.sub_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_SUB_U		(0xFE, 0x29, "i64.atomic.rmw8.sub_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_SUB_U		(0xFE, 0x2A, "i64.atomic.rmw16.sub_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_SUB_U		(0xFE, 0x2B, "i64.atomic.rmw32.sub_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_AND		(0xFE, 0x2C, "i32.atomic.rmw.and", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_AND		(0xFE, 0x2D, "i64.atomic.rmw.and", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_AND_U		(0xFE, 0x2E, "i32.atomic.rmw8.and_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_AND_U		(0xFE, 0x2F, "i32.atomic.rmw16.and_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_AND_U		(0xFE, 0x30, "i64.atomic.rmw8.and_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_AND_U		(0xFE, 0x31, "i64.atomic.rmw16.and_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_AND_U		(0xFE, 0x32, "i64.atomic.rmw32.and_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_OR		(0xFE, 0x33, "i32.atomic.rmw.or", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_OR		(0xFE, 0x34, "i64.atomic.rmw.or", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_OR_U		(0xFE, 0x35, "i32.atomic.rmw8.or_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_OR_U		(0xFE, 0x36, "i32.atomic.rmw16.or_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_OR_U		(0xFE, 0x37, "i64.atomic.rmw8.or_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_OR_U		(0xFE, 0x38, "i64.atomic.rmw16.or_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_OR_U		(0xFE, 0x39, "i64.atomic.rmw32.or_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_XOR		(0xFE, 0x3A, "i32.atomic.rmw.xor", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_XOR		(0xFE, 0x3B, "i64.atomic.rmw.xor", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_XOR_U		(0xFE, 0x3C, "i32.atomic.rmw8.xor_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_XOR_U		(0xFE, 0x3D, "i32.atomic.rmw16.xor_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_XOR_U		(0xFE, 0x3E, "i64.atomic.rmw8.xor_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_XOR_U		(0xFE, 0x3F, "i64.atomic.rmw16.xor_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_XOR_U		(0xFE, 0x40, "i64.atomic.rmw32.xor_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_XCHG		(0xFE, 0x41, "i32.atomic.rmw.xchg", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW_XCHG		(0xFE, 0x42, "i64.atomic.rmw.xchg", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW8_XCHG_U		(0xFE, 0x43, "i32.atomic.rmw8.xchg_u", imm.MEMARG, sig.ii_i),
	I32_ATOMIC_RMW16_XCHG_U		(0xFE, 0x44, "i32.atomic.rmw16.xchg_u", imm.MEMARG, sig.ii_i),
	I64_ATOMIC_RMW8_XCHG_U		(0xFE, 0x45, "i64.atomic.rmw8.xchg_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW16_XCHG_U		(0xFE, 0x46, "i64.atomic.rmw16.xchg_u", imm.MEMARG, sig.il_l),
	I64_ATOMIC_RMW32_XCHG_U		(0xFE, 0x47, "i64.atomic.rmw32.xchg_u", imm.MEMARG, sig.il_l),
	I32_ATOMIC_RMW_CMPXCHG		(0xFE, 0x48, "i32.atomic.rmw.cmpxchg", imm.MEMARG, sig.iii_i),
	I64_ATOMIC_RMW_CMPXCHG		(0xFE, 0x49, "i64.atomic.rmw.cmpxchg", imm.MEMARG, sig.ill_l),
	I32_ATOMIC_RMW8_CMPXCHG_U	(0xFE, 0x4A, "i32.atomic.rmw8.cmpxchg_u", imm.MEMARG, sig.iii_i),
	I32_ATOMIC_RMW16_CMPXCHG_U	(0xFE, 0x4B, "i32.atomic.rmw16.cmpxchg_u", imm.MEMARG, sig.iii_i),
	I64_ATOMIC_RMW8_CMPXCHG_U	(0xFE, 0x4C, "i64.atomic.rmw8.cmpxchg_u", imm.MEMARG, sig.ill_l),
	I64_ATOMIC_RMW16_CMPXCHG_U	(0xFE, 0x4D, "i64.atomic.rmw16.cmpxchg_u", imm.MEMARG, sig.ill_l),
	I64_ATOMIC_RMW32_CMPXCHG_U	(0xFE, 0x4E, "i64.atomic.rmw32.cmpxchg_u", imm.MEMARG, sig.ill_l),

	CONT_NEW			(0x00, 0xE0, "cont.new", imm.CONT, null),
	CONT_BIND			(0x00, 0xE1, "cont.bind", imm.CONT_CONT, null),
	SUSPEND				(0x00, 0xE2, "suspend", imm.TAG, null),
	RESUME				(0x00, 0xE3, "resume", imm.CONT_HANDLE, null),
	RESUME_THROW			(0x00, 0xE4, "resume.throw", imm.CONT_TAG_HANDLE, null)
}

// Enumeration of the different kinds of immediates to opcodes.
enum ImmKind {
	ARRAY_TYPE_INDEX,	// ARRAYT
	BLOCK_TYPE,		// BLOCKT
	DATA_INDEX,		// DATA
	ELEM_INDEX,		// ELEM
	TAG_INDEX,		// TAG
	FIELD_INDEX,		// FIELD
	FUNC_INDEX,		// FUNC
	GLOBAL_INDEX,		// GLOBAL
	LABEL,			// LABEL
	LABELS,			// LABELs
	LOCAL_INDEX,		// LOCAL
	MEMARG,			// MEMARG
	MEMORY_INDEX,		// MEMORY
	HEAP_TYPE,		// HEAPT
	SIG_INDEX,		// SIG
	STRUCT_TYPE_INDEX,	// STRUCTT
	TABLE_INDEX,		// TABLE
	VALUE_TYPES,		// VALTs
	ZERO_BYTE,		// ZEROB
	U32,			// U32
	I32,			// I32
	I64,			// I64
	F32,			// F32
	F64,			// F64
	V128,			// V128
	LANE_INDEX,		// LANE
	BR_CAST,		// BR_CAST
	CATCHES,		// CATCH
	CONT_INDEX,		// CONT
	EX_HANDLERS		// EX_HANDLERS
	SUS_HANDLERS	// SUS_HANDLERS
}
// Cached immediate signatures
component ImmSigs {
	def NONE = Array<ImmKind>.new(0);
	// Singleton immediate signatures.
	def BLOCKT = [ImmKind.BLOCK_TYPE];
	def DATA = [ImmKind.DATA_INDEX];
	def ELEM = [ImmKind.ELEM_INDEX];
	def TAG = [ImmKind.TAG_INDEX];
	def FUNC = [ImmKind.FUNC_INDEX];
	def GLOBAL = [ImmKind.GLOBAL_INDEX];
	def LABEL = [ImmKind.LABEL];
	def LABELS = [ImmKind.LABELS];
	def LOCAL = [ImmKind.LOCAL_INDEX];
	def MEMARG = [ImmKind.MEMARG];
	def MEMORY = [ImmKind.MEMORY_INDEX];
	def SIG = [ImmKind.SIG_INDEX];
	def HEAPT = [ImmKind.HEAP_TYPE];
	def ARRAYT = [ImmKind.ARRAY_TYPE_INDEX];
	def STRUCTT = [ImmKind.STRUCT_TYPE_INDEX];
	def TABLE = [ImmKind.TABLE_INDEX];
	def VALTS = [ImmKind.VALUE_TYPES];
	def ZEROB = [ImmKind.ZERO_BYTE];
	def I32 = [ImmKind.I32];
	def I64 = [ImmKind.I64];
	def F32 = [ImmKind.F32];
	def F64 = [ImmKind.F64];
	def V128 = [ImmKind.V128];
	def LANE = [ImmKind.LANE_INDEX];
	def BLOCKT_CATCHES = [ImmKind.BLOCK_TYPE, ImmKind.CATCHES];
	// Combination signatures.
	def STRUCTT_FIELD = [ImmKind.STRUCT_TYPE_INDEX, ImmKind.FIELD_INDEX];
	def DATA_MEMORY = [ImmKind.DATA_INDEX, ImmKind.MEMORY_INDEX];
	def ELEM_TABLE = [ImmKind.ELEM_INDEX, ImmKind.TABLE_INDEX];
	def MEMORY_MEMORY = [ImmKind.MEMORY_INDEX, ImmKind.MEMORY_INDEX];
	def TABLE_TABLE = [ImmKind.TABLE_INDEX, ImmKind.TABLE_INDEX];
	def SIG_TABLE = [ImmKind.SIG_INDEX, ImmKind.TABLE_INDEX];
	def ARRAYT_U32 = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.U32];
	def ARRAYT_DATA = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.DATA_INDEX];
	def ARRAYT_ELEM = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.ELEM_INDEX];
	def BR_CAST_ARG = [ImmKind.BR_CAST];
	private def L = ImmKind.LANE_INDEX;
	def LANEx16 = [L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L];
	def MEMARG_LANE = [ImmKind.MEMARG, ImmKind.LANE_INDEX];
	def ARRAYT_ARRAYT = [ImmKind.ARRAY_TYPE_INDEX, ImmKind.ARRAY_TYPE_INDEX];
	// Continuation operation signatures.
	def CONT = [ImmKind.CONT_INDEX];
	def CONT_CONT = [ImmKind.CONT_INDEX, ImmKind.CONT_INDEX];
	def CONT_HANDLE = [ImmKind.CONT_INDEX, ImmKind.SUS_HANDLERS];
	def CONT_TAG_HANDLE = [ImmKind.CONT_INDEX, ImmKind.TAG_INDEX, ImmKind.SUS_HANDLERS];
}

// Internal opcodes used by the interpreter.
enum InternalOpcode(code: u8, mnemonic: string) {
	PROBE(0x1E, "<probe>"),	// Used to overwrite a bytecode where a probe has been inserted
	WHAMM_PROBE(0x1D, "<whamm-probe>"),
	//PROBE_COUNTER
	//PROBE_COUNTER_n
	//PROBE_TOS_i
	//PROBE_WASM
	//PROBE_SAMPLE
	//PROBE_LIMIT
	CRASH_EXEC(0xF0, "<crash-execution>"), // Used to induce an execution crash
	CRASH_COMPILER(0xF1, "<crash-compiler>"), // Used to induce a compiler crash
}
// Various computed attributes about opcodes.
enum OpcodeAttribute {
	SHORT_OP,
	INTERNAL,
	VALID,
	CONSTANT,
	EXTENDED_CONSTANT
}
// A 256-entry page for dealing with prefixed opcodes.
class OpcodePage(prefix: byte) {
	private def valid = Array<u32>.new(8);  // bitmap for valid
	def opcodes = Array<Opcode>.new(256);
	def var oneByte = true;

	def put(opcode: Opcode) {
		valid[opcode.code >> 5] |= 1u << u5.view(opcode.code);
		opcodes[opcode.code] = opcode;
		if (prefix != 0 && opcode.code >= 128) oneByte = false; // need full LEB decoding for this page
	}
	def isValid(code: u32) -> bool {
		if (code >= opcodes.length) return false;
		var entry = valid[u8.view(code >> 5)];
		return (entry & (1u << u5.view(code))) != 0;
	}
	def [code: u32] -> Opcode {
		if (code >= opcodes.length) return Opcode.UNREACHABLE;
		return opcodes[u8.view(code)];
	}
}

def countOpcodes() -> i31 {
	var count = 0;
	for (op in Opcode) count++;
	return i31.!(count);
}
// Utilities for Wasm opcodes.
component Opcodes {
	def count = countOpcodes();
	def page_by_prefix = Array<OpcodePage>.new(256);
	def opcode_by_prefix = Array<Opcode>.new(256);

	def page_00 = OpcodePage.new(0);
	def attributes = Array<OpcodeAttribute.set>.new(count);
	def page_FB = page_by_prefix[0xFB] = OpcodePage.new(0xFB);
	def page_FC = page_by_prefix[0xFC] = OpcodePage.new(0xFC);
	def page_FD = page_by_prefix[0xFD] = OpcodePage.new(0xFD);
	def page_FE = page_by_prefix[0xFE] = OpcodePage.new(0xFE);
	def code_pages = [page_FB, page_FC, page_FD, page_FE];
	def var longestName: int;
	private var nameMap: HashMap<string, Opcode>;

	new() {
		for (op in Opcode) {
			if (op == Opcode.INVALID) continue;
			if (op.mnemonic.length > longestName) longestName = op.mnemonic.length;
			attributes[op.tag] |= OpcodeAttribute.VALID;
			if (op.sig != null && op.imms.length == 0) attributes[op.tag] |= OpcodeAttribute.SHORT_OP;
			if (op.prefix == 0) {
				opcode_by_prefix[op.code] = op;
				page_00.put(op);
			} else {
				page_by_prefix[op.prefix].put(op);
			}
		}
		attributes[Opcode.INVALID.tag] = OpcodeAttribute.INTERNAL;

		for (op in [Opcode.END, Opcode.I32_CONST, Opcode.I64_CONST, Opcode.F32_CONST, Opcode.F64_CONST, Opcode.GLOBAL_GET,
				Opcode.REF_NULL, Opcode.REF_FUNC, Opcode.STRUCT_NEW, Opcode.STRUCT_NEW_DEFAULT,
				Opcode.ARRAY_NEW, Opcode.ARRAY_NEW_DEFAULT, Opcode.ARRAY_NEW_FIXED, Opcode.ARRAY_NEW_DATA,
				Opcode.ARRAY_NEW_ELEM, Opcode.REF_I31, Opcode.V128_CONST]) {
			attributes[op.tag] |= OpcodeAttribute.CONSTANT;
		}
		for (op in [Opcode.I32_ADD, Opcode.I32_SUB, Opcode.I32_MUL, Opcode.I64_ADD, Opcode.I64_SUB, Opcode.I64_MUL]) {
			attributes[op.tag] |= OpcodeAttribute.EXTENDED_CONSTANT;
		}
	}

	// Render a single-byte opcode.
	def render(buf: StringBuilder, prefix: byte) -> StringBuilder {
		var op = opcode_by_prefix[prefix];
		if (op != Opcode.INVALID) return buf.puts(op.mnemonic);
		if (isPrefix(prefix)) return buf.put1("%x (prefix)", prefix);
		for (op in InternalOpcode) {
			if (op.code == prefix) return buf.put2("%x %s", prefix, op.mnemonic);
		}
		return buf.put1("%x (invalid)", prefix);
	}
	// Lookup an opcode, if it exists. Returns {Opcode.INVALID} if not.
	def find(prefix: byte, code: u32) -> Opcode {
		if (prefix == 0) return opcode_by_prefix[code];
		var page = page_by_prefix[prefix];
		return if(page != null, page[code], Opcode.INVALID);
	}
	// Look up an opcode by its mnemonic. Returns {Opcode.INVALID} if not found.
	def findByName(str: string) -> Opcode {
		if (nameMap == null) {
			nameMap = Strings.newMap<Opcode>();
			for (op in Opcode) {
				if (op != Opcode.SELECT_T) nameMap[op.mnemonic] = op;
			}
		}
		return nameMap[str];
	}
	// Parse and match opcode by its mnemonic. Returns {Opcode.INVALID} if not found.
	def parseName(str: Range<byte>) -> Opcode {
		var p = 0;
		for (i = 0; p < str.length; p++) {
			var ch = str[p];
			if (ch >= 'a' && ch <= 'z') continue;
			if (ch >= 'A' && ch <= 'Z') continue;
			if (ch >= '0' && ch <= '9') continue;
			if (ch == '_') continue;
			if (ch == '.') continue;
			break;
		}
		if (p > 0) {
			def op = findByName(Ranges.dup(str[0 ... p]));
			// ref.test and ref.cast have null versions with a space in the opcode name,
			// so we check those opcodes to see if it has null at the end
			match (op) {
				REF_TEST => {
					if (str.length >= p + 4 && Ranges.equal(str[p ... (p + 5)], " null")) {
						return Opcode.REF_TEST_NULL;
					}
				}
				REF_CAST => {
					if (str.length >= p + 4 && Ranges.equal(str[p ... (p + 5)], " null")) {
						return Opcode.REF_CAST_NULL;
					}
				}
				_ => ;
			}
			return op;
		}
		return Opcode.INVALID;
	}
	def isConstant(extensions: Extension.set, op: Opcode) -> bool {
		var empty: OpcodeAttribute.set;
		var mask: OpcodeAttribute.set = OpcodeAttribute.CONSTANT;
		if (extensions.EXTENDED_CONST) mask |= OpcodeAttribute.EXTENDED_CONSTANT;
		return (Opcodes.attributes[op.tag] & mask) != empty;
	}
	def isOneByte(b: byte) -> bool {
		return opcode_by_prefix[b] != Opcode.INVALID;
	}
	def isPrefix(b: byte) -> bool {
		return page_by_prefix[b] != null;
	}
	def isInternal(b: byte) -> bool {
		for (op in InternalOpcode) if (op.code == b) return true;
		return false;
	}
	def stackDelta(func_sig: SigDecl, opcode: Opcode, parser: WasmParser) -> (int, int) {
		var sig = opcode.sig;
		if (sig != null) return (sig.params.length, sig.results.length);
		def noFallThru = -1;
		def error = (-1, -1);
		match (opcode) {
			INVALID =>							return (0, noFallThru);
			UNREACHABLE, BR, DELEGATE =>					return (0, noFallThru);
			ELSE, CATCH, CATCH_ALL, RETHROW => 				return (0, noFallThru);
			THROW_REF, BR_TABLE => 						return (1, noFallThru);
			BR_ON_NULL, BR_ON_CAST, BR_ON_CAST_FAIL =>			return (1, 1);
			BR_IF, BR_ON_NON_NULL =>					return (1, 0);
			END =>								return (0, 0);
			DROP =>								return (1, 0);
			SELECT =>							return (3, 1);
			LOCAL_GET =>							return (0, 1);
			LOCAL_SET =>							return (1, 0);
			LOCAL_TEE =>							return (1, 1);
			GLOBAL_GET =>							return (0, 1);
			GLOBAL_SET =>							return (1, 0);
			TABLE_GET =>							return (1, 0);
			TABLE_SET =>							return (2, 0);
			MEMORY_SIZE =>							return (0, 1);
			MEMORY_GROW =>							return (1, 1);
			I32_CONST, I64_CONST, F32_CONST, F64_CONST, REF_NULL =>		return (0, 1);
			REF_IS_NULL =>							return (1, 1);
			REF_FUNC =>							return (0, 1);
			REF_AS_NON_NULL =>						return (1, 1);
			REF_EQ =>							return (2, 1);
			STRUCT_NEW_DEFAULT =>						return (0, 1);
			STRUCT_GET, STRUCT_GET_S, STRUCT_GET_U =>			return (1, 1);
			STRUCT_SET =>							return (2, 0);
			ARRAY_NEW_DEFAULT =>						return (1, 1);
			ARRAY_GET, ARRAY_GET_S, ARRAY_GET_U =>				return (2, 1);
			ARRAY_SET =>							return (3, 1);
			ARRAY_LEN =>							return (1, 1);
			ARRAY_FILL =>							return (3, 0);
			ARRAY_COPY =>							return (5, 0);
			ARRAY_INIT_DATA =>						return (4, 0);
			ARRAY_INIT_ELEM =>						return (4, 0);
			ARRAY_NEW_DATA =>						return (3, 1);
			ARRAY_NEW_ELEM =>						return (2, 1);
			REF_I31 =>							return (1, 1);
			I31_GET_S =>							return (1, 1);
			I31_GET_U =>							return (1, 1);
			REF_TEST, REF_TEST_NULL =>					return (1, 1);
			REF_CAST, REF_CAST_NULL =>					return (1, 1);
			ANY_CONVERT_EXTERN =>						return (1, 1);
			EXTERN_CONVERT_ANY =>						return (1, 1);
			MEMORY_INIT =>							return (3, 0);
			MEMORY_COPY =>							return (3, 0);
			MEMORY_FILL =>							return (3, 0);
			TABLE_INIT =>							return (3, 0);
			TABLE_COPY =>							return (3, 0);
			TABLE_GROW =>							return (2, 0);
			TABLE_SIZE =>							return (0, 1);
			TABLE_FILL =>							return (3, 0);
			CONT_NEW =>							return (1, 1);

			BLOCK, LOOP, TRY, TRY_TABLE => {
				var pr = parser.readBlockType();
				return (pr.0.length, pr.0.length); // consumes and leaves params on stack
			}
			IF => {
				var pr = parser.readBlockType();
				return (1 + pr.0.length, pr.0.length);
			}
			THROW => {
				var tag = parser.readTagRef();
				if (tag == null) return error;
				return (tag.fields.length, noFallThru);
			}
			RETURN => {
				return (func_sig.results.length, noFallThru);
			}
			CALL => {
				var func = parser.readFuncRef();
				if (func == null) return error;
				return (func.sig.params.length, func.sig.results.length);
			}
			CALL_INDIRECT => {
				var sig = parser.readSigRef();
				if (sig == null) return error;
				var unused_ = parser.readTableImm();
				return (1 + sig.params.length, sig.results.length);
			}
			RETURN_CALL => {
				var func = parser.readFuncRef();
				if (func == null) return error;
				return (func.sig.params.length, noFallThru);
			}
			RETURN_CALL_INDIRECT => {
				var sig = parser.readSigRef();
				if (sig == null) return error;
				var unused_ = parser.readTableImm();
				return (1 + sig.params.length, noFallThru);
			}
			CALL_REF => {
				var sig = parser.readSigRef();
				if (sig == null) return error;
				return (1 + sig.params.length, sig.results.length);
			}
			RETURN_CALL_REF => {
				var sig = parser.readSigRef();
				if (sig == null) return error;
				return (1 + sig.params.length, noFallThru);
			}
			SELECT_T => {
				var at = parser.readValueTypes("select count", parser.limits.max_num_select_results);
				// arity == 1 + 2 * at.length
				if (at.length == 0) return error;
				return (1 + 2 * at.length, at.length);
			}
			STRUCT_NEW => {
				var st = parser.readStructType();
				if (st == null) return error;
				return (st.field_types.length, 1);
			}
			ARRAY_NEW => {
				var at = parser.readArrayType();
				if (at == null) return error;
				return (1 + at.elem_types.length, 1);
			}
			ARRAY_NEW_FIXED => {
				var at = parser.readArrayType();
				if (at == null) return error;
				var size = parser.readU32_i("array size", parser.limits.max_array_length);
				return (1 + size, 1);
			}
			CONT_BIND => {
				var input_cont = parser.readCont();
				if (input_cont == null) return error;
				var output_cont = parser.readCont();
				if (output_cont == null) return error;
				return (1 + input_cont.sig.params.length - output_cont.sig.params.length, 1);
			}
			SUSPEND => {
				var tag = parser.readTagRef();
				if (tag == null) return error;
				var tag_sig = parser.module.heaptypes[tag.sig_index];
				if (!SigDecl.?(tag_sig)) return error;
				var sig = SigDecl.!(tag_sig);
				return (sig.params.length, sig.results.length);
			}
			RESUME => {
				var ct = parser.readCont();
				if (ct == null) return error;
				return (1 + ct.sig.params.length, ct.sig.results.length);
			}
			RESUME_THROW => {
				var ct = parser.readCont();
				if (ct == null) return error;
				var tag = parser.readTagRef();
				var tag_sig = parser.module.heaptypes[tag.sig_index];
				if (!SigDecl.?(tag_sig)) return error;
				var sig = SigDecl.!(tag_sig);
				return (sig.params.length, ct.sig.results.length);
			}
			_ => {
				return error;
			}
		}
	}
}

// Renders instructions as text.
class InstrTracer {
	def err = ErrorGen.new("");
	def codeptr = CodePtr.new([]);
	def all = Extension.set.all;
	def limits = Limits.new().set(Extension.set.all);
	var pc_width = 6;
	var instr_width = -1;
	var parser: WasmParser;

	def putInstr(out: StringBuilder, module: Module, d: DataReader) -> this {
		putInstrC(out, module, codeptr.reset(d.data, d.pos, d.limit));
	}
	def putInstrC(out: StringBuilder, module: Module, codeptr: CodePtr) -> this {
		if (parser == null || parser.module != module) {
			// TODO: instr tracer leaks last module
			parser = WasmParser.new(all, limits, module, err, codeptr);
		}

		var b = codeptr.read1();
		var op = Opcodes.opcode_by_prefix[b];
		if (op != Opcode.INVALID) {
			out.puts(op.mnemonic);
		} else if (Opcodes.isPrefix(b)) {
			var b2 = codeptr.read_uleb32();
			op = Opcodes.find(b, b2);
			if (op == Opcode.INVALID) out.put2("%x %x <invalid>", b, b2);
			else out.puts(op.mnemonic);
		} else if (b == InternalOpcode.PROBE.code || b == InternalOpcode.WHAMM_PROBE.code) {
			out.put1("<probe>", b);
			return;
		} else {
			out.put1("%x <invalid2>", b);
			return;
		}

		var imms = op.imms;
		if (imms.length > 0) out.putc('[');
		for (i < imms.length) {
			if (i > 0) out.putc(',');
			match (imms[i]) {
				BLOCK_TYPE => {
					var pr = parser.readBlockType();
					var pl = pr.0.length, rl = pr.1.length;
					if (pl == 0 && rl == 0) {
						// do nothing
					} else if (pl == 0 && rl == 1) {
						pr.1[0].render(out);
					} else {
						SigDecl.new(true, null, pr.0, pr.1).render(out);
					}
				}
				LABEL => out.put1("depth=%d", parser.readLabel());
				LABELS => {
					var labels = parser.readLabels();
					out.put1("%d...", labels.length);
				}
				EX_HANDLERS => {
					var handlers = parser.readHandlers();
					out.put1("%d...", handlers.length);
				}
				SUS_HANDLERS => {
					var handlers = parser.readSusHandlers();
					out.put1("%d...", handlers.length);
				}
				CATCHES => {
					var catches = parser.readCatches();
					out.put1("%d...", catches.length);
				}
				VALUE_TYPES => {
					var at = parser.readValueTypes("select count", u32.max);
					for (i < at.length) {
						if (i > 0) out.puts(" ");
						at[i].render(out);
					}
				}
				HEAP_TYPE => {
					var ht = parser.readHeapType();
					ht.render(out);
				}
				FUNC_INDEX => out.put1("func=%d", codeptr.read_uleb32());
				TABLE_INDEX => out.put1("table=%d", codeptr.read_uleb32());
				LOCAL_INDEX,
				GLOBAL_INDEX => out.put1("%d", codeptr.read_uleb32());
				MEMORY_INDEX => out.put1("mem=%d", codeptr.read_uleb32());
				ELEM_INDEX => out.put1("elem=%d", codeptr.read_uleb32());
				TAG_INDEX => out.put1("tag=%d", codeptr.read_uleb32());
				DATA_INDEX => out.put1("data=%d", codeptr.read_uleb32());
				LANE_INDEX => out.put1("lane=%d", codeptr.read1());
				U32 => out.put1("%d", codeptr.read_uleb32());
				I32 => out.put1("%d", codeptr.read_sleb32());
				I64 => out.put1("%d", codeptr.read_sleb64());
				F32 => out.put1("0x%x", parser.readF32());
				F64 => out.put1("0x%x", parser.readF64());
				V128 => {
					var low = parser.readF64();
					var high = parser.readF64();
					out.puts("0x").putx_64(high).putx_64(low);
				}
				MEMARG => {
					var memarg = parser.readMemoryArg();
					var align = 1 << byte.!(memarg.flags >> 1);
					if (memarg.memory_index > 0) out.put1("memory=%d,", memarg.memory_index);
					out.put2("align=%d,offset=%d", align, memarg.offset);
				}
				FIELD_INDEX => out.put1("field=%d", codeptr.read_uleb32());
				SIG_INDEX => out.put1("sig=%d", codeptr.read_uleb32());
				STRUCT_TYPE_INDEX,
				ARRAY_TYPE_INDEX => out.put1("type=%d", codeptr.read_uleb32()); // XXX: render heap type ref?
				ZERO_BYTE => codeptr.read1();
				BR_CAST => {
					var t = parser.readBrCastImms(), depth = t.0, t1 = t.1, t2 = t.2;
					out.put3("depth=%d %q to %q", depth, t1.render, t2.render);
				}
				CONT_INDEX => out.put1("cont=%d", codeptr.read_uleb32());
			}
		}
		if (op.imms.length > 0) out.putc(']');
	}
	def putPcAndInstr(out: TraceBuilder, module: Module, func: FuncDecl, pc: int, orig: bool) -> this {
		out.beginColor(Color.LINE);
		out.mark();
		out.put1("+%d ", pc);
		out.rjustify_mark(pc_width);
		out.beginColor(Color.INSTR);
		if (instr_width > 0) out.mark();
		var b = if(orig, func.orig_bytecode, func.cur_bytecode);
		putInstrC(out, module, codeptr.reset(b, pc, b.length));
		if (instr_width > 0) out.ljustify_mark(instr_width);
		out.endColor(Color.INSTR);
	}
	def putPcAndInstr2(out: TraceBuilder, module: Module, code: Range<byte>, pc: int) -> this {
		out.beginColor(Color.LINE);
		out.mark();
		out.put1("+%d ", pc);
		out.rjustify_mark(pc_width);
		out.beginColor(Color.INSTR);
		if (instr_width > 0) out.mark();
		putInstrC(out, module, codeptr.reset(code, 0, code.length));
		if (instr_width > 0) out.ljustify_mark(instr_width);
		out.endColor(Color.INSTR);
	}
}
