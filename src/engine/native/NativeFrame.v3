// Copyright 2025 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utilities associated with native frames.
component NativeFrames {
	// Convert a machine stack pointer into a reference to the frame.
	def fromSp(sp: Pointer) -> Ref<NativeInterpreterFrame> {
		return Ref<NativeInterpreterFrame>.of(CiRuntime.forgeRange<byte>(sp, NativeInterpreterFrame.size));
	}
}

// Memory representation of execution frames in the interpreter.
layout NativeInterpreterFrame {
	+0	wasm_func	: i64;	// WasmFunction
	+8	mem0_base	: i64;	// Pointer
	+16	vfp		: i64;	// Pointer
	+24	vsp		: i64;	// Pointer
	+32	sidetable	: i64;	// Array<int>
	+40	stp		: i64;	// Pointer
	+48	code		: i64;	// Array<byte>
	+56	ip		: i64;	// Pointer
	+64	eip		: i64;	// Pointer
	+72	func_decl	: i64;	// FuncDecl
	+80	instance	: i64;	// Instance
	+88	curpc		: int;
	+96	accessor	: i64;	// FrameAccessor
	=104;
}

// Implements access to interpreter and SPC frames.
class NativeFrameAccessor(stack: NativeExecStack, sp: Pointer, decl: FuncDecl) extends FrameAccessor {
	var writer: NativeFrameWriter; // non-null if any writes have been made
	var cached_depth = -1;
	var cached_pc: int;

	// Returns {true} if this frame has been unwound, either due to returning, a trap, or exception.
	def isUnwound() -> bool {
		if (FeatureDisable.frameAccess) return false; // TODO: proper is-frame-unwound check
		return this != (sp + NativeInterpreterFrame.accessor.offset).load<NativeFrameAccessor>();
	}
	// Returns the Wasm function in this frame.
	def func() -> WasmFunction {
		checkNotUnwound();
		return (sp + NativeInterpreterFrame.wasm_func.offset).load<WasmFunction>();
	}
	// Returns the current program counter.
	def pc() -> int {
		checkNotUnwound();
		var ip = readIp();
		var code = RiRuntime.findUserCode(ip);
		match (code) {
			x: NativeSpcModuleCode => cached_pc = x.lookupPc(ip, true);
			x: NativeInterpreterCode => cached_pc = NativeInterpreter.computePCFromFrame(sp);
			x: NativeSpcTrapsStub => cached_pc = (sp + NativeInterpreterFrame.curpc.offset).load<int>();
			_ => cached_pc = -1;
		}
		return cached_pc;
	}
	// Returns {true} if this frame is currently the top executing frame, {false} if the
	// frame has called another function or been unwound.
	def isTop() -> bool {
		return true; // TODO?
	}
	// Returns the call depth of this frame within its segment, with the bottom frame being #0.
	def depth() -> int {
		checkNotUnwound();
		if (cached_depth < 0) cached_depth = computeDepth();
		return cached_depth;
	}
	private def computeDepth() -> int {
		var depth = 0;
		var next_sp = sp;
		while (true) {
			next_sp = next_sp + NativeInterpreterFrame.size + RETADDR_SIZE;
			var retip = (next_sp + -RETADDR_SIZE).load<Pointer>();
			var code = RiRuntime.findUserCode(retip);
			match (code) {
				x: NativeInterpreterCode => ;
				x: NativeSpcCode => ;
				_ => return depth;
			}
			depth++;
		}
		return 0;
	}
	def caller() -> FrameLoc {
		checkNotUnwound();
		var frame = TargetFrame(callerSp());
		var accessor = frame.getFrameAccessor();
		if (accessor == null) return FrameLoc.None;
		return FrameLoc.Wasm(accessor.func(), accessor.pc(), frame);
	}
	def stp() -> int {
		checkNotUnwound();
		var ip = readIp();
		var code = RiRuntime.findUserCode(ip);
		match (code) {
			x: NativeInterpreterCode => {
				var stp = (sp + NativeInterpreterFrame.stp.offset).load<Pointer>();
				var stp0 = Pointer.atContents(func().decl.sidetable.entries);
				return int.!((stp - stp0) / 4);
			}
			_ => return -1;
		}
	}
	// Get the number of local variables in this frame.
	def numLocals() -> int {
		checkNotUnwound();
		return decl.num_locals;
	}
	// Get the value of local variable {i}.
	def getLocal(i: int) -> Value {
		checkNotUnwound();
		checkLocalBounds(i);
		var vfp = (sp + NativeInterpreterFrame.vfp.offset).load<Pointer>();
		return stack.readValue(vfp, i);
	}
	// Get the number of operand stack elements.
	def numOperands() -> int {
		checkNotUnwound();
		var vfp = (sp + NativeInterpreterFrame.vfp.offset).load<Pointer>();
		var vsp = (sp + NativeInterpreterFrame.vsp.offset).load<Pointer>();
		var diff = int.!((vsp - vfp) / Target.tagging.slot_size);
		return diff - decl.num_locals;
	}
	// Get operand at depth {i}, with 0 being the top of the stack, -1 being one lower, etc.
	def getOperand(i: int) -> Value {
		checkNotUnwound();
		var vsp = (sp + NativeInterpreterFrame.vsp.offset).load<Pointer>();
		return stack.readValue(vsp, i - 1);
	}
	// Get the frame writer.
	def getWriter() -> NativeFrameWriter {
		return if(writer != null, writer, writer = NativeFrameWriter.new(this));
	}

	// Read the return address from the frame.
	def readRetAddr() -> Pointer {
		return (sp + NativeInterpreterFrame.size).load<Pointer>();
	}
	// Read the instruction pointer from the frame.
	private def readIp() -> Pointer {
		return (sp + -RETADDR_SIZE).load<Pointer>();
	}
	// Compute the caller frame's stack pointer.
	def callerSp() -> Pointer {
		return sp + NativeInterpreterFrame.size + RETADDR_SIZE;
	}
	def isSpc() -> bool {
		var ip = readIp();
		var code = RiRuntime.findUserCode(ip);
		return NativeSpcCode.?(code);
	}

	private def checkNotUnwound() {
		if (isUnwound()) System.error("FrameAccessorError", "frame has been unwound");
	}
	private def checkLocalBounds(i: int) {
		if (u32.view(i) >= decl.num_locals) System.error("FrameAccessorError",
			Strings.format2("local index %d out-of-bounds (%d)", u32.view(i), decl.num_locals));
	}
	private def deoptToInterpreter() {
		var wf = func(), func = wf.decl;
		var pc = this.pc();
		var map = SidetableMap.new(func); // TODO: cache in FuncDecl?
		var stp = map[pc];
		deoptToInterpreter0(func, pc, stp);
	}
	private def deoptToInterpreter0(func: FuncDecl, pc: int, stp: int) {
		var ic = NativePreGenStubs.getInterpreterCode();
		setNewProgramLocation(func, pc, stp);
		(sp + -RETADDR_SIZE).store<Pointer>(ic.start + ic.header.deoptReentryOffset);
	}
	private def setNewProgramLocation(func: FuncDecl, pc: int, stp: int) {
		var code = func.cur_bytecode;
		(sp + NativeInterpreterFrame.func_decl.offset)	.store<FuncDecl>(func);
		(sp + NativeInterpreterFrame.curpc.offset)	.store<int>(pc);
		(sp + NativeInterpreterFrame.code.offset)	.store<Array<byte>>(code);
		(sp + NativeInterpreterFrame.ip.offset)		.store<Pointer>(Pointer.atElement(code, pc));
		(sp + NativeInterpreterFrame.eip.offset)	.store<Pointer>(Pointer.atContents(code) + code.length);
		var st_entries = func.sidetable.entries;
		var st_ptr = if(stp == st_entries.length, Pointer.atContents(st_entries), Pointer.atElement(func.sidetable.entries, stp));
		(sp + NativeInterpreterFrame.stp.offset)	.store<Pointer>(st_ptr);
	}
	private def vfp() -> Pointer {
		return (sp + NativeInterpreterFrame.vfp.offset).load<Pointer>();
	}
	private def set_vsp(p: Pointer) {
		(sp + NativeInterpreterFrame.vsp.offset).store<Pointer>(p);
	}
}
private class NativeFrameWriter extends FrameWriter {
	private def accessor: NativeFrameAccessor;

	new(accessor) { }

	// Set the value of a local variable. (dynamically typechecked).
	def setLocal(i: int, v: Value) {
		accessor.checkNotUnwound();
		accessor.checkLocalBounds(i);
		var vfp = (accessor.sp + NativeInterpreterFrame.vfp.offset).load<Pointer>();
		accessor.stack.writeValue(vfp, i, v);
		if (accessor.isSpc()) accessor.deoptToInterpreter();
	}
}
