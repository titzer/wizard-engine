// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Superclass of all import/exportable objects.
class Exportable {
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.puts("<exportable>");
	}
}
// Abstract base class of host and wasm functions.
class Function(sig: SigDecl) extends Object {
}

// An instantiated wasm function, i.e. one bound to an instance.
class WasmFunction(instance: Instance, decl: FuncDecl) extends Function {
	new() super(decl.sig) { }
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.put1("<wasm func %q>", renderShort);
	}
	def renderShort(buf: StringBuilder) -> StringBuilder {
		var names = if(instance != null, instance.module.names);
		return decl.render(names, buf);
	}
}
// An instantiated tag.
class Tag(sig: SigDecl, decl: TagDecl) extends Exportable {
}
// An instantiated global.
class Global(valtype: ValueType, decl: GlobalDecl) extends Exportable {
	def tag = ValueTypes.kind(valtype).code;
	// TODO: manually unboxed for performance, until Virgil unboxing catches up
	def var low: u64;		// TODO: non-private to compute its offset
	def var high: u64;		// TODO: non-private to compute its offset
	private var value: Value;	// TODO: ideal #unboxed in future, has no effect yet

	def get() -> Value {
		match (tag) {
			BpTypeCode.I32.code => return Value.I32(u32.view(low));
			BpTypeCode.I64.code => return Value.I64(low);
			BpTypeCode.F32.code => return Value.F32(u32.view(low));
			BpTypeCode.F64.code => return Value.F64(low);
			BpTypeCode.V128.code => return Value.V128(low, high);
			_ => return value;
		}
	}
	def set(v: Value) -> this {
		match (v) {
			I32(val) => low = val;
			I64(val) => low = val;
			F32(bits) => low = bits;
			F64(bits) => low = bits;
			V128(low, high) => { this.low = low; this.high = high; }
			_ => value = v;
		}
	}
}
// Superclass of all exported types.
class ExportedType extends Exportable {
}
// Wraps a source or host external type with its Wasm-level representation.
class ExportedValueType(src: ExportedType, vt: ValueType) extends ExportedType {
	def render(buf: StringBuilder) -> StringBuilder {
		if (src != null) buf.put2("<exported_type %q, %q>", src.render, vt.render);
		else buf.put1("<exported_type %q>", vt.render);
		return buf;
	}
}

// An instantiated module, including memories, tables, functions, etc.
class Instance(module: Module, imports: Array<Exportable>) {
	def memories = Array<Memory>.new(module.memories.length);
	def functions = Array<Function>.new(module.functions.length);
	def sig_ids = Array<int>.new(module.heaptypes.length);
	def tags = Array<Tag>.new(module.tags.length);
	def globals = Array<Global>.new(module.globals.length);
	def tables = Array<Table>.new(module.tables.length);
	def exports = Array<Exportable>.new(module.exports.length);
	def heaptypes = module.heaptypes.copy();
	def dropped_elems = Array<bool>.new(module.elems.length);
	def dropped_data = Array<bool>.new(module.data.length);

	def getFunctionAsVal(func_index: int) -> Value.Ref {
		return Value.Ref(functions[func_index]);
	}
	def evalInitExpr(init: InitExpr) -> Value {
		match (init) {
			I32(val) => return Value.I32(u32.view(val));
			I64(val) => return Value.I64(u64.view(val));
			F32(val) => return Value.F32(val);
			F64(val) => return Value.F64(val);
			V128(low, high) => return Value.V128(low, high);
			FuncRefNull,
			RefNull(ht),
			ExternRefNull => return Values.REF_NULL;
			Global(global_index, g) => {
				return globals[global_index].get();
			}
			FuncRef(func_index, f) => {
				return Value.Ref(functions[func_index]);
			}
			Const(val) => return val;
			I31(val) => {
				var v = evalInitExpr(val);
				return Value.I31(u31.view(Values.unbox_i(v)));
			}
			Array(t, len, elem) => {
				var vlen = Values.unbox_i(evalInitExpr(len));
				var decl = t.array;
				var st = decl.elem_types[0];
				var velem = evalInitExpr(elem);

				match (ObjTuning.arrayMode) {
					Typed => {
						match (st.pack) {
							UNPACKED => {
								match (st.valtype) {
									I32 => {
										var ielem = Value.I32.!(velem).val;
										var vvals = Array<u32>.new(vlen);
										for (i < vvals.length) vvals[i] = ielem;
										return Value.Ref(HeapArrayI32.new(t.array, vvals));
									}
									I64 => {
										var ielem = Value.I64.!(velem).val;
										var vvals = Array<u64>.new(vlen);
										for (i < vvals.length) vvals[i] = ielem;
										return Value.Ref(HeapArrayI64.new(t.array, vvals));
									}
									F32 => {
										var felem = Value.F32.!(velem).bits;
										var vvals = Array<u32>.new(vlen);
										for (i < vvals.length) vvals[i] = felem;
										return Value.Ref(HeapArrayF32.new(t.array, vvals));
									}
									F64 => {
										var felem = Value.F64.!(velem).bits;
										var vvals = Array<u64>.new(vlen);
										for (i < vvals.length) vvals[i] = felem;
										return Value.Ref(HeapArrayF64.new(t.array, vvals));
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var oelem = Value.I31.!(velem).val;
											var vvals = Array<u31>.new(vlen);
											for (i < vvals.length) vvals[i] = oelem;
											return Value.Ref(HeapArrayI31.new(t.array, vvals));
										} else {
											var oelem = Value.Ref.!(velem).val;
											var vvals = Array<Object>.new(vlen);
											for (i < vvals.length) vvals[i] = oelem;
											return Value.Ref(HeapArrayRef.new(t.array, vvals));
										}
									}
									V128 => {
										var v128 = Value.V128.!(velem);
										var vvals = Array<u64>.new(vlen << 1);
										var low = v128.low;
										var high = v128.high;
										for (i = 0; i < vvals.length; i += 2) {
											vvals[i] = low;
											vvals[i+1] = high;
										}
										return Value.Ref(HeapArrayV128.new(t.array, vvals));
									}
									_ => {
										var vvals = Array<Value>.new(vlen);
										for (i < vvals.length) vvals[i] = velem;
										return Value.Ref(HeapArrayValue.new(t.array, vvals));
									}
								}
							}
							PACKED_I8 => {
								var ielem = u8.view(Value.I32.!(velem).val);
								var vvals = Array<u8>.new(vlen);
								for (i < vvals.length) vvals[i] = ielem;
								return Value.Ref(HeapArrayI8.new(t.array, vvals));
							}
							PACKED_I16 => {
								var ielem = u16.view(Value.I32.!(velem).val);
								var vvals = Array<u16>.new(vlen);
								for (i < vvals.length) vvals[i] = ielem;
								return Value.Ref(HeapArrayI16.new(t.array, vvals));
							}
						}
					}
					Pair => {
						match (st.pack) {
							UNPACKED => {
								match (st.valtype) {
									I32 => {
										var bytes = Array<byte>.new(vlen << 2);
										var ielem = Value.I32.!(velem).val;
										var offset = 0;
										for (i < vlen) {
											Ref<Layout_u32>.at(bytes, offset).val = ielem;
											offset += 4;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 2));
									}
									I64 => {
										var bytes = Array<byte>.new(vlen << 3);
										var ielem = Value.I64.!(velem).val;
										var offset = 0;
										for (i < vlen) {
											Ref<Layout_u64>.at(bytes, offset).val = ielem;
											offset += 8;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 3));
									}
									F32 => {
										var bytes = Array<byte>.new(vlen << 2);
										var felem = Value.F32.!(velem).bits;
										var offset = 0;
										for (i < vlen) {
											Ref<Layout_u32>.at(bytes, offset).val = felem;
											offset += 4;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 2));
									}
									F64 => {
										var bytes = Array<byte>.new(vlen << 3);
										var felem = Value.F64.!(velem).bits;
										var offset = 0;
										for (i < vlen) {
											Ref<Layout_u64>.at(bytes, offset).val = felem;
											offset += 8;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 3));
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var bytes = Array<byte>.new(vlen << 2);
											var oelem = Value.I31.!(velem).val;
											var offset = 0;
											for (i < vlen) {
												Ref<Layout_u31>.at(bytes, offset).val = oelem;
												offset += 4;
											}
											return Value.Ref(HeapArrayPair.new(decl, null, bytes, 2));
										} else {
											var vals = Array<Object>.new(vlen);
											var oelem = Value.Ref.!(velem).val;
											for (i < vlen) vals[i] = oelem;
											return Value.Ref(HeapArrayPair.new(decl, vals, null, Values.OBJS_SHIFT));
										}
									}
									V128 => {
										var bytes = Array<byte>.new(vlen << 4);
										var v128 = Value.V128.!(velem);
										var low = v128.low;
										var high = v128.high;
										var offset = 0;
										for (i < vlen) {
											var r = Ref<Layout_u128>.at(bytes, offset);
											r.lo_val = low;
											r.hi_val = high;
											offset += 16;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 4));
									}
									_ => {
										var vvals = Array<Value>.new(vlen);
										for (i < vvals.length) vvals[i] = velem;
										return Value.Ref(HeapArrayValue.new(t.array, vvals));
									}
								}
							}
							PACKED_I8 => {
								var bytes = Array<byte>.new(vlen);
								var ielem = u8.view(Value.I32.!(velem).val);
								for (i < vlen) {
									bytes[i] = u8.view(ielem);
								}
								return Value.Ref(HeapArrayPair.new(decl, null, bytes, 0));
							}
							PACKED_I16 => {
								var bytes = Array<byte>.new(vlen << 1);
								var ielem = u16.view(Value.I32.!(velem).val);
								var offset = 0;
								for (i < vlen) {
									Ref<Layout_u16>.at(bytes, offset).val = u16.view(ielem);
									offset += 2;
								}
								return Value.Ref(HeapArrayPair.new(decl, null, bytes, 1));
							}
						}
					}
					_ => {
						var vvals = Array<Value>.new(vlen);
						for (i < vvals.length) vvals[i] = velem;
						return Value.Ref(HeapArrayValue.new(t.array, vvals));
					}
				}
			}
			FixedArray(t, vals) => {
				var decl = t.array;
				var st = decl.elem_types[0];
				match (ObjTuning.arrayMode) {
					Typed => {
						match (st.pack) {
							UNPACKED => {
								match (st.valtype) {
									I32 => {
										var vlen = vals.length;
										var vvals = Array<u32>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.I32.!(velem).val;
										}
										return Value.Ref(HeapArrayI32.new(t.array, vvals));
									}
									I64 => {
										var vlen = vals.length;
										var vvals = Array<u64>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.I64.!(velem).val;
										}
										return Value.Ref(HeapArrayI64.new(t.array, vvals));
									}
									F32 => {
										var vlen = vals.length;
										var vvals = Array<u32>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.F32.!(velem).bits;
										}
										return Value.Ref(HeapArrayF32.new(t.array, vvals));
									}
									F64 => {
										var vlen = vals.length;
										var vvals = Array<u64>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.F64.!(velem).bits;
										}
										return Value.Ref(HeapArrayF64.new(t.array, vvals));
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var vlen = vals.length;
											var vvals = Array<u31>.new(vlen);
											for (i < vlen) {
												var velem = evalInitExpr(vals[i]);
												vvals[i] = Value.I31.!(velem).val;
											}
											return Value.Ref(HeapArrayI31.new(t.array, vvals));
										} else {
											var vlen = vals.length;
											var vvals = Array<Object>.new(vlen);
											for (i < vlen) {
												var velem = evalInitExpr(vals[i]);
												vvals[i] = Value.Ref.!(velem).val;
											}
											return Value.Ref(HeapArrayRef.new(t.array, vvals));
										}
									}
									V128 => {
										var vlen = vals.length;
										var vvals = Array<u64>.new(vlen << 1);
										for (i = 0; i < vlen; i += 2) {
											var velem = evalInitExpr(vals[i]);
											var v128 = Value.V128.!(velem);
											vvals[i] = v128.low;
											vvals[i+1] = v128.high;
										}
										return Value.Ref(HeapArrayV128.new(t.array, vvals));
									}
									_ => {
										var vvals = Arrays.map(vals, evalInitExpr);
										return Value.Ref(HeapArrayValue.new(t.array, vvals));
									}
								}
							}
							PACKED_I8 => {
								var vlen = vals.length;
								var vvals = Array<u8>.new(vlen);
								for (i < vlen) {
										var velem = evalInitExpr(vals[i]);
										vvals[i] = u8.view(Value.I32.!(velem).val);
								}
								return Value.Ref(HeapArrayI8.new(t.array, vvals));
							}
							PACKED_I16 => {
								var vlen = vals.length;
								var vvals = Array<u16>.new(vlen);
								for (i < vlen) {
										var velem = evalInitExpr(vals[i]);
										vvals[i] = u16.view(Value.I32.!(velem).val);
								}
								return Value.Ref(HeapArrayI16.new(t.array, vvals));
							}
						}
					}
					Pair => {
						var decl = t.array;
						var st = decl.elem_types[0];
						match (st.pack) {
							UNPACKED => {
								match (st.valtype) {
									I32 => {
										var vlen = vals.length;
										var bytes = Array<byte>.new(vlen << 2);
										var offset = 0;
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											Ref<Layout_u32>.at(bytes, offset).val = Value.I32.!(velem).val;
											offset += 4;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 2));
									}
									I64 => {
										var vlen = vals.length;
										var bytes = Array<byte>.new(vlen << 3);
										var offset = 0;
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											Ref<Layout_u64>.at(bytes, offset).val = Value.I64.!(velem).val;
											offset += 8;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 3));
									}
									F32 => {
										var vlen = vals.length;
										var bytes = Array<byte>.new(vlen << 2);
										var offset = 0;
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											Ref<Layout_u32>.at(bytes, offset).val = Value.F32.!(velem).bits;
											offset += 4;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 2));
									}
									F64 => {
										var vlen = vals.length;
										var bytes = Array<byte>.new(vlen << 3);
										var offset = 0;
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											Ref<Layout_u64>.at(bytes, offset).val = Value.F64.!(velem).bits;
											offset += 8;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 3));
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var vlen = vals.length;
											var bytes = Array<byte>.new(vlen << 2);
											var offset = 0;
											for (i < vlen) {
												var velem = evalInitExpr(vals[i]);
												Ref<Layout_u31>.at(bytes, offset).val = Value.I31.!(velem).val;
												offset += 4;
											}
											return Value.Ref(HeapArrayPair.new(decl, null, bytes, 2));
										} else {
											var vlen = vals.length;
											var objs = Array<Object>.new(vlen);
											for (i < vlen) {
												var velem = evalInitExpr(vals[i]);
												objs[i] = Value.Ref.!(velem).val;
											}
											return Value.Ref(HeapArrayPair.new(decl, objs, null, Values.OBJS_SHIFT));
										}
									}
									V128 => {
										var vlen = vals.length;
										var bytes = Array<byte>.new(vlen << 4);
										var offset = 0;
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											var r = Ref<Layout_u128>.at(bytes, offset);
											var pair = Value.V128.!(velem);
											r.lo_val = pair.low;
											r.hi_val = pair.high;
											offset += 16;
										}
										return Value.Ref(HeapArrayPair.new(decl, null, bytes, 4));
									}
									_ => {
										var vvals = Arrays.map(vals, evalInitExpr);
										return Value.Ref(HeapArrayValue.new(t.array, vvals));
									}
								}
							}
							PACKED_I8 => {
								var vlen = vals.length;
								var bytes = Array<byte>.new(vlen);
								for (i < vlen) {
									var velem = evalInitExpr(vals[i]);
									bytes[i] = u8.view(Value.I32.!(velem).val);
								}
								return Value.Ref(HeapArrayPair.new(decl, null, bytes, 0));
							}
							PACKED_I16 => {
								var vlen = vals.length;
								var bytes = Array<byte>.new(vlen << 1);
								var offset = 0;
								for (i < vlen) {
									var velem = evalInitExpr(vals[i]);
									Ref<Layout_u16>.at(bytes, offset).val = u16.view(Value.I32.!(velem).val);
									offset += 2;
								}
								return Value.Ref(HeapArrayPair.new(decl, null, bytes, 1));
							}
						}
					}
					_ => {
						var vvals = Arrays.map(vals, evalInitExpr);
						return Value.Ref(HeapArrayValue.new(t.array, vvals));
					}
				}
			}
			Struct(t, vals) => {
				var vvals = Arrays.map(vals, evalInitExpr);
				match (ObjTuning.structMode) {
					Original => {
						return Value.Ref(HeapStruct.new(t.sdecl, vvals));
					}
					Pair => {
						var decl = t.sdecl;
						var bytes = if(decl.num_bytes == 0, null, Array<byte>.new(decl.num_bytes));
						var objs = if(decl.num_refs == 0, null, Array<Object>.new(decl.num_refs));
						var obj = HeapStructPair.new(decl, objs, bytes);

						for (i < decl.field_types.length) {
							obj.setFieldValue(u31.view(i), vvals[i]);
						}
						return Value.Ref(obj);
					}
				}
			}
			ArrayNewData(t, data_index, offset, len) => {
				var voffset = evalInitExpr(offset);
				var vlen = evalInitExpr(len);
				return Values.I32_0; // TODO
			}
			ArrayNewElem(t, elem_index, offset, len) => {
				var voffset = evalInitExpr(offset);
				var vlen = evalInitExpr(len);
				return Values.I32_0; // TODO
			}
			I32_ADD(a, b) => return Value.I32(Values.unbox_u(evalInitExpr(a)) + Values.unbox_u(evalInitExpr(b)));
			I32_SUB(a, b) => return Value.I32(Values.unbox_u(evalInitExpr(a)) - Values.unbox_u(evalInitExpr(b)));
			I32_MUL(a, b) => return Value.I32(Values.unbox_u(evalInitExpr(a)) * Values.unbox_u(evalInitExpr(b)));
			I64_ADD(a, b) => return Value.I64(Values.unbox_w(evalInitExpr(a)) + Values.unbox_w(evalInitExpr(b)));
			I64_SUB(a, b) => return Value.I64(Values.unbox_w(evalInitExpr(a)) - Values.unbox_w(evalInitExpr(b)));
			I64_MUL(a, b) => return Value.I64(Values.unbox_w(evalInitExpr(a)) * Values.unbox_w(evalInitExpr(b)));
		}
	}
	def findExportOfType<T>(matcher: GlobMatcher) -> T {
		var decls = module.exports;
		for (i < decls.length) {
			if (matcher != null && !matcher.matches(decls[i].0)) continue;
			var iex = exports[i];
			if (T.?(iex)) return T.!(iex);
		}
		var d: T;
		return d;
	}
}
