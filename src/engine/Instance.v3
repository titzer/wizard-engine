// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Superclass of all import/exportable objects.
class Exportable {
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.puts("<exportable>");
	}
}
// Abstract base class of host and wasm functions.
class Function(sig: SigDecl) extends Object {
}

// An instantiated wasm function, i.e. one bound to an instance.
class WasmFunction(instance: Instance, decl: FuncDecl) extends Function {
	new() super(decl.sig) { }
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.put1("<wasm func %q>", renderShort);
	}
	def renderShort(buf: StringBuilder) -> StringBuilder {
		var names = if(instance != null, instance.module.names);
		return decl.render(names, buf);
	}
}
// An instantiated tag.
class Tag(sig: SigDecl, decl: TagDecl) extends Exportable {
}
// An instantiated global.
class Global(valtype: ValueType, decl: GlobalDecl) extends Exportable {
	def tag = ValueTypes.kind(valtype).code;
	// TODO: manually unboxed for performance, until Virgil unboxing catches up
	def var low: u64;		// TODO: non-private to compute its offset
	def var high: u64;		// TODO: non-private to compute its offset
	private var value: Value;	// TODO: ideal #unboxed in future, has no effect yet

	def get() -> Value {
		match (tag) {
			BpTypeCode.I32.code => return Value.I32(u32.view(low));
			BpTypeCode.I64.code => return Value.I64(low);
			BpTypeCode.F32.code => return Value.F32(u32.view(low));
			BpTypeCode.F64.code => return Value.F64(low);
			BpTypeCode.V128.code => return Value.V128(low, high);
			_ => return value;
		}
	}
	def set(v: Value) -> this {
		match (v) {
			I32(val) => low = val;
			I64(val) => low = val;
			F32(bits) => low = bits;
			F64(bits) => low = bits;
			V128(low, high) => { this.low = low; this.high = high; }
			_ => value = v;
		}
	}
}
// Superclass of all exported types.
class ExportedType extends Exportable {
}
// Wraps a source or host external type with its Wasm-level representation.
class ExportedValueType(src: ExportedType, vt: ValueType) extends ExportedType {
	def render(buf: StringBuilder) -> StringBuilder {
		if (src != null) buf.put2("<exported_type %q, %q>", src.render, vt.render);
		else buf.put1("<exported_type %q>", vt.render);
		return buf;
	}
}

// An instantiated module, including memories, tables, functions, etc.
class Instance(module: Module, imports: Array<Exportable>) {
	def memories = Array<Memory>.new(module.memories.length);
	def functions = Array<Function>.new(module.functions.length);
	def sig_ids = Array<int>.new(module.heaptypes.length);
	def tags = Array<Tag>.new(module.tags.length);
	def globals = Array<Global>.new(module.globals.length);
	def tables = Array<Table>.new(module.tables.length);
	def exports = Array<Exportable>.new(module.exports.length);
	def heaptypes = module.heaptypes.copy();
	def dropped_elems = Array<bool>.new(module.elems.length);
	def dropped_data = Array<bool>.new(module.data.length);

	def getFunctionAsVal(func_index: int) -> Value.Ref {
		return Value.Ref(functions[func_index]);
	}
	def evalInitExpr(init: InitExpr) -> Value {
		match (init) {
			I32(val) => return Value.I32(u32.view(val));
			I64(val) => return Value.I64(u64.view(val));
			F32(val) => return Value.F32(val);
			F64(val) => return Value.F64(val);
			V128(low, high) => return Value.V128(low, high);
			FuncRefNull,
			RefNull(ht),
			ExternRefNull => return Values.REF_NULL;
			Global(global_index, g) => {
				return globals[global_index].get();
			}
			FuncRef(func_index, f) => {
				return Value.Ref(functions[func_index]);
			}
			Const(val) => return val;
			I31(val) => {
				var v = evalInitExpr(val);
				return Value.I31(u31.view(Values.unbox_i(v)));
			}
			Array(t, len, elem),
			FixedArray(t, vals),
			Struct(t, vals) => {
				return Value.Ref(evalInitExprObject(init));
			}
			ArrayNewData(t, data_index, offset, len) => {
				var voffset = evalInitExpr(offset);
				var vlen = evalInitExpr(len);
				return Values.I32_0; // TODO
			}
			ArrayNewElem(t, elem_index, offset, len) => {
				var voffset = evalInitExpr(offset);
				var vlen = evalInitExpr(len);
				return Values.I32_0; // TODO
			}
			I32_ADD(a, b) => return Value.I32(Values.unbox_u(evalInitExpr(a)) + Values.unbox_u(evalInitExpr(b)));
			I32_SUB(a, b) => return Value.I32(Values.unbox_u(evalInitExpr(a)) - Values.unbox_u(evalInitExpr(b)));
			I32_MUL(a, b) => return Value.I32(Values.unbox_u(evalInitExpr(a)) * Values.unbox_u(evalInitExpr(b)));
			I64_ADD(a, b) => return Value.I64(Values.unbox_w(evalInitExpr(a)) + Values.unbox_w(evalInitExpr(b)));
			I64_SUB(a, b) => return Value.I64(Values.unbox_w(evalInitExpr(a)) - Values.unbox_w(evalInitExpr(b)));
			I64_MUL(a, b) => return Value.I64(Values.unbox_w(evalInitExpr(a)) * Values.unbox_w(evalInitExpr(b)));
		}
	}
	def evalInitExprObject(init: InitExpr) -> Object {
		match (init) {
			FuncRefNull,
			RefNull(ht),
			ExternRefNull => return null;
			Global(global_index, g) => {
				return Values.unbox<Object>(globals[global_index].get());
			}
			FuncRef(func_index, f) => {
				return functions[func_index];
			}
			Const(val) => return Values.unbox<Object>(val); 
			I31(val) => {
				var v = evalInitExpr(val);
				return ObjectI31.new(u31.view(Values.unbox_i(v)));
			}
			Array(t, len, elem) => {
				var vlen = Values.unbox_i(evalInitExpr(len));
				var decl = t.array;
				var st = decl.elem_types[0];
				var velem = evalInitExpr(elem);

				match (ObjTuning.arrayMode) {
					Typed => {
						match (st.pack) {
							UNPACKED => {
								match (st.valtype) {
									I32 => {
										var ielem = Value.I32.!(velem).val;
										var vvals = Array<u32>.new(vlen);
										for (i < vvals.length) vvals[i] = ielem;
										return HeapArrayI32.new(t.array, vvals);
									}
									I64 => {
										var ielem = Value.I64.!(velem).val;
										var vvals = Array<u64>.new(vlen);
										for (i < vvals.length) vvals[i] = ielem;
										return HeapArrayI64.new(t.array, vvals);
									}
									F32 => {
										var felem = Value.F32.!(velem).bits;
										var vvals = Array<u32>.new(vlen);
										for (i < vvals.length) vvals[i] = felem;
										return HeapArrayF32.new(t.array, vvals);
									}
									F64 => {
										var felem = Value.F64.!(velem).bits;
										var vvals = Array<u64>.new(vlen);
										for (i < vvals.length) vvals[i] = felem;
										return HeapArrayF64.new(t.array, vvals);
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var oelem = Value.I31.!(velem).val;
											var vvals = Array<u31>.new(vlen);
											for (i < vvals.length) vvals[i] = oelem;
											return HeapArrayI31.new(t.array, vvals);
										} else {
											var oelem = Value.Ref.!(velem).val;
											var vvals = Array<Object>.new(vlen);
											for (i < vvals.length) vvals[i] = oelem;
											return HeapArrayRef.new(t.array, vvals);
										}
									}
									V128 => {
										var v128 = Value.V128.!(velem);
										var vvals = Array<u64>.new(vlen << 1);
										var low = v128.low;
										var high = v128.high;
										for (i = 0; i < vvals.length; i += 2) {
											vvals[i] = low;
											vvals[i+1] = high;
										}
										return HeapArrayV128.new(t.array, vvals);
									}
									_ => {
										var vvals = Array<Value>.new(vlen);
										for (i < vvals.length) vvals[i] = velem;
										return HeapArrayValue.new(t.array, vvals);
									}
								}
							}
							PACKED_I8 => {
								var ielem = u8.view(Value.I32.!(velem).val);
								var vvals = Array<u8>.new(vlen);
								for (i < vvals.length) vvals[i] = ielem;
								return HeapArrayI8.new(t.array, vvals);
							}
							PACKED_I16 => {
								var ielem = u16.view(Value.I32.!(velem).val);
								var vvals = Array<u16>.new(vlen);
								for (i < vvals.length) vvals[i] = ielem;
								return HeapArrayI16.new(t.array, vvals);
							}
						}
					}
					_ => {
						var vvals = Array<Value>.new(vlen);
						for (i < vvals.length) vvals[i] = velem;
						return HeapArrayValue.new(t.array, vvals);
					}
				}
			}
			FixedArray(t, vals) => {
				var decl = t.array;
				var st = decl.elem_types[0];
				match (ObjTuning.arrayMode) {
					Typed => {
						match (st.pack) {
							UNPACKED => {
								match (st.valtype) {
									I32 => {
										var vlen = vals.length;
										var vvals = Array<u32>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.I32.!(velem).val;
										}
										return HeapArrayI32.new(t.array, vvals);
									}
									I64 => {
										var vlen = vals.length;
										var vvals = Array<u64>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.I64.!(velem).val;
										}
										return HeapArrayI64.new(t.array, vvals);
									}
									F32 => {
										var vlen = vals.length;
										var vvals = Array<u32>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.F32.!(velem).bits;
										}
										return HeapArrayF32.new(t.array, vvals);
									}
									F64 => {
										var vlen = vals.length;
										var vvals = Array<u64>.new(vlen);
										for (i < vlen) {
											var velem = evalInitExpr(vals[i]);
											vvals[i] = Value.F64.!(velem).bits;
										}
										return HeapArrayF64.new(t.array, vvals);
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var vlen = vals.length;
											var vvals = Array<u31>.new(vlen);
											for (i < vlen) {
												var velem = evalInitExpr(vals[i]);
												vvals[i] = Value.I31.!(velem).val;
											}
											return HeapArrayI31.new(t.array, vvals);
										} else {
											var vlen = vals.length;
											var vvals = Array<Object>.new(vlen);
											for (i < vlen) {
												var velem = evalInitExpr(vals[i]);
												vvals[i] = Value.Ref.!(velem).val;
											}
											return HeapArrayRef.new(t.array, vvals);
										}
									}
									V128 => {
										var vlen = vals.length;
										var vvals = Array<u64>.new(vlen << 1);
										for (i = 0; i < vlen; i += 2) {
											var velem = evalInitExpr(vals[i]);
											var v128 = Value.V128.!(velem);
											vvals[i] = v128.low;
											vvals[i+1] = v128.high;
										}
										return HeapArrayV128.new(t.array, vvals);
									}
									_ => {
										var vvals = Arrays.map(vals, evalInitExpr);
										return HeapArrayValue.new(t.array, vvals);
									}
								}
							}
							PACKED_I8 => {
								var vlen = vals.length;
								var vvals = Array<u8>.new(vlen);
								for (i < vlen) {
										var velem = evalInitExpr(vals[i]);
										vvals[i] = u8.view(Value.I32.!(velem).val);
								}
								return HeapArrayI8.new(t.array, vvals);
							}
							PACKED_I16 => {
								var vlen = vals.length;
								var vvals = Array<u16>.new(vlen);
								for (i < vlen) {
										var velem = evalInitExpr(vals[i]);
										vvals[i] = u16.view(Value.I32.!(velem).val);
								}
								return HeapArrayI16.new(t.array, vvals);
							}
						}
					}
					_ => {
						var vvals = Arrays.map(vals, evalInitExpr);
						return HeapArrayValue.new(t.array, vvals);
					}
				}
			}
			Struct(t, vals) => {
				var vvals = Arrays.map(vals, evalInitExpr);
				match (ObjTuning.structMode) {
					Original => {
						return HeapStructValue.new(t.sdecl, vvals);
					}
					Pair => {
						var decl = t.sdecl;
						var bytes = if(decl.num_bytes == 0, null, Array<byte>.new(decl.num_bytes));
						var objs = if(decl.num_refs == 0, null, Array<Object>.new(decl.num_refs));
						var obj = HeapStructPair.new(decl, objs, bytes);

						for (i < decl.field_types.length) {
							obj.setFieldValue(u31.view(i), vvals[i]);
						}
						return obj;
					}
				}
			}
			ArrayNewData(t, data_index, offset, len) => {
				var voffset = evalInitExpr(offset);
				var vlen = evalInitExpr(len);
				return null;
			}
			ArrayNewElem(t, elem_index, offset, len) => {
				var voffset = evalInitExpr(offset);
				var vlen = evalInitExpr(len);
				return null;
			}
			_ => return null;
		}
	}
	def evalInitExprScalar<T>(init: InitExpr) -> T {
		match (init) {
			I32(val) => return T.!(u32.view(val));
			I64(val) => return T.!(u64.view(val));
			F32(val) => return T.!(val);
			F64(val) => return T.!(val);
			V128(low, high) => return T.!((low, high));
			Global(global_index, g) => {
				return Values.unbox<T>(globals[global_index].get());
			}
			Const(val) => return Values.unbox<T>(val);
			I31(val) => {
				var v = evalInitExpr(val);
				return T.!(u31.view(Values.unbox_i(v)));
			}
			I32_ADD(a, b) => return T.!(Values.unbox_u(evalInitExpr(a)) + Values.unbox_u(evalInitExpr(b)));
			I32_SUB(a, b) => return T.!(Values.unbox_u(evalInitExpr(a)) - Values.unbox_u(evalInitExpr(b)));
			I32_MUL(a, b) => return T.!(Values.unbox_u(evalInitExpr(a)) * Values.unbox_u(evalInitExpr(b)));
			I64_ADD(a, b) => return T.!(Values.unbox_w(evalInitExpr(a)) + Values.unbox_w(evalInitExpr(b)));
			I64_SUB(a, b) => return T.!(Values.unbox_w(evalInitExpr(a)) - Values.unbox_w(evalInitExpr(b)));
			I64_MUL(a, b) => return T.!(Values.unbox_w(evalInitExpr(a)) * Values.unbox_w(evalInitExpr(b)));
			_ => return T.!(0);
		}
	}
	def findExportOfType<T>(matcher: GlobMatcher) -> T {
		var decls = module.exports;
		for (i < decls.length) {
			if (matcher != null && !matcher.matches(decls[i].0)) continue;
			var iex = exports[i];
			if (T.?(iex)) return T.!(iex);
		}
		var d: T;
		return d;
	}
}
