// Copyright 2023 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Shared runtime routines that are called by different execution tiers, both the
// pure-Virgil (V3) implementation, and any native implementations.
component Runtime {
	def GLOBAL_GET(stack: ExecStack, instance: Instance, global_index: u31) {
		var val = instance.globals[global_index].get();
		stack.push(val);
	}
	def GLOBAL_SET(stack: ExecStack, instance: Instance, global_index: u31) {
		var g = instance.globals[global_index];
		var val = stack.popV(g.valtype);
		g.set(val);
	}
	def TABLE_GET(stack: ExecStack, instance: Instance, table_index: u31) -> Throwable {
		var table = instance.tables[table_index], elems = table.elems;
		var elem = stack.popa(table.decl.size);
		if (elem >= elems.length) return stack.trap(TrapReason.TABLE_OOB);
		stack.push(elems[elem]);
		return null;
	}
	def TABLE_SET(stack: ExecStack, instance: Instance, table_index: u31) -> Throwable {
		var table = instance.tables[table_index], elems = table.elems;
		var val = stack.popV(table.elemtype);
		var elem = stack.popa(table.decl.size);
		if (elem >= elems.length) return stack.trap(TrapReason.TABLE_OOB);
		table[int.!(elem)] = val;
		return null;
	}
	def MEMORY_GROW(stack: ExecStack, instance: Instance, mem_index: u31) {
		var memory = instance.memories[mem_index];
		var pages = stack.popa(memory.decl.size);
		var result : long = memory.grow(pages);
		stack.pusha(memory.decl.size, u64.view(result));
	}
	// --- GC operations -----------------------------------------------------------------------------------------
	def STRUCT_NEW(stack: ExecStack, instance: Instance, struct_index: u31) {
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		var obj: HeapStructGeneric;
		if (ObjReps.structMode == StructMode.Original) {
			var fields = Array<Value>.new(decl.field_types.length);
			for (i = fields.length - 1; i >= 0; i--) {
				fields[i] = stack.popV(decl.field_types[i].valtype);
			}
			obj = HeapStructValue.new(decl, fields);
		} else {
			obj = ObjectRuntime.STRUCT_NEW(stack, decl);
		}
		stack.push(Value.Ref(obj));
	}
	def STRUCT_NEW_DEFAULT(stack: ExecStack, instance: Instance, struct_index: u31) {
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		var obj: HeapStructGeneric;
		if (ObjReps.structMode == StructMode.Original) {
			var fields = Array<Value>.new(decl.field_types.length);
			for (i < fields.length) {
				fields[i] = Values.default(decl.field_types[i].valtype);
			}
			obj = HeapStructValue.new(decl, fields);
		} else {
			obj = ObjectRuntime.STRUCT_NEW_DEFAULT(decl);
		}
		stack.push(Value.Ref(obj));
	}
	def STRUCT_GET(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var obj = stack.popStruct();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		stack.push(obj.getFieldValue(field_index));
		return null;
	}
	def STRUCT_GET_S(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var obj = stack.popStruct();
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var val: Value;
		match (decl.field_types[field_index].pack) {
			PACKED_I8 => val = obj.getFieldSignExtend8Value(field_index);
			PACKED_I16 => val = obj.getFieldSignExtend16Value(field_index);
			UNPACKED => return stack.trap(TrapReason.ERROR);
		}
		stack.push(val); // XXX: pushi
		return null;
	}
	def STRUCT_GET_U(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var obj = stack.popStruct();
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var val: Value;
		match (decl.field_types[field_index].pack) {
			PACKED_I8 => val = obj.getFieldZeroExtend8Value(field_index);
			PACKED_I16 => val = obj.getFieldZeroExtend16Value(field_index);
			UNPACKED => return stack.trap(TrapReason.ERROR);
		}
		stack.push(val); // XXX: pushi
		return null;
	}
	def STRUCT_SET(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		var val = stack.popV(decl.field_types[field_index].valtype);
		var obj = stack.popStruct();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		obj.setFieldValue(field_index, val);
		return null;
	}
	def ARRAY_NEW(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var length = stack.popu();
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var vals = Array<Value>.new(u31.!(length));
			var elem = stack.popV(decl.elem_types[0].valtype);
			for (i < vals.length) vals[i] = elem;
			stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
		} else {
			return ObjectRuntime.ARRAY_NEW(stack, decl, length);
		}
		return null;
	}
	def ARRAY_NEW_DEFAULT(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var length = stack.popu();
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var vals = Array<Value>.new(u31.!(length));
			var elem = Values.default(decl.elem_types[0].valtype);
			for (i < vals.length) vals[i] = elem;
			stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
		} else {
			return ObjectRuntime.ARRAY_NEW_DEFAULT(stack, decl, length);
		}
		return null;
	}
	def ARRAY_NEW_FIXED(stack: ExecStack, instance: Instance, array_index: u31, length: u32) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var vals = Array<Value>.new(u31.!(length));
			var t = decl.elem_types[0].valtype;
			for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popV(t);
			stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
		} else {
			return ObjectRuntime.ARRAY_NEW_FIXED(stack, decl, length);
		}
		return null;
	}
	def ARRAY_NEW_DATA(stack: ExecStack, instance: Instance, array_index: u31, data_index: u31) -> Throwable {
		var length = stack.popu();
		var offset = stack.popu();
		if (instance.dropped_data[data_index]) return stack.trap(TrapReason.MEMORY_OOB);
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		var ddecl = instance.module.data[data_index];
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var t = bytesToVals(rtt.elem_types[0], ddecl.data, offset, length);
			if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
			stack.push(Value.Ref(HeapArrayValue.new(rtt, t.1)));
		} else {
			return ObjectRuntime.ARRAY_NEW_DATA(stack, instance, rtt, ddecl, offset, length, data_index);
		}
		return null;
	}
	def ARRAY_NEW_ELEM(stack: ExecStack, instance: Instance, array_index: u31, elem_index: u31) -> Throwable {
		var length = stack.popu();
		var offset = stack.popu();
		if (instance.dropped_elems[elem_index]) return stack.trap(TrapReason.MEMORY_OOB);
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		var edecl = instance.module.elems[elem_index];
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var r = getElems(instance, edecl, offset, length);
			if (!r.0) return stack.trap(TrapReason.TABLE_OOB);
			var vals = Array<Value>.new(u31.!(length));
			for (i < vals.length) {
				var val = r.1[i];
				vals[i] = if(ObjectI31.?(val), Value.I31(ObjectI31.!(val).val), Value.Ref(val));
			}
			stack.push(Value.Ref(HeapArrayValue.new(rtt, vals)));
		} else {
			 return ObjectRuntime.ARRAY_NEW_ELEM(stack, instance, rtt, edecl, offset, length);
		}
		return null;
	}
	def ARRAY_GET(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		stack.push(obj.getValue(index));
		return null;
	}
	def ARRAY_GET_S(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		stack.push(V3Eval.signExtend(decl.elem_types[0], obj.getValue(index))); // XXX: pushi
		return null;
	}
	def ARRAY_GET_U(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		stack.push(V3Eval.zeroExtend(decl.elem_types[0], obj.getValue(index))); // XXX: pushi
		return null;
	}
	def ARRAY_SET(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var val = stack.popV(decl.elem_types[0].valtype);
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		obj.setValue(index, val);
		return null;
	}
	def ARRAY_LEN(stack: ExecStack, instance: Instance) -> Throwable {
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		stack.pushi(obj.length());
		return null;
	}
	def ARRAY_FILL(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		var size = stack.popu();
		var stype = rtt.elem_types[0];
		var val = stack.popV(stype.valtype); // XXX: polymorphic pop
		var offset = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var index = ArrayUtil.boundsCheckWithLength(u31.view(obj.length()), offset, 0, size);
		if (index < 0) return stack.trap(TrapReason.ARRAY_OOB);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var vals = obj.getArray<Value>();
			var r = vals[index ..+ size];
			for (i < r.length) r[i] = val;
		} else {
			return ObjectRuntime.ARRAY_FILL(obj, rtt, index, size, val);
		}
		return null;
	}
	def ARRAY_COPY(stack: ExecStack, instance: Instance, array_index1: u31, array_index2: u31) -> Throwable {
		var size = stack.popu();
		var src_offset = stack.popu();
		var src = stack.popArray();
		var dst_offset = stack.popu();
		var dst = stack.popArray();
		if (src == null || dst == null) return stack.trap(TrapReason.NULL_DEREF);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var r = ArrayUtil.safeCopy(dst.getArray<Value>(), dst_offset, src.getArray<Value>(), src_offset, size);
			if (!r) return stack.trap(TrapReason.ARRAY_OOB);
			return null;
		} else {
			return ObjectRuntime.ARRAY_COPY(stack, dst, src, dst_offset, src_offset, size);
		}
	}
	def ARRAY_INIT_DATA(stack: ExecStack, instance: Instance, array_index: u31, data_index: u31) -> Throwable {
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		if (instance.dropped_data[data_index]) return if(size > 0, stack.trap(TrapReason.DATA_SEGMENT_DROPPED), null);
		var data = instance.module.data[data_index].data;
		if (ArrayUtil.boundsCheckWithLength(u31.view(obj.length()), dst_offset, 0, size) < 0) return stack.trap(TrapReason.ARRAY_OOB);
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var t = bytesToVals(rtt.elem_types[0], data, src_offset, size);
			if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
			var vals = obj.getArray<Value>();
			ArrayUtil.safeCopy(vals, dst_offset, t.1, 0, size);
			return null;
		} else {
			return ObjectRuntime.ARRAY_INIT_DATA(stack, obj, rtt, data, dst_offset, src_offset, size);
		}
	}
	def ARRAY_INIT_ELEM(stack: ExecStack, instance: Instance, array_index: u31, elem_index: u31) -> Throwable {
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popu();
		var obj = stack.popArray();
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (instance.dropped_elems[elem_index]) return if(size > 0, stack.trap(TrapReason.ELEM_SEGMENT_DROPPED), null);
		var edecl = instance.module.elems[elem_index];
		if (ObjReps.arrayMode == ArrayMode.Original) {
			var vals = HeapArrayValue.!(obj).vals;
			var r = getElems(instance, edecl, src_offset, size);
			if (!r.0) return stack.trap(TrapReason.ARRAY_OOB);
			if (ArrayUtil.boundsCheck(vals, dst_offset, size) < 0) return stack.trap(TrapReason.ARRAY_OOB);
			for (i < r.1.length) {
				vals[int.!(dst_offset)+i] = Value.Ref(r.1[i]);
			}
		} else {
			return ObjectRuntime.ARRAY_INIT_ELEM(stack, obj, instance, edecl, dst_offset, src_offset, size);
		}
		return null;
	}
	// --- Table operations -----------------------------------------------------------------------------------------
	def TABLE_INIT(stack: ExecStack, instance: Instance, elem_index: u31, table_index: u31) -> Throwable {
		var elem = if (!instance.dropped_elems[elem_index], instance.module.elems[elem_index]);
		var table = instance.tables[table_index], sc = table.decl.size;
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popa(sc);
		var t = table.copyE(instance, dst_offset, elem, src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def TABLE_COPY(stack: ExecStack, instance: Instance, table_index1: u31, table_index2: u31) -> Throwable {
		var dst = instance.tables[table_index1];
		var src = instance.tables[table_index2];
		var dit = dst.decl.size;
		var sit = src.decl.size;
		var nit = if(dit.is64, sit, dit);
		var size = stack.popa(nit);
		var src_offset = stack.popa(sit);
		var dst_offset = stack.popa(dit);
		var t = dst.copyT(dst_offset, src, src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def TABLE_GROW(stack: ExecStack, instance: Instance, table_index: u31) {
		var table = instance.tables[table_index], sc = table.decl.size;
		var size = stack.popa(sc);
		var val = stack.popV(table.elemtype);
		var r = table.grow(size, val);
		stack.pusha(sc, u64.view(r));
	}
	def TABLE_FILL(stack: ExecStack, instance: Instance, table_index: u31) -> Throwable {
		var table = instance.tables[table_index], sc = table.decl.size;
		var size = stack.popa(sc);
		var val = stack.popV(table.elemtype);
		var dest = stack.popa(sc);
		var t = table.fill(dest, val, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def MEMORY_INIT(stack: ExecStack, instance: Instance, data_index: u31, mem_index: u31) -> Throwable {
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var ddecl = if(!instance.dropped_data[data_index], instance.module.data[data_index]);
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popa(sc);
		var t = memory.copyIn(dst_offset, if(ddecl != null, ddecl.data), src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def MEMORY_COPY(stack: ExecStack, instance: Instance, mem_index1: u31, mem_index2: u31) -> Throwable {
		var dst = instance.memories[mem_index1];
		var src = instance.memories[mem_index2];
		var size = stack.popa(src.decl.size);
		var src_offset = stack.popa(src.decl.size);
		var dst_offset = stack.popa(dst.decl.size);
		var t = dst.copyM(dst_offset, src, src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def MEMORY_FILL(stack: ExecStack, instance: Instance, mem_index: u31) -> Throwable {
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var size = stack.popa(sc);
		var val = stack.popu();
		var dest = stack.popa(sc);
		var t = memory.fill(dest, u8.view(val), size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	// --- Atomic operations -----------------------------------------------------------------------------------------
	def MEMORY_ATOMIC_NOTIFY(stack: ExecStack, instance: Instance, mem_index: u31, offset: u64) -> Throwable { // TODO: nop for now
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var count = stack.popu();
		var index = stack.popa(sc);
		stack.pushu(0);
		return null;
	}
	def MEMORY_ATOMIC_WAIT32(stack: ExecStack, instance: Instance, mem_index: u31, offset: u64) -> Throwable { // TODO: nop for now
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var timeout = stack.popw();
		var expected = stack.popu();
		var index = stack.popa(sc);
		stack.pushu(0);
		return null;
	}
	def MEMORY_ATOMIC_WAIT64(stack: ExecStack, instance: Instance, mem_index: u31, offset: u64) -> Throwable { // TODO: nop for now
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var timeout = stack.popw();
		var expected = stack.popw();
		var index = stack.popa(sc);
		stack.pushu(0);
		return null;
	}
	def ATOMIC_FENCE() { // XXX: nop on single-threaded targets
	}
	def CONT_NEW(stack: WasmStack, instance: Instance, cont_index: u31) -> Throwable {
		var cont_decl = ContDecl.!(instance.heaptypes[cont_index]);
		var func_ref = stack.popV(ValueType.Ref(true, HeapType.Func(cont_decl.sig)));
		var func = Function.!(Value.Ref.!(func_ref).val);
		if (func == null) return stack.trap(TrapReason.NULL_DEREF);

		var new_stack = Target.newWasmStack().reset(func);
		new_stack.cont_bottom = new_stack;
		var cont = Continuations.makeContinuation(new_stack);
		stack.push(Value.Cont(cont));
		return null;
	}
	def CONT_BIND(stack: WasmStack, instance: Instance, in_cont_index: u31, out_cont_index: u31) -> Throwable {
		var in_cont = ContDecl.!(instance.heaptypes[in_cont_index]);
		var out_cont = ContDecl.!(instance.heaptypes[out_cont_index]);
		var n_binds = in_cont.sig.params.length - out_cont.sig.params.length;

		var cont = stack.popContinuation();
		var vals = stack.popN(in_cont.sig.params[0 ... n_binds]);
		if (Continuations.isNull(cont)) return stack.trap(TrapReason.NULL_DEREF);
		if (Continuations.isUsed(cont)) return stack.trap(TrapReason.USED_CONTINUATION);

		var cont_stack = cont.stack;
		Continuations.setUsed(cont);
		var new_cont = Continuations.makeContinuation(cont_stack);

		new_cont.stack.bind(vals);
		stack.push(Value.Cont(new_cont));
		return null;
	}
	// Finds a handler for {tag} by unwinding the stack-switching chain and return
	// a freshly created continuation with {Continuation.bottom} pointing to the
	// direct child of the handler stack.
	def unwindStackChain(stack: WasmStack, instance: Instance, tag: u31, get_handler: (WasmStack, Tag) -> ExHandler) -> Continuation {
		var prev = stack; // stack == <top of stack chain>
		while (prev.parent != null) {
			var parent = prev.parent;
			var handler = get_handler(parent, instance.tags[tag]);
			if (handler.handler_pc >= 0) {
				stack.cont_bottom = prev;
				return Continuations.makeContinuation(stack);
			}
			prev = parent;
		}
		return Continuations.NULL;
	}
	def matchRtt(obj: Object, rtt: HeapTypeDecl) -> bool {
		match (obj) {
			x: HeapObject => return ValueTypes.isAssignableHeap(x.decl, rtt);
			x: WasmFunction => return ValueTypes.isAssignableHeap(x.sig, rtt);
		}
		return false;
	}
	def cast(instance: Instance, nullable: bool, ht_val: int, val: Value) -> bool {
		match (val) {
			Ref(obj) => {
				match (obj) {
					null => return nullable;
					_ => return castObject(instance, ht_val, obj);
				}
			}
			I31(val) => {
				match (ht_val) {
					BpHeapTypeCode.EXTERN.val,
					BpHeapTypeCode.ANY.val,
					BpHeapTypeCode.EQ.val,
					BpHeapTypeCode.I31.val => return true;
					_ => return false;
				}
			}
			_ => return false;
		}
	}
	def castObject(instance: Instance, ht_val: int, obj: Object) -> bool {
		match (ht_val) {
			BpHeapTypeCode.FUNC.val => return Function.?(obj);
			BpHeapTypeCode.EXTERN.val => return Object.?(obj);
			BpHeapTypeCode.ARRAY.val => return HeapArrayGeneric.?(obj);
			BpHeapTypeCode.STRUCT.val => return HeapStructGeneric.?(obj);
			BpHeapTypeCode.ANY.val => return Object.?(obj);
			BpHeapTypeCode.EQ.val => return HeapObject.?(obj);
			BpHeapTypeCode.I31.val,		// fallthru
			BpHeapTypeCode.NOCONT.val, 	// fallthru
			BpHeapTypeCode.NOFUNC.val,	// fallthru
			BpHeapTypeCode.NOEXTERN.val, 	// fallthru
			BpHeapTypeCode.NONE.val => return false;
			_ => {
				var index = u32.!(ht_val); // XXX: make this a runtime error?
				var rtt = instance.heaptypes[index];
				return matchRtt(obj, rtt);
			}
		}
	}
	def copyElemsInto(dest: Array<Value>, instance: Instance, dst_offset: u64, elem: ElemDecl, src_offset: u64, size: u64) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) {
			FuncRefs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, instance.getFunctionAsVal);
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, instance.evalInitExpr);
			}
		}
	}
	def getElems(instance: Instance, elem: ElemDecl, src_offset: u64, size: u64) -> (bool, Array<Object>) {
		if (elem == null) {
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return (false, null);
			return (true, Array<Object>.new(0));
		}
		var dest = Array<Object>.new(int.!(size));
		var result = false;
		match (elem.details) {
			FuncRefs(vals) => {
				result = ArrayUtil.safeCopyF(dest, 0, vals, src_offset, size, fun(idx: int) => instance.functions[idx]);
			}
			Exprs(vals) => {
				result = ArrayUtil.safeCopyF(dest, 0, vals, src_offset, size, instance.evalInitExprObject);
			}
		}
		return (result, if(result, dest));
	}
	def getData<T>(instance: Instance, data_index: u31, src_offset: u64, size: u64, func: DataReader -> T) -> (bool, Array<T>) {
		var data = if(!instance.dropped_data[data_index], instance.module.data[data_index]);
		if (data == null) return (false, null);
		var start = ArrayUtil.boundsCheck(data.data, src_offset, size);
		if (start < 0) return (false, null);
		var vals = Array<T>.new(int.!(size));
		var d = DataReader.new(data.data).reset(data.data, int.!(src_offset), data.data.length);
		for (i < vals.length) vals[i] = func(d);
		return (d.ok, if(d.ok, vals));
	}
	def bytesToVals(storage: StorageType, data: Array<byte>, offset: u32, length: u32) -> (bool, Array<Value>) { // TODO: MaybeTrap
		var vals = Array<Value>.new(int.!(length));
		var size = sizeOfStorage(storage);
		var nbytes = length * size;
		var start = ArrayUtil.boundsCheck(data, offset, nbytes);
		if (start < 0) return (false, null);
		var d = ExtendedDataReader.new(data).reset(data, start, start + int.!(nbytes));
		match (storage.pack) {
			UNPACKED => {
				match (storage.valtype) {
					I32 => for (i < vals.length) vals[i] = Value.I32(d.read_u32());
					I64 => for (i < vals.length) vals[i] = Value.I64(d.read_u64());
					F32 => for (i < vals.length) vals[i] = Value.F32(d.read_u32());
					F64 => for (i < vals.length) vals[i] = Value.F64(d.read_u64());
					V128 => for (i < vals.length) vals[i] = Value.V128(d.read_u64(), d.read_u64());
					_ => ;
				}
			}
			PACKED_I8 => for (i < vals.length) vals[i] = Value.I32(d.read_u8());
			PACKED_I16 => for (i < vals.length) vals[i] = Value.I32(d.read_u16());
		}
		return (d.ok, vals);
	}
	def sizeOfStorage(storage: StorageType) -> u32 {
		match (storage.pack) {
			UNPACKED => {
				match (storage.valtype) {
					I32, F32 => return 4;
					I64, F64 => return 8;
					V128 => return 16;
					_ => return 8;
				}
			}
			PACKED_I8 => return 1;
			PACKED_I16 => return 2;
		}
	}

}
class ExtendedDataReader extends DataReader {
	new(data: Range<byte>) super(data) { }
	def read_u8() => read1();
	def read_u16() -> u16 {
		var range = acquire(2);
		if (range.length != 2) return 0;
		at(pos + 2);
		return DataReaders.read_range_u16(range);
	}
}
