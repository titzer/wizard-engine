// Copyright 2023 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Shared runtime routines that are called by different execution tiers, both the
// pure-Virgil (V3) implementation, and any native implementations.
component Runtime {
	def GLOBAL_GET(stack: ExecStack, instance: Instance, global_index: u31) {
		var val = instance.globals[global_index].get();
		stack.push(val);
	}
	def GLOBAL_SET(stack: ExecStack, instance: Instance, global_index: u31) {
		var g = instance.globals[global_index];
		var val = stack.popV(g.valtype);
		g.set(val);
	}
	def TABLE_GET(stack: ExecStack, instance: Instance, table_index: u31) -> Throwable {
		var table = instance.tables[table_index], elems = table.elems;
		var elem = stack.popa(table.decl.size);
		if (elem >= elems.length) return stack.trap(TrapReason.TABLE_OOB);
		stack.push(elems[elem]);
		return null;
	}
	def TABLE_SET(stack: ExecStack, instance: Instance, table_index: u31) -> Throwable {
		var table = instance.tables[table_index], elems = table.elems;
		var val = stack.popV(table.elemtype);
		var elem = stack.popa(table.decl.size);
		if (elem >= elems.length) return stack.trap(TrapReason.TABLE_OOB);
		table[int.!(elem)] = val;
		return null;
	}
	def MEMORY_GROW(stack: ExecStack, instance: Instance, mem_index: u31) {
		var memory = instance.memories[mem_index];
		var pages = stack.popa(memory.decl.size);
		var result : long = memory.grow(pages);
		stack.pusha(memory.decl.size, u64.view(result));
	}
	// --- GC operations -----------------------------------------------------------------------------------------
	def STRUCT_NEW(stack: ExecStack, instance: Instance, struct_index: u31) {
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		var obj: HeapStructGeneric;
		match (ObjTuning.structMode) {
			Pair => {
				var bytes = if(decl.num_bytes == 0, null, Array<byte>.new(decl.num_bytes));
				var objs = if(decl.num_refs == 0, null, Array<Object>.new(decl.num_refs));
				obj = HeapStructPair.new(decl, objs, bytes);

				for (i = decl.field_types.length - 1; i >= 0; i--) {
					var index = u31.!(i);
					match (decl.field_shifts[i]) {
						0 => {
							var val = stack.popi();
							obj.setFieldI8(index, i8.view(val));
						}
						1 => {
							var val = stack.popi();
							obj.setFieldI16(index, i16.view(val));
						}
						2 => {
							if (decl.field_types[i].valtype == ValueType.I32) {
								var val = stack.popi();
								obj.setFieldI32(index, val);
							} else {
								var val = stack.popf();
								obj.setFieldF32(index, val);
							}
						}
						3 => {
							if (decl.field_types[i].valtype == ValueType.I64) {
								var val = stack.popl();
								obj.setFieldI64(index,  val);
							} else {
								var val = stack.popd();
								obj.setFieldF64(index, val);
							}
						}
						4 => {
							var pair = stack.pops();
							obj.setFieldV128(index, pair.0, pair.1);
						}
						-1 => {
							var o = stack.popObject();
							obj.setFieldRef(index, o);
						}
					}
				}
			}
			_ => {
				var fields = Array<Value>.new(decl.field_types.length);
				for (i = fields.length - 1; i >= 0; i--) {
					fields[i] = stack.popV(decl.field_types[i].valtype);
				}
				obj = HeapStruct.new(decl, fields);
			}
		}
		stack.push(Value.Ref(obj));
	}
	def STRUCT_NEW_DEFAULT(stack: ExecStack, instance: Instance, struct_index: u31) {
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		var obj: HeapStructGeneric;
		match (ObjTuning.structMode) {
			 Pair => {
				var bytes = if(decl.num_bytes == 0, null, Array<byte>.new(decl.num_bytes));
				var objs = if(decl.num_refs == 0, null, Array<Object>.new(decl.num_refs));
				obj = HeapStructPair.new(decl, objs, bytes);

				for (i < decl.field_types.length) {
					var index = u31.view(i);
					match (decl.field_shifts[i]) {
						0 => {
							obj.setFieldI8(index, 0);
						}
						1 => {
							obj.setFieldI16(index, 0);
						}
						2 => {
							if (decl.field_types[i].valtype == ValueType.I32) {
								obj.setFieldI32(index, 0);
							} else {
								obj.setFieldF32(index, 0.0f);
							}
						}
						3 => {
							if (decl.field_types[i].valtype == ValueType.I64) {
								obj.setFieldI64(index, 0);
							} else {
								obj.setFieldF64(index, 0.0d);
							}
						}
						4 => {
							obj.setFieldV128(index, 0, 0);
						}
						-1 => {
							obj.setFieldRef(index, null);
						}
					}
				}
			}
			_ => {
				var fields = Array<Value>.new(decl.field_types.length);
				for (i < fields.length) {
					fields[i] = Values.default(decl.field_types[i].valtype);
				}
				obj = HeapStruct.new(decl, fields);
			}
		}
		stack.push(Value.Ref(obj));
	}
	def STRUCT_GET(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var obj = stack.popStruct();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		stack.push(obj.getFieldValue(field_index));
		return null;
	}
	def STRUCT_GET_S(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var obj = stack.popStruct();
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var val: Value;
		match (decl.field_types[field_index].pack) {
			PACKED_I8 => {
				val = obj.getFieldSignExtend8Value(field_index);
			}
			PACKED_I16 => {
				val = obj.getFieldSignExtend16Value(field_index);
			}
			UNPACKED => {
				return stack.trap(TrapReason.ERROR);
			}
		}
		stack.push(val); // XXX: pushi
		return null;
	}
	def STRUCT_GET_U(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var obj = stack.popStruct();
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var val: Value;
		match (decl.field_types[field_index].pack) {
			PACKED_I8 => {
				val = obj.getFieldZeroExtend8Value(field_index);
			}
			PACKED_I16 => {
				val = obj.getFieldZeroExtend16Value(field_index);
			}
			UNPACKED => {
				return stack.trap(TrapReason.ERROR);
			}
		}
		stack.push(val); // XXX: pushi
		return null;
	}
	def STRUCT_SET(stack: ExecStack, instance: Instance, struct_index: u31, field_index: u31) -> Throwable {
		var decl = StructDecl.!(instance.heaptypes[struct_index]);
		var val = stack.popV(decl.field_types[field_index].valtype);
		var obj = stack.popStruct();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		obj.setFieldValue(field_index, val);
		return null;
	}
	def ARRAY_NEW(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var length = stack.popu();
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (decl.elem_types[0].pack) {
					UNPACKED => {
						match (decl.elem_types[0].valtype) {
							I32 => {
								var vals = Array<u32>.new(u31.!(length));
								var elem = stack.popu();
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayI32.new(decl, vals)));
							}
							I64 => {
								var vals = Array<u64>.new(u31.!(length));
								var elem = stack.popw();
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayI64.new(decl, vals)));
							}
							F32 => {
								var vals = Array<u32>.new(u31.!(length));
								var elem = u32.view(stack.popf());
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayF32.new(decl, vals)));
							}
							F64 => {
								var vals = Array<u64>.new(u31.!(length));
								var elem = u64.view(stack.popd());
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayF64.new(decl, vals)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var vals = Array<u31>.new(u31.!(length));
									var elem = stack.popV(ValueType.Ref(false, HeapType.I31));
									var val = ObjectI31.!(Value.Ref.!(elem).val).val;
									for (i < vals.length) vals[i] = val;
									stack.push(Value.Ref(HeapArrayI31.new(decl, vals)));
								} else {
									var vals = Array<Object>.new(u31.!(length));
									var elem = stack.popObject();
									for (i < vals.length) vals[i] = elem;
									stack.push(Value.Ref(HeapArrayRef.new(decl, vals)));
								}
							}
							V128 => {
								var vals = Array<u64>.new(u31.!(length << 1));
								var v128 = stack.pops();
								var low = v128.0;
								var high = v128.1;
								for (i = 0; i < vals.length; i += 2) {
									vals[i] = low;
									vals[i+1] = high;
								}
								stack.push(Value.Ref(HeapArrayV128.new(decl, vals)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var elem = stack.popV(decl.elem_types[0].valtype);
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
							}
						}
					}
					PACKED_I8 => {
						var vals = Array<u8>.new(u31.!(length));
						var elem = u8.view(stack.popu());
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayI8.new(decl, vals)));
					}
					PACKED_I16 => {
						var vals = Array<u16>.new(u31.!(length));
						var elem = u16.view(stack.popu());
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayI16.new(decl, vals)));
					}
				}
			}
			Pair => {
				var len = u31.!(length);
				match (decl.elem_types[0].pack) {
					UNPACKED => {
						match (decl.elem_types[0].valtype) {
							I32 => {
								var bytes = Array<byte>.new(len << 2);
								var elem = stack.popu();
								var offset = 0;
								for (i < len) {
									Ref<Layout_u32>.at(bytes, offset).val = elem;
									offset += 4;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
							}
							I64 => {
								var bytes = Array<byte>.new(len << 3);
								var elem = stack.popw();
								var offset = 0;
								for (i < len) {
									Ref<Layout_u64>.at(bytes, offset).val = elem;
									offset += 8;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 3)));
							}
							F32 => {
								var bytes = Array<byte>.new(len << 2);
								var elem = stack.popf();
								var offset = 0;
								for (i < len) {
									Ref<Layout_u32>.at(bytes, offset).val = u32.view(elem);
									offset += 4;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
							}
							F64 => {
								var bytes = Array<byte>.new(len << 3);
								var elem = stack.popd();
								var offset = 0;
								for (i < len) {
									Ref<Layout_u64>.at(bytes, offset).val = u64.view(elem);
									offset += 8;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 3)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var bytes = Array<byte>.new(len << 2);
									var elem = stack.popV(ValueType.Ref(false, HeapType.I31));
									var val = ObjectI31.!(Value.Ref.!(elem).val).val;
									var offset = 0;
									for (i < len) {
										Ref<Layout_u31>.at(bytes, offset).val = val;
										offset += 4;
									}
									stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
								} else {
									var vals = Array<Object>.new(len);
									var elem = stack.popObject();
									for (i < len) vals[i] = elem;
									stack.push(Value.Ref(HeapArrayPair.new(decl, vals, null, Values.OBJS_SHIFT)));
								}
							}
							V128 => {
								var bytes = Array<byte>.new(len << 4);
								var v128 = stack.pops();
								var low = v128.0;
								var high = v128.1;
								var offset = 0;
								for (i < len) {
									var r = Ref<Layout_u128>.at(bytes, offset);
									r.lo_val = low;
									r.hi_val = high;
									offset += 16;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 4)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var elem = stack.popV(decl.elem_types[0].valtype);
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
							}
						}
					}
					PACKED_I8 => {
						var bytes = Array<byte>.new(len);
						var elem = u8.view(stack.popu());
						for (i < len) {
							bytes[i] = elem;
						}
						stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 0)));
					}
					PACKED_I16 => {
						var bytes = Array<byte>.new(len << 1);
						var elem = u16.view(stack.popu());
						var offset = 0;
						for (i < len) {
							Ref<Layout_u16>.at(bytes, offset).val = elem;
							offset += 2;
						}
						stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 1)));
					}
				}
			}
			_ => {
				var vals = Array<Value>.new(u31.!(length));
				var elem = stack.popV(decl.elem_types[0].valtype);
				for (i < vals.length) vals[i] = elem;
				stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
			}
		}
		return null;
	}
	def ARRAY_NEW_DEFAULT(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var length = stack.popu();
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (decl.elem_types[0].pack) {
					UNPACKED => {
						match (decl.elem_types[0].valtype) {
							I32 => {
								var vals = Array<u32>.new(u31.!(length));
								// for (i < vals.length) vals[i] = 0u32;
								stack.push(Value.Ref(HeapArrayI32.new(decl, vals)));
							}
							I64 => {
								var vals = Array<u64>.new(u31.!(length));
								// for (i < vals.length) vals[i] = 0u64;
								stack.push(Value.Ref(HeapArrayI64.new(decl, vals)));
							}
							F32 => {
								var vals = Array<u32>.new(u31.!(length));
								// for (i < vals.length) vals[i] = u32.view(0.0f);
								stack.push(Value.Ref(HeapArrayF32.new(decl, vals)));
							}
							F64 => {
								var vals = Array<u64>.new(u31.!(length));
								// for (i < vals.length) vals[i] = u64.view(0.0d);
								stack.push(Value.Ref(HeapArrayF64.new(decl, vals)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var vals = Array<u31>.new(u31.!(length));
									// for (i < vals.length) vals[i] = null;
									stack.push(Value.Ref(HeapArrayI31.new(decl, vals)));
								} else {
									var vals = Array<Object>.new(u31.!(length));
									// for (i < vals.length) vals[i] = null;
									stack.push(Value.Ref(HeapArrayRef.new(decl, vals)));
								}
							}
							V128 => {
								var vals = Array<u64>.new(u31.!(length << 1));
								// for (i < vals.length) vals[i] = 0u64;
								stack.push(Value.Ref(HeapArrayV128.new(decl, vals)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var elem = Values.default(decl.elem_types[0].valtype);
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
							}
						}
					}
					PACKED_I8 => {
						var vals = Array<u8>.new(u31.!(length));
						// for (i < vals.length) vals[i] = 0u8;
						stack.push(Value.Ref(HeapArrayI8.new(decl, vals)));
					}
					PACKED_I16 => {
						var vals = Array<u16>.new(u31.!(length));
						// for (i < vals.length) vals[i] = 0u16;
						stack.push(Value.Ref(HeapArrayI16.new(decl, vals)));
					}
				}
			}
			Pair => {
				var len = u31.!(length);
				match (decl.elem_types[0].pack) {
					UNPACKED => {
						match (decl.elem_types[0].valtype) {
							I32, F32 => {
								var bytes = Array<byte>.new(len << 2);
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
							}
							I64, F64 => {
								var bytes = Array<byte>.new(len << 3);
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 3)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var bytes = Array<byte>.new(len << 2);
									stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
								} else {
									var vals = Array<Object>.new(len);
									stack.push(Value.Ref(HeapArrayPair.new(decl, vals, null, Values.OBJS_SHIFT)));
								}
							}
							V128 => {
								var bytes = Array<byte>.new(len << 4);
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 4)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var elem = Values.default(decl.elem_types[0].valtype);
								for (i < vals.length) vals[i] = elem;
								stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
							}
						}
					}
					PACKED_I8 => {
						var bytes = Array<byte>.new(len);
						stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 0)));
					}
					PACKED_I16 => {
						var bytes = Array<byte>.new(len << 1);
						stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 1)));
					}
				}
			}
			_ => {
				var vals = Array<Value>.new(u31.!(length));
				var elem = Values.default(decl.elem_types[0].valtype);
				for (i < vals.length) vals[i] = elem;
				stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
			}
		}
		return null;
	}
	def ARRAY_NEW_FIXED(stack: ExecStack, instance: Instance, array_index: u31, length: u32) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);

		match (ObjTuning.arrayMode) {
			 Typed => {
				match (decl.elem_types[0].pack) {
					UNPACKED => {
						match (decl.elem_types[0].valtype) {
							I32 => {
								var vals = Array<u32>.new(u31.!(length));
								for (i = vals.length - 1; i >= 0; i--) vals[i] = u32.view(stack.popu());
								stack.push(Value.Ref(HeapArrayI32.new(decl, vals)));
							}
							I64 => {
								var vals = Array<u64>.new(u31.!(length));
								for (i = vals.length - 1; i >= 0; i--) vals[i] = u64.view(stack.popw());
								stack.push(Value.Ref(HeapArrayI64.new(decl, vals)));
							}
							F32 => {
								var vals = Array<u32>.new(u31.!(length));
								for (i = vals.length - 1; i >= 0; i--) vals[i] = u32.view(stack.popf());
								stack.push(Value.Ref(HeapArrayF32.new(decl, vals)));
							}
							F64 => {
								var vals = Array<u64>.new(u31.!(length));
								for (i = vals.length - 1; i >= 0; i--) vals[i] = u64.view(stack.popd());
								stack.push(Value.Ref(HeapArrayF64.new(decl, vals)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var vals = Array<u31>.new(u31.!(length));
									for (i = vals.length - 1; i >= 0; i--) vals[i] = ObjectI31.!(stack.popObject()).val;
									stack.push(Value.Ref(HeapArrayI31.new(decl, vals)));

								} else {
									var vals = Array<Object>.new(u31.!(length));
									for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popObject();
									stack.push(Value.Ref(HeapArrayRef.new(decl, vals)));
								}
							}
							V128 => {
								var vals = Array<u64>.new(u31.!(length << 1));
								for (i = vals.length - 2; i >= 0; i -= 2) {
									var v128 = stack.pops();
									vals[i] = v128.0;
									vals[i+1] = v128.1;
								}
								stack.push(Value.Ref(HeapArrayV128.new(decl, vals)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var t = decl.elem_types[0].valtype;
								for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popV(t);
								stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
							}
						}
					}
					PACKED_I8 => {
						var vals = Array<u8>.new(u31.!(length));
						for (i = vals.length - 1; i >= 0; i--) vals[i] = u8.view(stack.popu());
						stack.push(Value.Ref(HeapArrayI8.new(decl, vals)));
					}
					PACKED_I16 => {
						var vals = Array<u16>.new(u31.!(length));
						for (i = vals.length - 1; i >= 0; i--) vals[i] = u16.view(stack.popu());
						stack.push(Value.Ref(HeapArrayI16.new(decl, vals)));
					}
				}
			}
			Pair => {
				var len = u31.!(length);
				match (decl.elem_types[0].pack) {
					UNPACKED => {
						match (decl.elem_types[0].valtype) {
							I32 => {
								var nbytes = len << 2;
								var bytes = Array<byte>.new(nbytes);
								for (i < len) {
									var elem = stack.popu();
									nbytes -= 4;
									Ref<Layout_u32>.at(bytes, nbytes).val = elem;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
							}
							I64 => {
								var nbytes = len << 3;
								var bytes = Array<byte>.new(nbytes);
								for (i < len) {
									var elem = stack.popw();
									nbytes -= 8;
									Ref<Layout_u64>.at(bytes, nbytes).val = elem;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 3)));
							}
							F32 => {
								var nbytes = len << 2;
								var bytes = Array<byte>.new(nbytes);
								for (i < len) {
									var elem = stack.popf();
									nbytes -= 4;
									Ref<Layout_u32>.at(bytes, nbytes).val = u32.view(elem);
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
							}
							F64 => {
								var nbytes = len << 3;
								var bytes = Array<byte>.new(nbytes);
								for (i < len) {
									var elem = stack.popd();
									nbytes -= 8;
									Ref<Layout_u64>.at(bytes, nbytes).val = u64.view(elem);
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 3)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && ! nullable) {
									var nbytes = len << 2;
									var bytes = Array<byte>.new(nbytes);
									for (i < len) {
										var elem = ObjectI31.!(stack.popObject()).val;
										nbytes -= 4;
										Ref<Layout_u31>.at(bytes, nbytes).val = elem;
									}
									stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 2)));
								} else {
									var vals = Array<Object>.new(len);
									for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popObject();
									stack.push(Value.Ref(HeapArrayPair.new(decl, vals, null, Values.OBJS_SHIFT)));
								}
							}
							V128 => {
								var nbytes = len << 4;
								var bytes = Array<byte>.new(nbytes);
								for (i < len) {
									var v128 = stack.pops();
									nbytes -= 16;
									var r = Ref<Layout_u128>.at(bytes, nbytes);
									r.lo_val = v128.0;
									r.hi_val = v128.1;
								}
								stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 4)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var t = decl.elem_types[0].valtype;
								for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popV(t);
								stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
							}
						}
					}
					PACKED_I8 => {
						var bytes = Array<byte>.new(len);
						var nbytes = len;
						for (i < len) {
							var elem = u8.view(stack.popu());
							nbytes -= 1;
							bytes[nbytes] = elem;
						}
						stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 0)));
					}
					PACKED_I16 => {
						var nbytes = len << 1;
						var bytes = Array<byte>.new(nbytes);
						for (i < len) {
							var elem = u16.view(stack.popu());
							nbytes -= 2;
							Ref<Layout_u16>.at(bytes, nbytes).val = elem;
						}
						stack.push(Value.Ref(HeapArrayPair.new(decl, null, bytes, 1)));
					}
				}
			}
			_ => {
				var vals = Array<Value>.new(u31.!(length));
				var t = decl.elem_types[0].valtype;
				for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popV(t);
				stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
			}
		}
		return null;
	}
	def ARRAY_NEW_DATA(stack: ExecStack, instance: Instance, array_index: u31, data_index: u31) -> Throwable {
		var length = stack.popu();
		var offset = stack.popu();
		if (instance.dropped_data[data_index]) return stack.trap(TrapReason.MEMORY_OOB);
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		var ddecl = instance.module.data[data_index];
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (rtt.elem_types[0].pack) {
					UNPACKED => {
						match (rtt.elem_types[0].valtype) {
							I32 => {
								var t = bytesToI32s(ddecl.data, offset, length);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayI32.new(rtt, t.1)));
							}
							I64 => {
								var t = bytesToI64s(ddecl.data, offset, length);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayI64.new(rtt, t.1)));
							}
							F32 => {
								var t = bytesToI32s(ddecl.data, offset, length);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayF32.new(rtt, t.1)));
							}
							F64 => {
								var t = bytesToI64s(ddecl.data, offset, length);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayF64.new(rtt, t.1)));
							}
							Ref => {
								return stack.trap(TrapReason.ERROR);
							}
							V128 => {
								var t = bytesToI64s(ddecl.data, offset, length << 1);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayV128.new(rtt, t.1)));
							}
							_ => {
								var t = bytesToVals(rtt.elem_types[0], ddecl.data, offset, length);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayValue.new(rtt, t.1)));
							}
						}
					}
					PACKED_I8 => {
						var t = bytesToI8s(ddecl.data, offset, length);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayI8.new(rtt, t.1)));
					}
					PACKED_I16 => {
						var t = bytesToI16s(ddecl.data, offset, length);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayI16.new(rtt, t.1)));
					}
				}
			}
			Pair => {
				var elemSize = sizeOfStorage(rtt.elem_types[0]);
				var t = bytesToBytes(ddecl.data, offset, length * elemSize);
				if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
				match (rtt.elem_types[0].pack) {
					UNPACKED => {
						match (rtt.elem_types[0].valtype) {
							I32 => {
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 2)));
							}
							I64 => {
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 3)));
							}
							F32 => {
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 2)));
							}
							F64 => {
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 3)));
							}
							V128 => {
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 4)));
							}
							_ => {
								if (true) return stack.trap(TrapReason.ERROR);
								var t = bytesToVals(rtt.elem_types[0], ddecl.data, offset, length);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								stack.push(Value.Ref(HeapArrayValue.new(rtt, t.1)));
							}
						}
					}
					PACKED_I8 => {
						stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 0)));
					}
					PACKED_I16 => {
						stack.push(Value.Ref(HeapArrayPair.new(rtt, null, t.1, 1)));
					}
				}
			}
			_ => {
				var t = bytesToVals(rtt.elem_types[0], ddecl.data, offset, length);
				if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
				stack.push(Value.Ref(HeapArrayValue.new(rtt, t.1)));
			}
		}
		return null;
	}
	def ARRAY_NEW_ELEM(stack: ExecStack, instance: Instance, array_index: u31, elem_index: u31) -> Throwable {
		var length = stack.popu();
		var offset = stack.popu();
		if (instance.dropped_elems[elem_index]) return stack.trap(TrapReason.MEMORY_OOB);
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		var edecl = instance.module.elems[elem_index];
		if (length > Execute.limits.max_array_length) return stack.trap(TrapReason.OOM);
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (rtt.elem_types[0].pack) {
					UNPACKED => {
						match (rtt.elem_types[0].valtype) {
							I32 => {
								var vals = Array<u32>.new(u31.!(length));
								var r = copyElemsIntoI32(vals, instance, 0, edecl, offset, length);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayI32.new(rtt, vals)));
							}
							I64 => {
								var vals = Array<u64>.new(u31.!(length));
								var r = copyElemsIntoI64(vals, instance, 0, edecl, offset, length);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayI64.new(rtt, vals)));
							}
							F32 => {
								var vals = Array<u32>.new(u31.!(length));
								var r = copyElemsIntoI32(vals, instance, 0, edecl, offset, length);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayF32.new(rtt, vals)));
							}
							F64 => {
								var vals = Array<u64>.new(u31.!(length));
								var r = copyElemsIntoI64(vals, instance, 0, edecl, offset, length);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayF64.new(rtt, vals)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var vals = Array<u31>.new(u31.!(length));
									var r = copyElemsIntoI31(vals, instance, 0, edecl, offset, length);
									if (!r) return stack.trap(TrapReason.TABLE_OOB);
									stack.push(Value.Ref(HeapArrayI31.new(rtt, vals)));
								} else {
									var vals = Array<Object>.new(u31.!(length));
									var r = copyElemsIntoObject(vals, instance, 0, edecl, offset, length);
									if (!r) return stack.trap(TrapReason.TABLE_OOB);
									stack.push(Value.Ref(HeapArrayRef.new(rtt, vals)));
								}
							}
							V128 => {
								var vals = Array<u64>.new(u31.!(length << 1));
								var r = copyElemsIntoI64(vals, instance, 0, edecl, offset, length << 1);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayV128.new(rtt, vals)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var r = copyElemsInto(vals, instance, 0, edecl, offset, length);
								if (!r) return stack.trap(TrapReason.TABLE_OOB); // TODO: elem out of bounds
								stack.push(Value.Ref(HeapArrayValue.new(rtt, vals)));
							}
						}
					}
					PACKED_I8 => {
						var vals = Array<byte>.new(u31.!(length));
						var r = copyElemsIntoI8(vals, instance, 0, edecl, offset, length);
						if (!r) return stack.trap(TrapReason.TABLE_OOB);
						stack.push(Value.Ref(HeapArrayI8.new(rtt, vals)));
					}
					PACKED_I16 => {
						var vals = Array<u16>.new(u31.!(length));
						var r = copyElemsIntoI16(vals, instance, 0, edecl, offset, length);
						if (!r) return stack.trap(TrapReason.TABLE_OOB);
						stack.push(Value.Ref(HeapArrayI16.new(rtt, vals)));
					}
				}
			}
			Pair => {
				match (rtt.elem_types[0].pack) {
					UNPACKED => {
						match (rtt.elem_types[0].valtype) {
							I32, F32 => {
								var len = length << 2;
								var vals = Array<byte>.new(u31.!(len));
								var r = copyElemsIntoI32bytes(vals, instance, 0, edecl, offset, len);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, vals, 2)));
							}
							I64, F64 => {
								var len = length << 3;
								var vals = Array<byte>.new(u31.!(len));
								var r = copyElemsIntoI64bytes(vals, instance, 0, edecl, offset, len);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, vals, 3)));
							}
							Ref(nullable, heaptype) => {
								if (heaptype == HeapType.I31 && !nullable) {
									var len = length << 2;
									var bytes = Array<byte>.new(u31.!(len));
									var r = copyElemsIntoI32bytes(bytes, instance, 0, edecl, offset, len);
									if (!r) return stack.trap(TrapReason.TABLE_OOB);
									stack.push(Value.Ref(HeapArrayPair.new(rtt, null, bytes, 2)));
								} else {
									var vals = Array<Object>.new(u31.!(length));
									var r = copyElemsIntoObject(vals, instance, 0, edecl, offset, length);
									if (!r) return stack.trap(TrapReason.TABLE_OOB);
									stack.push(Value.Ref(HeapArrayPair.new(rtt, vals, null, Values.OBJS_SHIFT)));
								}
							}
							V128 => {
								var len = length << 4;
								var vals = Array<byte>.new(u31.!(len));
								var r = copyElemsIntoV128bytes(vals, instance, 0, edecl, offset, len);
								if (!r) return stack.trap(TrapReason.TABLE_OOB);
								stack.push(Value.Ref(HeapArrayPair.new(rtt, null, vals, 4)));
							}
							_ => {
								var vals = Array<Value>.new(u31.!(length));
								var r = copyElemsInto(vals, instance, 0, edecl, offset, length);
								if (!r) return stack.trap(TrapReason.TABLE_OOB); // TODO: elem out of bounds
								stack.push(Value.Ref(HeapArrayValue.new(rtt, vals)));
							}
						}
					}
					PACKED_I8 => {
						var vals = Array<byte>.new(u31.!(length));
						var r = copyElemsIntoI8(vals, instance, 0, edecl, offset, length);
						if (!r) return stack.trap(TrapReason.TABLE_OOB);
						stack.push(Value.Ref(HeapArrayPair.new(rtt, null, vals, 1)));
					}
					PACKED_I16 => {
						var len = length << 1;
						var vals = Array<byte>.new(u31.!(len));
						var r = copyElemsIntoI16bytes(vals, instance, 0, edecl, offset, len);
						if (!r) return stack.trap(TrapReason.TABLE_OOB);
						stack.push(Value.Ref(HeapArrayPair.new(rtt, null, vals, 1)));
					}
				}
			}
			_ => {
				var vals = Array<Value>.new(u31.!(length));
				var r = copyElemsInto(vals, instance, 0, edecl, offset, length);
				if (!r) return stack.trap(TrapReason.TABLE_OOB); // TODO: elem out of bounds
				stack.push(Value.Ref(HeapArrayValue.new(rtt, vals)));
			}
		}
		return null;
	}
	def ARRAY_GET(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		stack.push(obj.getValue(index));
		return null;
	}
	def ARRAY_GET_S(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		stack.push(V3Eval.signExtend(decl.elem_types[0], obj.getValue(index))); // XXX: pushi
		return null;
	}
	def ARRAY_GET_U(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		stack.push(V3Eval.zeroExtend(decl.elem_types[0], obj.getValue(index))); // XXX: pushi
		return null;
	}
	def ARRAY_SET(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var decl = ArrayDecl.!(instance.heaptypes[array_index]);
		var val = stack.popV(decl.elem_types[0].valtype);
		var index = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (index >= u32.view(obj.length())) return stack.trap(TrapReason.ARRAY_OOB);
		obj.setValue(index, val);
		return null;
	}
	def ARRAY_LEN(stack: ExecStack, instance: Instance) -> Throwable {
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		stack.pushi(obj.length());
		return null;
	}
	def ARRAY_FILL(stack: ExecStack, instance: Instance, array_index: u31) -> Throwable {
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		var size = stack.popu();
		var stype = rtt.elem_types[0];
		var val = stack.popV(stype.valtype); // XXX: polymorphic pop
		var offset = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var index = ArrayUtil.boundsCheckWithLength(u31.view(obj.length()), offset, 0, size);
		if (index < 0) return stack.trap(TrapReason.ARRAY_OOB);
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (obj) {
					x: HeapArrayValue => {
						var r = x.vals[index ..+ size];
						for (i < r.length) r[i] = val;
					}
					x: HeapArrayI32 => {
						var r = x.vals[index ..+ size];
						var v = Value.I32.!(val).val;
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayI31 => {
						var r = x.vals[index ..+ size];
						var v = Value.I31.!(val).val;
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayI64 => {
						var r = x.vals[index ..+ size];
						var v = Value.I64.!(val).val;
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayI8 => {
						var r = x.vals[index ..+ size];
						var v = u8.view(Value.I32.!(val).val);
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayI16 => {
						var r = x.vals[index ..+ size];
						var v = u16.view(Value.I32.!(val).val);
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayF32 => {
						var r = x.vals[index ..+ size];
						var v = Value.F32.!(val).bits;
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayF64 => {
						var r = x.vals[index ..+ size];
						var v = Value.F64.!(val).bits;
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayRef => {
						var r = x.vals[index ..+ size];
						var v = Value.Ref.!(val).val;
						for (i < r.length) r[i] = v;
					}
					x: HeapArrayV128 => {
						var r = x.vals[index ..+ (size << 1)];
						var v128 = Value.V128.!(val);
						for (i=0; i < r.length; i+=2) {
							r[i] = v128.low;
							r[i+1] = v128.high;
						}
					}
				}
			}
			Pair => {
				match (obj) {
					x: HeapArrayValue => {
						var r = x.vals[index ..+ size];
						for (i < r.length) r[i] = val;
					}
					x: HeapArrayPair => {
						var uindex = u32.!(index);
						match (stype.pack) {
							UNPACKED => {
								match (stype.valtype) {
									I32 => {
										var ival = i32.!(Value.I32.!(val).val);
										for (u = uindex; u < size; u++) {
											x.setI32(u, ival);
										}
									}
									I64 => {
										var ival = i64.!(Value.I64.!(val).val);
										for (u = uindex; u < size; u++) {
											x.setI64(u, ival);
										}
									}
									F32 => {
										var fval = float.!(Value.F32.!(val).bits);
										for (u = uindex; u < size; u++) {
											x.setF32(u, fval);
										}
									}
									F64 => {
										var fval = double.!(Value.F64.!(val).bits);
										for (u = uindex; u < size; u++) {
											x.setF64(u, fval);
										}
									}
									V128 => {
										var vals = Value.V128.!(val);
										var low = vals.low;
										var high = vals.high;
										for (u = uindex; u < size; u++) {
											x.setV128(u, low, high);
										}
									}
									Ref(nullable, heaptype) => {
										if (heaptype == HeapType.I31 && !nullable) {
											var ival = i31.!(Value.I31.!(val).val);
											for (u = uindex; u < size; u++) {
												x.setI31(u, ival);
											}
										} else {
											var rval = Value.Ref.!(val).val;
											for (u = uindex; u < size; u++) {
												x.setRef(u, rval);
											}
										}
									}
									_ => {}
								}
							}
							PACKED_I8 => {
								var ival = i8.!(Value.I32.!(val).val);
								for (u = uindex; u < size; u++) {
									x.setI8(u, ival);
								}
							}
							PACKED_I16 => {
								var ival = i16.!(Value.I32.!(val).val);
								for (u = uindex; u < size; u++) {
									x.setI16(u, ival);
								}
							}
						}
					}
				}
			}
			_ => {
				var vals = obj.getArray<Value>();
				var r = vals[index ..+ size];
				for (i < r.length) r[i] = val;
			}
		}
		return null;
	}
	def ARRAY_COPY(stack: ExecStack, instance: Instance, array_index1: u31, array_index2: u31) -> Throwable {
		var size = stack.popu();
		var src_offset = stack.popu();
		var src = stack.popArray();
		var dst_offset = stack.popu();
		var dst = stack.popArray();
		if (src == null || dst == null) return stack.trap(TrapReason.NULL_DEREF);
		match (ObjTuning.arrayMode) {
			 Typed => {
				if (HeapArrayValue.?(src) && HeapArrayValue.?(dst)) {
					var r = ArrayUtil.safeCopy(dst.getArray<Value>(), dst_offset, src.getArray<Value>(), src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}

				if (HeapArrayValue.?(dst)) {
					var arr = HeapArrayValue.!(dst);
					var r = ArrayUtil.safeCopyDiffTypes(arr.vals, dst_offset, u31.view(src.length()), src_offset, size, src.getValue);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}

				if (HeapArrayValue.?(src)){
					var arr = HeapArrayValue.!(src);
					match (dst) {
						x: HeapArrayI32 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU32);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayI31 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, fun (x: u32) => u31.!(arr.getI31(x)));
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayI64 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU64);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayI8 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU8);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayI16 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU16);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayF32 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU32);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayF64 => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU64);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayRef => {
							var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getRef);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
						x: HeapArrayV128 => {
							var r = ArrayUtil.safeCopyFromV128(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getV128);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}

						_ => { return stack.trap(TrapReason.ERROR); }
					}
				}

				match (src) {
					x: HeapArrayI32 => {
						if (HeapArrayI32.?(dst)) {
							var arr = HeapArrayI32.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayI31 => {
						if (HeapArrayI31.?(dst)) {
							var arr = HeapArrayI31.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayI64 => {
						if (HeapArrayI64.?(dst)) {
							var arr = HeapArrayI64.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayI8 => {
						if (HeapArrayI8.?(dst)) {
							var arr = HeapArrayI8.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayI16 => {
						if (HeapArrayI16.?(dst)) {
							var arr = HeapArrayI16.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayF32 => {
						if (HeapArrayF32.?(dst)) {
							var arr = HeapArrayF32.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayF64 => {
						if (HeapArrayF64.?(dst)) {
							var arr = HeapArrayF64.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayRef => {
						if (HeapArrayRef.?(dst)) {
							var arr = HeapArrayRef.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
					x: HeapArrayV128 => {
						if (HeapArrayV128.?(dst)) {
							var arr = HeapArrayV128.!(dst);
							var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size << 1);
							if (!r) return stack.trap(TrapReason.ARRAY_OOB);
							return null;
						}
					}
				}
			}
			Pair => {
				// HeapArrayValue -> HeapArrayValue
				if (HeapArrayValue.?(src) && HeapArrayValue.?(dst)) {
					var r = ArrayUtil.safeCopy(dst.getArray<Value>(), dst_offset, src.getArray<Value>(), src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}

				// HeapArrayPair -> HeapArrayPair
				if (HeapArrayPair.?(src) && HeapArrayPair.?(dst)) {
					var src_arr = HeapArrayPair.!(src);
					var dst_arr = HeapArrayPair.!(dst);
					var shift = src_arr.shift;

					if (shift != dst_arr.shift) return stack.trap(TrapReason.ERROR); // Validation should prevent this
					if (shift == Values.OBJS_SHIFT) {
						var r = ArrayUtil.safeCopy(dst_arr.objs, dst_offset, src_arr.objs, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					} else {
						var r = ArrayUtil.safeCopy(dst_arr.bytes, dst_offset << shift, src_arr.bytes, src_offset << shift, size << shift);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					return null;
				}

				// HeapArrayPair -> HeapArrayValue: shouldn't happen
				if (HeapArrayValue.?(dst)) {
					var arr = HeapArrayValue.!(dst);
					var r = ArrayUtil.safeCopyDiffTypes(arr.vals, dst_offset, u31.view(src.length()), src_offset, size, src.getValue);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}

				// HeapArrayValue -> HeapArrayPair: shouldn't happen
				if (HeapArrayValue.?(src)){
					var src_arr = HeapArrayValue.!(src);
					var dst_arr = HeapArrayPair.!(dst);

					var r = ArrayUtil.safeCopyFromValueToPair(dst_arr, dst_offset, src_arr, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			_ => {
				var r = ArrayUtil.safeCopy(dst.getArray<Value>(), dst_offset, src.getArray<Value>(), src_offset, size);
				if (!r) return stack.trap(TrapReason.ARRAY_OOB);
				return null;
			}
		}

		return stack.trap(TrapReason.ERROR);
	}
	def ARRAY_INIT_DATA(stack: ExecStack, instance: Instance, array_index: u31, data_index: u31) -> Throwable {
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popu();
		var obj = stack.popArray();
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		if (instance.dropped_data[data_index]) return if(size > 0, stack.trap(TrapReason.DATA_SEGMENT_DROPPED), null);
		var data = instance.module.data[data_index].data;
		if (ArrayUtil.boundsCheckWithLength(u31.view(obj.length()), dst_offset, 0, size) < 0) return stack.trap(TrapReason.ARRAY_OOB);
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (obj) {
					x: HeapArrayValue => {
						var t = bytesToVals(rtt.elem_types[0], data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
						return null;
					}
				}
				match (rtt.elem_types[0].pack) {
					UNPACKED => {
						match (rtt.elem_types[0].valtype) {
							I32 => {
								var t = bytesToI32s(data, src_offset, size);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								match (obj) {
									x: HeapArrayI32 => {
										ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
										return null;
									}
								}
							}
							I64 => {
								var t = bytesToI64s(data, src_offset, size);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								match (obj) {
									x: HeapArrayI64 => {
										ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
										return null;
									}
								}
							}
							F32 => {
								var t = bytesToI32s(data, src_offset, size);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								match (obj) {
									x: HeapArrayF32 => {
										ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
										return null;
									}
								}
							}
							F64 => {
								var t = bytesToI64s(data, src_offset, size);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								match (obj) {
									x: HeapArrayF64 => {
										ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
										return null;
									}
								}
							}
							V128 => {
								var t = bytesToI64s(data, src_offset, size << 1);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								match (obj) {
									x: HeapArrayV128 => {
										ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size << 1);
										return null;
									}
								}
							}
							_ => { }
						}
					}
					PACKED_I8 => {
						match (obj) {
							x: HeapArrayI8 => {
								var t = bytesToI8s(data, src_offset, size);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
								return null;
							}
						}
					}
					PACKED_I16 => {
						match (obj) {
							x: HeapArrayI16 => {
								var t = bytesToI16s(data, src_offset, size);
								if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
								return null;
							}
						}
					}
				}
			}
			Pair => {
				match (obj) {
					x: HeapArrayValue => {
						var t = bytesToVals(rtt.elem_types[0], data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
						return null;
					}
					x: HeapArrayPair => {
						var stype = rtt.elem_types[0];
						match (stype.pack) {
							UNPACKED => {
								match (stype.valtype) {
									I32, F32 => {
										size = size << 2;
									}
									I64, F64 => {
										size = size << 3;
									}
									V128 => {
										size = size << 4;
									}
									_ => {}
								}
							}
							PACKED_I8 => { /* leave the size alone */ }
							PACKED_I16 => {
								size = size << 1;
							}
						}
						var t = bytesToBytes(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						ArrayUtil.safeCopy(x.bytes, dst_offset, t.1, 0, size);
						return null;
					}
				}
			}
			_ => {
				var t = bytesToVals(rtt.elem_types[0], data, src_offset, size);
				if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
				var vals = obj.getArray<Value>();
				ArrayUtil.safeCopy(vals, dst_offset, t.1, 0, size);
				return null;
			}
		}

		return stack.trap(TrapReason.ERROR);
	}
	def ARRAY_INIT_ELEM(stack: ExecStack, instance: Instance, array_index: u31, elem_index: u31) -> Throwable {
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popu();
		var obj = stack.popArray();
		var rtt = ArrayDecl.!(instance.heaptypes[array_index]);
		if (obj == null) return stack.trap(TrapReason.NULL_DEREF);
		if (instance.dropped_elems[elem_index]) return if(size > 0, stack.trap(TrapReason.ELEM_SEGMENT_DROPPED), null);
		var edecl = instance.module.elems[elem_index];
		match (ObjTuning.arrayMode) {
			 Typed => {
				match (obj) {
					x: HeapArrayValue => {
						var r = copyElemsInto(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayI32 => {
						var r = copyElemsIntoI32(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayI31 => {
						var r = copyElemsIntoI31(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayI64 => {
						var r = copyElemsIntoI64(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayI8 => {
						var r = copyElemsIntoI8(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayI16 => {
						var r = copyElemsIntoI16(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayF32 => {
						var r = copyElemsIntoI32(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayF64 => {
						var r = copyElemsIntoI64(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayRef => {
						var r = copyElemsIntoObject(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayV128 => {
						var r = copyElemsIntoI64(x.vals, instance, dst_offset, edecl, src_offset, size << 1);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					_ => {return stack.trap(TrapReason.ARRAY_OOB);}
				}
			}
			Pair => {
				match (obj) {
					x: HeapArrayValue => { // shouldn't happen ...
						var r = copyElemsInto(x.vals, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
					x: HeapArrayPair => {
						var stype = rtt.elem_types[0];
						match (stype.pack) {
							UNPACKED => {
								match (stype.valtype) {
									I32, F32 => {
										size = size << 2;
									}
									I64, F64 => {
										size = size << 3;
									}
									V128 => {
										size = size << 4;
									}
									_ => {}
								}
							}
							PACKED_I8 => { /* leave the size alone */ }
							PACKED_I16 => {
								size = size << 1;
							}
						}
						var r = copyElemsIntoI8(x.bytes, instance, dst_offset, edecl, src_offset, size);
						if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					}
				}
			}
			_ => {
				var vals = obj.getArray<Value>();
				var r = copyElemsInto(vals, instance, dst_offset, edecl, src_offset, size);
				if (!r) return stack.trap(TrapReason.ARRAY_OOB);
			}
		}
		return null;
	}
	// --- Table operations -----------------------------------------------------------------------------------------
	def TABLE_INIT(stack: ExecStack, instance: Instance, elem_index: u31, table_index: u31) -> Throwable {
		var elem = if (!instance.dropped_elems[elem_index], instance.module.elems[elem_index]);
		var table = instance.tables[table_index], sc = table.decl.size;
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popa(sc);
		var t = table.copyE(instance, dst_offset, elem, src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def TABLE_COPY(stack: ExecStack, instance: Instance, table_index1: u31, table_index2: u31) -> Throwable {
		var dst = instance.tables[table_index1];
		var src = instance.tables[table_index2];
		var dit = dst.decl.size;
		var sit = src.decl.size;
		var nit = if(dit.is64, sit, dit);
		var size = stack.popa(nit);
		var src_offset = stack.popa(sit);
		var dst_offset = stack.popa(dit);
		var t = dst.copyT(dst_offset, src, src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def TABLE_GROW(stack: ExecStack, instance: Instance, table_index: u31) {
		var table = instance.tables[table_index], sc = table.decl.size;
		var size = stack.popa(sc);
		var val = stack.popV(table.elemtype);
		var r = table.grow(size, val);
		stack.pusha(sc, u64.view(r));
	}
	def TABLE_FILL(stack: ExecStack, instance: Instance, table_index: u31) -> Throwable {
		var table = instance.tables[table_index], sc = table.decl.size;
		var size = stack.popa(sc);
		var val = stack.popV(table.elemtype);
		var dest = stack.popa(sc);
		var t = table.fill(dest, val, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def MEMORY_INIT(stack: ExecStack, instance: Instance, data_index: u31, mem_index: u31) -> Throwable {
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var ddecl = if(!instance.dropped_data[data_index], instance.module.data[data_index]);
		var size = stack.popu();
		var src_offset = stack.popu();
		var dst_offset = stack.popa(sc);
		var t = memory.copyIn(dst_offset, if(ddecl != null, ddecl.data), src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def MEMORY_COPY(stack: ExecStack, instance: Instance, mem_index1: u31, mem_index2: u31) -> Throwable {
		var dst = instance.memories[mem_index1];
		var src = instance.memories[mem_index2];
		var size = stack.popa(src.decl.size);
		var src_offset = stack.popa(src.decl.size);
		var dst_offset = stack.popa(dst.decl.size);
		var t = dst.copyM(dst_offset, src, src_offset, size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	def MEMORY_FILL(stack: ExecStack, instance: Instance, mem_index: u31) -> Throwable {
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var size = stack.popa(sc);
		var val = stack.popu();
		var dest = stack.popa(sc);
		var t = memory.fill(dest, u8.view(val), size);
		if (t != TrapReason.NONE) return stack.trap(t);
		return null;
	}
	// --- Atomic operations -----------------------------------------------------------------------------------------
	def MEMORY_ATOMIC_NOTIFY(stack: ExecStack, instance: Instance, mem_index: u31, offset: u64) -> Throwable { // TODO: nop for now
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var count = stack.popu();
		var index = stack.popa(sc);
		stack.pushu(0);
		return null;
	}
	def MEMORY_ATOMIC_WAIT32(stack: ExecStack, instance: Instance, mem_index: u31, offset: u64) -> Throwable { // TODO: nop for now
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var timeout = stack.popw();
		var expected = stack.popu();
		var index = stack.popa(sc);
		stack.pushu(0);
		return null;
	}
	def MEMORY_ATOMIC_WAIT64(stack: ExecStack, instance: Instance, mem_index: u31, offset: u64) -> Throwable { // TODO: nop for now
		var memory = instance.memories[mem_index], sc = memory.decl.size;
		var timeout = stack.popw();
		var expected = stack.popw();
		var index = stack.popa(sc);
		stack.pushu(0);
		return null;
	}
	def ATOMIC_FENCE() { // XXX: nop on single-threaded targets
	}
	def CONT_NEW(stack: WasmStack, instance: Instance, cont_index: u31) -> Throwable {
		var cont_decl = ContDecl.!(instance.heaptypes[cont_index]);
		var func_ref = stack.popV(ValueType.Ref(true, HeapType.Func(cont_decl.sig)));
		var func = Function.!(Value.Ref.!(func_ref).val);
		if (func == null) return stack.trap(TrapReason.NULL_DEREF);

		var new_stack = Target.newWasmStack().reset(func);
		new_stack.cont_bottom = new_stack;
		var cont = Continuations.makeContinuation(new_stack);
		stack.push(Value.Ref(cont));
		return null;
	}
	def CONT_BIND(stack: WasmStack, instance: Instance, in_cont_index: u31, out_cont_index: u31) -> Throwable {
		var in_cont = ContDecl.!(instance.heaptypes[in_cont_index]);
		var out_cont = ContDecl.!(instance.heaptypes[out_cont_index]);
		var n_binds = in_cont.sig.params.length - out_cont.sig.params.length;

		var cont_ref = stack.popV(ValueType.Ref(true, HeapType.Cont(in_cont)));
		var vals = stack.popN(in_cont.sig.params[0 ... n_binds]);

		var cont = Continuation.!(Value.Ref.!(cont_ref).val);
		if (Continuations.isNull(cont)) return stack.trap(TrapReason.NULL_DEREF);
		if (Continuations.isUsed(cont)) return stack.trap(TrapReason.USED_CONTINUATION);
		var new_cont = Continuations.makeContinuation(cont.stack);
		Continuations.setUsed(cont);

		new_cont.stack.bind(vals);
		stack.push(Value.Ref(new_cont));
		return null;
	}
	// Finds a handler for {tag} by unwinding the stack-switching chain and return
	// a freshly created continuation with {Continuation.bottom} pointing to the
	// direct child of the handler stack.
	def unwindStackChain(stack: WasmStack, instance: Instance, tag: u31, get_handler: (WasmStack, Tag) -> ExHandler) -> Continuation {
		var prev = stack; // stack == <top of stack chain>
		while (prev.parent != null) {
			var parent = prev.parent;
			var handler = get_handler(parent, instance.tags[tag]);
			if (handler.handler_pc >= 0) {
				stack.cont_bottom = prev;
				return Continuations.makeContinuation(stack);
			}
			prev = parent;
		}
		return Continuations.NULL;
	}
	def matchRtt(obj: Object, rtt: HeapTypeDecl) -> bool {
		match (obj) {
			x: HeapObject => return ValueTypes.isAssignableHeap(x.decl, rtt);
			x: WasmFunction => return ValueTypes.isAssignableHeap(x.sig, rtt);
		}
		return false;
	}
	def cast(instance: Instance, nullable: bool, ht_val: int, val: Value) -> bool {
		match (val) {
			Ref(obj) => {
				match (obj) {
					null => return nullable;
					_ => return castObject(instance, ht_val, obj);
				}
			}
			I31(val) => {
				match (ht_val) {
					BpHeapTypeCode.EXTERN.val,
					BpHeapTypeCode.ANY.val,
					BpHeapTypeCode.EQ.val,
					BpHeapTypeCode.I31.val => return true;
					_ => return false;
				}
			}
			_ => return false;
		}
	}
	def castObject(instance: Instance, ht_val: int, obj: Object) -> bool {
		match (ht_val) {
			BpHeapTypeCode.FUNC.val => return Function.?(obj);
			BpHeapTypeCode.EXTERN.val => return Object.?(obj);
			BpHeapTypeCode.ARRAY.val => return HeapArrayGeneric.?(obj);
			BpHeapTypeCode.STRUCT.val => return HeapStructGeneric.?(obj);
			BpHeapTypeCode.ANY.val => return Object.?(obj);
			BpHeapTypeCode.EQ.val => return HeapObject.?(obj);
			BpHeapTypeCode.I31.val,		// fallthru
			BpHeapTypeCode.NOCONT.val, 	// fallthru
			BpHeapTypeCode.NOFUNC.val,	// fallthru
			BpHeapTypeCode.NOEXTERN.val, 	// fallthru
			BpHeapTypeCode.NONE.val => return false;
			_ => {
				var index = u32.!(ht_val); // XXX: make this a runtime error?
				var rtt = instance.heaptypes[index];
				return matchRtt(obj, rtt);
			}
		}
	}
	def copyElemsInto(dest: Array<Value>, instance: Instance, dst_offset: u64, elem: ElemDecl, src_offset: u64, size: u64) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) {
			FuncRefs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, instance.getFunctionAsVal);
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, instance.evalInitExpr);
			}
		}
	}
	def evalInitExprU32(instance: Instance, i: InitExpr) -> u32 {
		var v = instance.evalInitExpr(i);
		return Value.I32.!(v).val;
	}
	def copyElemsIntoI32(dest: Array<u32>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, evalInitExprU32(instance, _));
			}
		}
	}
	def store4(bytes: Array<byte>, index: u64, val: u32) {
		Ref<Layout_u32>.at(bytes, int.!(index)).val = val;
	}
	def copyElemsIntoI32bytes(dest: Array<byte>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyFbytes(dest, dst_offset, vals, src_offset, size, evalInitExprU32(instance, _), store4(_, _, _), 4);
			}
		}
	}
	def evalInitExprU31(instance: Instance, i: InitExpr) -> u31 {
		var v = instance.evalInitExpr(i);
		return Value.I31.!(v).val;
	}
	def copyElemsIntoI31(dest: Array<u31>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, evalInitExprU31(instance, _));
			}
		}
	}
	def evalInitExprU64(instance: Instance, i: InitExpr) -> u64 {
		var v = instance.evalInitExpr(i);
		return Value.I64.!(v).val;
	}
	def copyElemsIntoI64(dest: Array<u64>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) {
			FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, evalInitExprU64(instance, _));
			}
		}
	}
	def store8(bytes: Array<byte>, index: u64, val: u64) {
		Ref<Layout_u64>.at(bytes, int.!(index)).val = val;
	}
	def copyElemsIntoI64bytes(dest: Array<byte>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyFbytes(dest, dst_offset, vals, src_offset, size, evalInitExprU64(instance, _), store8(_, _, _), 8);
			}
		}
	}
	def evalInitExprV128(instance: Instance, i: InitExpr) -> (u64, u64) {
		var v = instance.evalInitExpr(i);
		var val = Value.V128.!(v);
		return (val.low, val.high);
	}
	def store16(bytes: Array<byte>, index: u64, pair: (u64, u64)) {
		var r = Ref<Layout_u128>.at(bytes, int.!(index));
		r.lo_val = pair.0;
		r.hi_val = pair.1;
	}
	def copyElemsIntoV128bytes(dest: Array<byte>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyFbytes(dest, dst_offset, vals, src_offset, size, evalInitExprV128(instance, _), store16(_, _, _), 16);
			}
		}
	}
	def evalInitExprU8(instance: Instance, i: InitExpr) -> u8 {
		var v = instance.evalInitExpr(i);
		return u8.view(Value.I32.!(v).val);
	}
	def copyElemsIntoI8(dest: Array<byte>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) {
			FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, evalInitExprU8(instance, _));
			}
		}
	}
	def evalInitExprU16(instance: Instance, i: InitExpr) -> u16 {
		var v = instance.evalInitExpr(i);
		return u16.view(Value.I32.!(v).val);
	}
	def copyElemsIntoI16(dest: Array<u16>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) {
			FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, evalInitExprU16(instance, _));
			}
		}
	}
	def store2(bytes: Array<byte>, index: u64, val: u16) {
		Ref<Layout_u16>.at(bytes, int.!(index)).val = val;
	}
	def copyElemsIntoI16bytes(dest: Array<byte>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyFbytes(dest, dst_offset, vals, src_offset, size, evalInitExprU16(instance, _), store2(_, _, _), 2);
			}
		}
	}
	def evalInitExprObject(instance: Instance, i: InitExpr) -> Object {
		var v = instance.evalInitExpr(i);
		match (v) {
			Ref(obj) => return obj;
			I31(val) => return ObjectI31.new(val);
			_ => return null;
		}
	}
	def copyElemsIntoObject(dest: Array<Object>, instance: Instance, dst_offset: u32, elem: ElemDecl, src_offset: u32, size: u32) -> bool {
		if (elem == null) {
			if (ArrayUtil.boundsCheck(dest, dst_offset, size) < 0) return false;
			if (ArrayUtil.boundsCheck<byte>(null, src_offset, size) < 0) return false;
			return true;
		}
		match (elem.details) { FuncRefs(vals) => {
				return false;
			}
			Exprs(vals) => {
				return ArrayUtil.safeCopyF(dest, dst_offset, vals, src_offset, size, evalInitExprObject(instance, _));
			}
		}
	}
}
class ExtendedDataReader extends DataReader {
	new(data: Range<byte>) super(data) { }
	def read_u8() => read1();
	def read_u16() -> u16 {
		var range = acquire(2);
		if (range.length != 2) return 0;
		at(pos + 2);
		return DataReaders.read_range_u16(range);
	}
}
def bytesToVals(storage: StorageType, data: Array<byte>, offset: u32, length: u32) -> (bool, Array<Value>) { // TODO: MaybeTrap
	var vals = Array<Value>.new(int.!(length));
	var size = sizeOfStorage(storage);
	var nbytes = length * size;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var d = ExtendedDataReader.new(data).reset(data, start, start + int.!(nbytes));
	match (storage.pack) {
		UNPACKED => {
			match (storage.valtype) {
				I32 => for (i < vals.length) vals[i] = Value.I32(d.read_u32());
				I64 => for (i < vals.length) vals[i] = Value.I64(d.read_u64());
				F32 => for (i < vals.length) vals[i] = Value.F32(d.read_u32());
				F64 => for (i < vals.length) vals[i] = Value.F64(d.read_u64());
				V128 => for (i < vals.length) vals[i] = Value.V128(d.read_u64(), d.read_u64());
				_ => ;
			}
		}
		PACKED_I8 => for (i < vals.length) vals[i] = Value.I32(d.read_u8());
		PACKED_I16 => for (i < vals.length) vals[i] = Value.I32(d.read_u16());
	}
	return (d.ok, vals);
}
def bytesToBytes(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<byte>) {
	var start = ArrayUtil.boundsCheck(data, offset, length);
	if (start < 0) return (false, null);
	var limit = length + offset;
	var bytes = DataReader.new(data).reset(data, start, int.!(limit)).readN(int.!(length));
	return (true, bytes);
}
def bytesToI8s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u8>) {
	var vals = Array<u8>.new(int.!(length));
	var start = ArrayUtil.boundsCheck(data, offset, length);
	if (start < 0) return (false, null);
	var limit = length + offset;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u8();
	return (d.ok, vals);
}
def bytesToI8sAsI32s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u32>) {
	var vals = Array<u32>.new(int.!(length));
	var start = ArrayUtil.boundsCheck(data, offset, length);
	if (start < 0) return (false, null);
	var limit = length + offset;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = u32.view(d.read_u8());
	return (d.ok, vals);
}
def bytesToI16s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u16>) {
	var vals = Array<u16>.new(int.!(length));
	var nbytes = length << 1;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var limit = offset + nbytes;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u16();
	return (d.ok, vals);
}
def bytesToI16sAsI32s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u32>) {
	var vals = Array<u32>.new(int.!(length));
	var nbytes = length << 1;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var limit = offset + nbytes;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = u32.view(d.read_u16());
	return (d.ok, vals);
}
def bytesToI32s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u32>) {
	var vals = Array<u32>.new(int.!(length));
	var nbytes = length << 2;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var limit = offset + nbytes;
	var d = DataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u32();
	return (d.ok, vals);
}
def bytesToI64s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u64>) {
	var vals = Array<u64>.new(int.!(length));
	var nbytes = length << 3;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var limit = offset + nbytes;
	var d = DataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u64();
	return (d.ok, vals);
}
def sizeOfStorage(storage: StorageType) -> u32 {
	match (storage.pack) {
		UNPACKED => {
			match (storage.valtype) {
				I32, F32 => return 4;
				I64, F64 => return 8;
				V128 => return 16;
				_ => return 8;
			}
		}
		PACKED_I8 => return 1;
		PACKED_I16 => return 2;
	}
}
layout Layout_i31 {
	+0	val: i31;
	=4;
}
layout Layout_u31 {
	+0	val: u31;
	=4;
}
