// Paired array representation: an Array<Object> holds all the reference fields,
// and an Array<byte> holds all the primitive values
class HeapStructPair extends HeapStructGeneric {
	def objs: Array<Object>;
	def bytes: Array<byte>;
	new(decl: StructDecl, objs, bytes) super(decl) { }

	def getFieldValue(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		match (decl.field_shifts[index]) {
			-1 => {
				return Value.Ref(objs[decl.field_offsets[index]]);
			}
			0 => {
				var v = bytes[decl.field_offsets[index]];
				return Value.I32(u32.view(v));
			}
			1 => {
				var v = Ref<Layout_u16>.at(bytes, decl.field_offsets[index]).val;
				return Value.I32(u32.view(v));
			}
			2 => {
				var v = Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val;
				return if(decl.field_types[index].valtype == ValueType.I32, Value.I32(v), Value.F32(v));
			}
			3 => {
				var v = Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val;
				return if(decl.field_types[index].valtype == ValueType.I64, Value.I64(v), Value.F64(v));
			}
			4 => {
				var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
				return Value.V128(r.lo_val, r.hi_val);
			}
		}
		return Value.I32(u32.view(-1));
	}
	def getFieldSignExtend8Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_i8>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(i32.!(v)));
	}
	def getFieldSignExtend16Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_i16>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(i32.!(v)));
	}
	def getFieldZeroExtend8Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_u8>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(v));
	}
	def getFieldZeroExtend16Value(index: u31) -> Value {
		var decl = StructDecl.!(this.decl);
		var v = Ref<Layout_u16>.at(bytes, decl.field_offsets[index]).val;
		return Value.I32(u32.view(v));
	 }
	def getFieldI32(index: u32) -> i32 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.I32)) { return -1; }
		var v = Ref<Layout_i32>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldI64(index: u32) -> i64 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.I64)) { return -1; }
		var v = Ref<Layout_i64>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldI8(index: u32) -> i8 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && ft.pack != Packedness.PACKED_I8) { return -1; }
		var v = Ref<Layout_i8>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldI16(index: u32) -> i16 {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && ft.pack != Packedness.PACKED_I16) { return -1; }
		var v = Ref<Layout_i16>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldF32(index: u32) -> float {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.F32)) { return -1f; }
		var v = Ref<Layout_float>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldF64(index: u32) -> double {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.F64)) { return -1d; }
		var v = Ref<Layout_double>.at(bytes, decl.field_offsets[index]).val;
		return v;
	}
	def getFieldRef(index: u32) -> Object {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && ValueType.Ref.?(ft.valtype)) { return null; }
		return objs[decl.field_offsets[index]];
	}
	def getFieldV128(index: u32) -> (u64, u64) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (!Values.NO_CHECKS && (ft.pack != Packedness.UNPACKED || ft.valtype != ValueType.V128)) { return (u64.view(-1), u64.view(-1)); }
		var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
		return (r.lo_val, r.hi_val);
	}
	def setFieldValue(index: u31, val: Value) {
		var decl = StructDecl.!(this.decl);
		match (decl.field_shifts[index]) {
			-1 => {
				objs[decl.field_offsets[index]] = Value.Ref.!(val).val;
			}
			0 => {
				bytes[decl.field_offsets[index]] = u8.view(Value.I32.!(val).val);
			}
			1 => {
				Ref<Layout_u16>.at(bytes, decl.field_offsets[index]).val = u16.view(Value.I32.!(val).val);
			}
			2 => {
				if (Value.I32.?(val)) {
					Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val = Value.I32.!(val).val;
				} else {
					Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val = Value.F32.!(val).bits;
				}
			}
			3 => {
				if (Value.I64.?(val)) {
					Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val = Value.I64.!(val).val;
				} else {
					Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val = Value.F64.!(val).bits;
				}
			}
			4 => {
				var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
				var pair = Value.V128.!(val);
				r.lo_val = pair.low;
				r.hi_val = pair.high;
			}
		}
	}
	def setFieldI32(index: u32, val: i32) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.I32)) {
			Ref<Layout_u32>.at(bytes, decl.field_offsets[index]).val = u32.view(val);
		}
	}
	def setFieldI64(index: u32, val: i64) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.I64)) {
			Ref<Layout_u64>.at(bytes, decl.field_offsets[index]).val = u64.view(val);
		}
	}
	def setFieldI8(index: u32, val: i8) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || ft.pack == Packedness.PACKED_I8) {
			bytes[decl.field_offsets[index]] = u8.view(val);
		}
	}
	def setFieldI16(index: u32, val: i16) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || ft.pack == Packedness.PACKED_I16) {
			Ref<Layout_i16>.at(bytes, decl.field_offsets[index]).val = val;
		}
	}
	def setFieldF32(index: u32, val: float) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.F32)) {
			Ref<Layout_float>.at(bytes, decl.field_offsets[index]).val = val;
		}
	 }
	def setFieldF64(index: u32, val: double) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.F64)) {
			Ref<Layout_double>.at(bytes, decl.field_offsets[index]).val = val;
		}
	}
	def setFieldRef(index: u32, val: Object) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || ValueType.Ref.?(ft.valtype)) {
			objs[decl.field_offsets[index]] = val;
		}
	}
	def setFieldV128(index: u32, low: u64, high: u64) {
		var decl = StructDecl.!(this.decl);
		var ft = decl.field_types[index];
		if (Values.NO_CHECKS || (ft.pack == Packedness.UNPACKED && ft.valtype == ValueType.V128)) {
			var r = Ref<Layout_u128>.at(bytes, decl.field_offsets[index]);
			r.lo_val = low;
			r.hi_val = high;
		}
	}
}

// Implementations of arrays of specific types
class HeapArrayI32 extends HeapArrayGeneric {
	def vals: Array<u32>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u32.view(Value.I32.!(val).val);
	}
	def getI32(index: u32) -> i32 {
		return i32.view(vals[index]);
	}
	def setI32(index: u32, val: i32) {
		vals[index] = u32.view(val);
	}
}

class HeapArrayI31 extends HeapArrayGeneric {
	def vals: Array<u31>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I31(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u31.view(Value.I31.!(val).val);
	}
	def getI31(index: u32) -> i31 {
		return i31.view(vals[index]);
	}
	def setI31(index: u32, val: i31) {
		vals[index] = u31.view(val);
	}
}

class HeapArrayI64 extends HeapArrayGeneric {
	def vals: Array<u64>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I64(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u64.view(Value.I64.!(val).val);
	}
	def getI64(index: u32) -> i64 {
		return i64.view(vals[index]);
	}
	def setI64(index: u32, val: i64) {
		vals[index] = u64.view(val);
	}
}

class HeapArrayI8 extends HeapArrayGeneric {
	def vals: Array<u8>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u8.view(Value.I32.!(val).val);
	}
	def getI8(index: u32) -> i8 {
		return i8.view(vals[index]);
	}
	def setI8(index: u32, val: i8) {
		vals[index] = u8.view(val);
	}
}

class HeapArrayI16 extends HeapArrayGeneric {
	def vals: Array<u16>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.I32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u16.view(Value.I32.!(val).val);
	}
	def getI16(index: u32) -> i16 {
		return i16.view(vals[index]);
	}
	def setI16(index: u32, val: i16) {
		vals[index] = u16.view(val);
	}
}

class HeapArrayF32 extends HeapArrayGeneric {
	def vals: Array<u32>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.F32(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u32.view(Value.F32.!(val).bits);
	}
	def getF32(index: u32) -> float {
		return if(index >= 0 && index < vals.length, float.view(vals[index]), -1);
	}
	def setF32(index: u32, val: float) {
		if (index >= 0 && index < vals.length) {
			vals[index] = u32.view(val);
		}
	}
}

class HeapArrayF64 extends HeapArrayGeneric {
	def vals: Array<u64>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		return Value.F64(vals[index]);
	}
	def setValue(index: u32, val: Value) {
		vals[index] = u64.view(Value.F64.!(val).bits);
	}
	def getF64(index: u32) -> double {
		return double.view(vals[index]);
	}
	def setF64(index: u32, val: double) {
		vals[index] = u64.view(val);
	}
}

class HeapArrayRef extends HeapArrayGeneric {
	def vals: Array<Object>;
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length; }

	def getValue(index: u32) -> Value {
		match (vals[index]) {
			x: ObjectI31 => return Value.I31(x.val);
			x: Object => return Value.Ref(x);
			_ => return Values.REF_NULL;
		}
	}
	def setValue(index: u32, val: Value) {
		var obj: Object;
		match (val) {
			Ref(v) => obj = v;
			I31(v) => obj = ObjectI31.new(v);
			_ => ;
		}
		vals[index] = obj;
	}
	def getRef(index: u32) -> Object {
		return vals[index];
	}
	def setRef(index: u32, val: Object) {
		vals[index] = val;
	}
}

// A v128 uses two adjacent u64 entries in the vals array
class HeapArrayV128 extends HeapArrayGeneric {
	def vals: Array<u64>; // The array format: [low 0, high 0, low 1, high 1, ...]
	new(decl: ArrayDecl, vals) super(decl) { }

	def length() -> int { return vals.length >> 1; }

	def getValue(index: u32) -> Value {
		var idx = index << 1;
		return Value.V128(vals[idx], vals[idx+1]);
	}
	def setValue(index: u32, val: Value) {
		var idx = index << 1;
		var v128 = Value.V128.!(val);
		vals[idx] = u64.view(v128.low);
		vals[idx+1] = u64.view(v128.high);
	}
	def getV128(index: u32) -> (u64, u64) {
		var idx = index << 1;
		return (vals[idx], vals[idx+1]);
	}
	def setV128(index: u32, low: u64, high: u64) {
		var idx = index << 1;
		vals[idx] = low;
		vals[idx+1] = high;
	}
}

component ObjectRuntime {
	def STRUCT_NEW(stack: ExecStack, decl: StructDecl) -> HeapStructGeneric {
		var bytes = if(decl.num_bytes == 0, null, Array<byte>.new(decl.num_bytes));
		var objs = if(decl.num_refs == 0, null, Array<Object>.new(decl.num_refs));
		var obj: HeapStructGeneric = HeapStructPair.new(decl, objs, bytes);
		for (i = decl.field_types.length - 1; i >= 0; i--) {
			var index = u31.!(i);
			match (decl.field_shifts[i]) {
				0 => {
					var val = stack.popi();
					obj.setFieldI8(index, i8.view(val));
				}
				1 => {
					var val = stack.popi();
					obj.setFieldI16(index, i16.view(val));
				}
				2 => {
					if (decl.field_types[i].valtype == ValueType.I32) {
						var val = stack.popi();
						obj.setFieldI32(index, val);
					} else {
						var val = stack.popf();
						obj.setFieldF32(index, val);
					}
				}
				3 => {
					if (decl.field_types[i].valtype == ValueType.I64) {
						var val = stack.popl();
						obj.setFieldI64(index,  val);
					} else {
						var val = stack.popd();
						obj.setFieldF64(index, val);
					}
				}
				4 => {
					var pair = stack.pops();
					obj.setFieldV128(index, pair.0, pair.1);
				}
				-1 => {
					var o = stack.popObject();
					obj.setFieldRef(index, o);
				}
			}
		}
		return obj;
	}
	def STRUCT_NEW_DEFAULT(decl: StructDecl) -> HeapStructGeneric {
		var bytes = if(decl.num_bytes == 0, null, Array<byte>.new(decl.num_bytes));
		var objs = if(decl.num_refs == 0, null, Array<Object>.new(decl.num_refs));
		var obj: HeapStructGeneric = HeapStructPair.new(decl, objs, bytes);
		for (i < decl.field_types.length) {
			var index = u31.view(i);
			match (decl.field_shifts[i]) {
				0 => {
					obj.setFieldI8(index, 0);
				}
				1 => {
					obj.setFieldI16(index, 0);
				}
				2 => {
					if (decl.field_types[i].valtype == ValueType.I32) {
						obj.setFieldI32(index, 0);
					} else {
						obj.setFieldF32(index, 0.0f);
					}
				}
				3 => {
					if (decl.field_types[i].valtype == ValueType.I64) {
						obj.setFieldI64(index, 0);
					} else {
						obj.setFieldF64(index, 0.0d);
					}
				}
				4 => {
					obj.setFieldV128(index, 0, 0);
				}
				-1 => {
					obj.setFieldRef(index, null);
				}
			}
		}
		return obj;
	}
	def ARRAY_NEW(stack: ExecStack, decl: ArrayDecl, length: u32) -> Throwable {
		match (decl.elem_types[0].pack) {
			UNPACKED => {
				match (decl.elem_types[0].valtype) {
					I32 => {
						var vals = Array<u32>.new(u31.!(length));
						var elem = stack.popu();
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayI32.new(decl, vals)));
					}
					I64 => {
						var vals = Array<u64>.new(u31.!(length));
						var elem = stack.popw();
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayI64.new(decl, vals)));
					}
					F32 => {
						var vals = Array<u32>.new(u31.!(length));
						var elem = u32.view(stack.popf());
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayF32.new(decl, vals)));
					}
					F64 => {
						var vals = Array<u64>.new(u31.!(length));
						var elem = u64.view(stack.popd());
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayF64.new(decl, vals)));
					}
					Ref(nullable, heaptype) => {
						if (heaptype == HeapType.I31 && !nullable) {
							var vals = Array<u31>.new(u31.!(length));
							var elem = stack.popV(ValueType.Ref(false, HeapType.I31));
							var val = ObjectI31.!(Value.Ref.!(elem).val).val;
							for (i < vals.length) vals[i] = val;
							stack.push(Value.Ref(HeapArrayI31.new(decl, vals)));
						} else {
							var vals = Array<Object>.new(u31.!(length));
							var elem = stack.popObject();
							for (i < vals.length) vals[i] = elem;
							stack.push(Value.Ref(HeapArrayRef.new(decl, vals)));
						}
					}
					V128 => {
						var vals = Array<u64>.new(u31.!(length << 1));
						var v128 = stack.pops();
						var low = v128.0;
						var high = v128.1;
						for (i = 0; i < vals.length; i += 2) {
							vals[i] = low;
							vals[i+1] = high;
						}
						stack.push(Value.Ref(HeapArrayV128.new(decl, vals)));
					}
					_ => {
						var vals = Array<Value>.new(u31.!(length));
						var elem = stack.popV(decl.elem_types[0].valtype);
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
					}
				}
			}
			PACKED_I8 => {
				var vals = Array<u8>.new(u31.!(length));
				var elem = u8.view(stack.popu());
				for (i < vals.length) vals[i] = elem;
				stack.push(Value.Ref(HeapArrayI8.new(decl, vals)));
			}
			PACKED_I16 => {
				var vals = Array<u16>.new(u31.!(length));
				var elem = u16.view(stack.popu());
				for (i < vals.length) vals[i] = elem;
				stack.push(Value.Ref(HeapArrayI16.new(decl, vals)));
			}
		}
		return null;
	}
	def ARRAY_NEW_DEFAULT(stack: ExecStack, decl: ArrayDecl, length: u32) -> Throwable {
		match (decl.elem_types[0].pack) {
			UNPACKED => {
				match (decl.elem_types[0].valtype) {
					I32 => {
						var vals = Array<u32>.new(u31.!(length));
						// for (i < vals.length) vals[i] = 0u32;
						stack.push(Value.Ref(HeapArrayI32.new(decl, vals)));
					}
					I64 => {
						var vals = Array<u64>.new(u31.!(length));
						// for (i < vals.length) vals[i] = 0u64;
						stack.push(Value.Ref(HeapArrayI64.new(decl, vals)));
					}
					F32 => {
						var vals = Array<u32>.new(u31.!(length));
						// for (i < vals.length) vals[i] = u32.view(0.0f);
						stack.push(Value.Ref(HeapArrayF32.new(decl, vals)));
					}
					F64 => {
						var vals = Array<u64>.new(u31.!(length));
						// for (i < vals.length) vals[i] = u64.view(0.0d);
						stack.push(Value.Ref(HeapArrayF64.new(decl, vals)));
					}
					Ref(nullable, heaptype) => {
						if (heaptype == HeapType.I31 && !nullable) {
							var vals = Array<u31>.new(u31.!(length));
							// for (i < vals.length) vals[i] = null;
							stack.push(Value.Ref(HeapArrayI31.new(decl, vals)));
						} else {
							var vals = Array<Object>.new(u31.!(length));
							// for (i < vals.length) vals[i] = null;
							stack.push(Value.Ref(HeapArrayRef.new(decl, vals)));
						}
					}
					V128 => {
						var vals = Array<u64>.new(u31.!(length << 1));
						// for (i < vals.length) vals[i] = 0u64;
						stack.push(Value.Ref(HeapArrayV128.new(decl, vals)));
					}
					_ => {
						var vals = Array<Value>.new(u31.!(length));
						var elem = Values.default(decl.elem_types[0].valtype);
						for (i < vals.length) vals[i] = elem;
						stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
					}
				}
			}
			PACKED_I8 => {
				var vals = Array<u8>.new(u31.!(length));
				// for (i < vals.length) vals[i] = 0u8;
				stack.push(Value.Ref(HeapArrayI8.new(decl, vals)));
			}
			PACKED_I16 => {
				var vals = Array<u16>.new(u31.!(length));
				// for (i < vals.length) vals[i] = 0u16;
				stack.push(Value.Ref(HeapArrayI16.new(decl, vals)));
			}
		}
		return null;
	}
	def ARRAY_NEW_FIXED(stack: ExecStack, decl: ArrayDecl, length: u32) -> Throwable {
		match (decl.elem_types[0].pack) {
			UNPACKED => {
				match (decl.elem_types[0].valtype) {
					I32 => {
						var vals = Array<u32>.new(u31.!(length));
						for (i = vals.length - 1; i >= 0; i--) vals[i] = u32.view(stack.popu());
						stack.push(Value.Ref(HeapArrayI32.new(decl, vals)));
					}
					I64 => {
						var vals = Array<u64>.new(u31.!(length));
						for (i = vals.length - 1; i >= 0; i--) vals[i] = u64.view(stack.popw());
						stack.push(Value.Ref(HeapArrayI64.new(decl, vals)));
					}
					F32 => {
						var vals = Array<u32>.new(u31.!(length));
						for (i = vals.length - 1; i >= 0; i--) vals[i] = u32.view(stack.popf());
						stack.push(Value.Ref(HeapArrayF32.new(decl, vals)));
					}
					F64 => {
						var vals = Array<u64>.new(u31.!(length));
						for (i = vals.length - 1; i >= 0; i--) vals[i] = u64.view(stack.popd());
						stack.push(Value.Ref(HeapArrayF64.new(decl, vals)));
					}
					Ref(nullable, heaptype) => {
						if (heaptype == HeapType.I31 && !nullable) {
							var vals = Array<u31>.new(u31.!(length));
							for (i = vals.length - 1; i >= 0; i--) vals[i] = ObjectI31.!(stack.popObject()).val;
							stack.push(Value.Ref(HeapArrayI31.new(decl, vals)));

						} else {
							var vals = Array<Object>.new(u31.!(length));
							for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popObject();
							stack.push(Value.Ref(HeapArrayRef.new(decl, vals)));
						}
					}
					V128 => {
						var vals = Array<u64>.new(u31.!(length << 1));
						for (i = vals.length - 2; i >= 0; i -= 2) {
							var v128 = stack.pops();
							vals[i] = v128.0;
							vals[i+1] = v128.1;
						}
						stack.push(Value.Ref(HeapArrayV128.new(decl, vals)));
					}
					_ => {
						var vals = Array<Value>.new(u31.!(length));
						var t = decl.elem_types[0].valtype;
						for (i = vals.length - 1; i >= 0; i--) vals[i] = stack.popV(t);
						stack.push(Value.Ref(HeapArrayValue.new(decl, vals)));
					}
				}
			}
			PACKED_I8 => {
				var vals = Array<u8>.new(u31.!(length));
				for (i = vals.length - 1; i >= 0; i--) vals[i] = u8.view(stack.popu());
				stack.push(Value.Ref(HeapArrayI8.new(decl, vals)));
			}
			PACKED_I16 => {
				var vals = Array<u16>.new(u31.!(length));
				for (i = vals.length - 1; i >= 0; i--) vals[i] = u16.view(stack.popu());
				stack.push(Value.Ref(HeapArrayI16.new(decl, vals)));
			}
		}
		return null;
	}
	def ARRAY_NEW_DATA(stack: ExecStack, instance: Instance, rtt: ArrayDecl, ddecl: DataDecl, offset: u32, length: u32, data_index: u31) -> Throwable {
		match (rtt.elem_types[0].pack) {
			UNPACKED => {
				match (rtt.elem_types[0].valtype) {
					I32 => {
						var r = Runtime.getData<u32>(instance, data_index, offset, length, DataReader.read_u32);
						if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayI32.new(rtt, r.1)));
					}
					I64 => {
						var r = Runtime.getData<u64>(instance, data_index, offset, length, DataReader.read_u64);
						if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayI64.new(rtt, r.1)));
					}
					F32 => {
						var r = Runtime.getData<u32>(instance, data_index, offset, length, DataReader.read_u32);
						if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayF32.new(rtt, r.1)));
					}
					F64 => {
						var r = Runtime.getData<u64>(instance, data_index, offset, length, DataReader.read_u64);
						if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayF64.new(rtt, r.1)));
					}
					V128 => {
						var r = Runtime.getData<u64>(instance, data_index, offset, length << 1, DataReader.read_u64);
						if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
						stack.push(Value.Ref(HeapArrayV128.new(rtt, r.1)));
					}
					_ => {
						return stack.trap(TrapReason.ERROR);
					}
				}
			}
			PACKED_I8 => {
				var r = Runtime.getData<u8>(instance, data_index, offset, length, DataReader.read1);
				if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
				stack.push(Value.Ref(HeapArrayI8.new(rtt, r.1)));
			}
			PACKED_I16 => {
				var r = Runtime.getData<u16>(instance, data_index, offset, length, fun (d: DataReader) => DataReaders.read_range_u16(d.acquire(2)));
				if (!r.0) return stack.trap(TrapReason.MEMORY_OOB);
				stack.push(Value.Ref(HeapArrayI16.new(rtt, r.1)));
			}
		}
		return null;
	}
	def ARRAY_NEW_ELEM(stack: ExecStack, instance: Instance, rtt: ArrayDecl, edecl: ElemDecl, offset: u32, length: u32) -> Throwable {
		match (rtt.elem_types[0].pack) {
			UNPACKED => {
				match (rtt.elem_types[0].valtype) {
					Ref(nullable, heaptype) => {
						var r = Runtime.getElems(instance, edecl, offset, length);
						if (!r.0) return stack.trap(TrapReason.TABLE_OOB);
						stack.push(Value.Ref(HeapArrayRef.new(rtt, r.1)));
					}
					_ => return stack.trap(TrapReason.ERROR);
				}
			}
			_ => return stack.trap(TrapReason.ERROR);
		}
		return null;
	}
	def ARRAY_FILL(obj: HeapArrayGeneric, rtt: ArrayDecl, index: int, size: u32, val: Value) -> Throwable {
		match (obj) {
			x: HeapArrayValue => {
				var r = x.vals[index ..+ size];
				for (i < r.length) r[i] = val;
			}
			x: HeapArrayI32 => {
				var r = x.vals[index ..+ size];
				var v = Value.I32.!(val).val;
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayI31 => {
				var r = x.vals[index ..+ size];
				var v = Value.I31.!(val).val;
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayI64 => {
				var r = x.vals[index ..+ size];
				var v = Value.I64.!(val).val;
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayI8 => {
				var r = x.vals[index ..+ size];
				var v = u8.view(Value.I32.!(val).val);
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayI16 => {
				var r = x.vals[index ..+ size];
				var v = u16.view(Value.I32.!(val).val);
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayF32 => {
				var r = x.vals[index ..+ size];
				var v = Value.F32.!(val).bits;
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayF64 => {
				var r = x.vals[index ..+ size];
				var v = Value.F64.!(val).bits;
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayRef => {
				var r = x.vals[index ..+ size];
				var v = Value.Ref.!(val).val;
				for (i < r.length) r[i] = v;
			}
			x: HeapArrayV128 => {
				var r = x.vals[index ..+ (size << 1)];
				var v128 = Value.V128.!(val);
				for (i=0; i < r.length; i+=2) {
					r[i] = v128.low;
					r[i+1] = v128.high;
				}
			}
		}
		return null;
	}
	def ARRAY_COPY(stack: ExecStack, src: HeapArrayGeneric, dst: HeapArrayGeneric, src_offset: u32, dst_offset: u32, size: u32) -> Throwable {
		if (HeapArrayValue.?(src) && HeapArrayValue.?(dst)) {
			var r = ArrayUtil.safeCopy(dst.getArray<Value>(), dst_offset, src.getArray<Value>(), src_offset, size);
			if (!r) return stack.trap(TrapReason.ARRAY_OOB);
			return null;
		}

		if (HeapArrayValue.?(dst)) {
			var arr = HeapArrayValue.!(dst);
			var r = ArrayUtil.safeCopyDiffTypes(arr.vals, dst_offset, u31.view(src.length()), src_offset, size, src.getValue);
			if (!r) return stack.trap(TrapReason.ARRAY_OOB);
			return null;
		}

		if (HeapArrayValue.?(src)){
			var arr = HeapArrayValue.!(src);
			match (dst) {
				x: HeapArrayI32 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU32);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayI31 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, fun (x: u32) => u31.!(arr.getI31(x)));
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayI64 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU64);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayI8 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU8);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayI16 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU16);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayF32 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU32);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayF64 => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getU64);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayRef => {
					var r = ArrayUtil.safeCopyDiffTypes(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getRef);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
				x: HeapArrayV128 => {
					var r = ArrayUtil.safeCopyFromV128(x.vals, dst_offset, u31.view(arr.length()), src_offset, size, arr.getV128);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}

				_ => { return stack.trap(TrapReason.ERROR); }
			}
		}

		match (src) {
			x: HeapArrayI32 => {
				if (HeapArrayI32.?(dst)) {
					var arr = HeapArrayI32.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayI31 => {
				if (HeapArrayI31.?(dst)) {
					var arr = HeapArrayI31.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayI64 => {
				if (HeapArrayI64.?(dst)) {
					var arr = HeapArrayI64.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayI8 => {
				if (HeapArrayI8.?(dst)) {
					var arr = HeapArrayI8.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayI16 => {
				if (HeapArrayI16.?(dst)) {
					var arr = HeapArrayI16.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayF32 => {
				if (HeapArrayF32.?(dst)) {
					var arr = HeapArrayF32.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayF64 => {
				if (HeapArrayF64.?(dst)) {
					var arr = HeapArrayF64.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayRef => {
				if (HeapArrayRef.?(dst)) {
					var arr = HeapArrayRef.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
			x: HeapArrayV128 => {
				if (HeapArrayV128.?(dst)) {
					var arr = HeapArrayV128.!(dst);
					var r = ArrayUtil.safeCopy(x.vals, dst_offset, arr.vals, src_offset, size << 1);
					if (!r) return stack.trap(TrapReason.ARRAY_OOB);
					return null;
				}
			}
		}
		return stack.trap(TrapReason.ERROR);
	}	
	def ARRAY_INIT_DATA(stack: ExecStack, obj: HeapArrayGeneric, rtt: ArrayDecl, data: Array<byte>, src_offset: u32, dst_offset: u32, size: u32) -> Throwable {
		/*match (obj) {
			x: HeapArrayValue => {
				var t = Runtime.bytesToVals(rtt.elem_types[0], data, src_offset, size);
				if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
				ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
				return null;
			}
		}*/
		match (rtt.elem_types[0].pack) {
			UNPACKED => {
				match (rtt.elem_types[0].valtype) {
					I32 => {
						var t = bytesToI32s(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						match (obj) {
							x: HeapArrayI32 => {
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
								return null;
							}
						}
					}
					I64 => {
						var t = bytesToI64s(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						match (obj) {
							x: HeapArrayI64 => {
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
								return null;
							}
						}
					}
					F32 => {
						var t = bytesToI32s(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						match (obj) {
							x: HeapArrayF32 => {
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
								return null;
							}
						}
					}
					F64 => {
						var t = bytesToI64s(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						match (obj) {
							x: HeapArrayF64 => {
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
								return null;
							}
						}
					}
					V128 => {
						var t = bytesToI64s(data, src_offset, size << 1);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						match (obj) {
							x: HeapArrayV128 => {
								ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size << 1);
								return null;
							}
						}
					}
					_ => { }
				}
			}
			PACKED_I8 => {
				match (obj) {
					x: HeapArrayI8 => {
						var t = bytesToI8s(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
						return null;
					}
				}
			}
			PACKED_I16 => {
				match (obj) {
					x: HeapArrayI16 => {
						var t = bytesToI16s(data, src_offset, size);
						if (!t.0) return stack.trap(TrapReason.MEMORY_OOB);
						ArrayUtil.safeCopy(x.vals, dst_offset, t.1, 0, size);
						return null;
					}
				}
			}
		}
		return stack.trap(TrapReason.ERROR);
	}
	def ARRAY_INIT_ELEM(stack: ExecStack, obj: HeapArrayGeneric, instance: Instance, edecl: ElemDecl, src_offset: u32, dst_offset: u32, size: u32) -> Throwable {
		match (obj) {
			x: HeapArrayI31 => {
				var r = Runtime.getElems(instance, edecl, src_offset, size);
				if (!r.0) return stack.trap(TrapReason.ARRAY_OOB);
				if (ArrayUtil.boundsCheck(x.vals, dst_offset, size) < 0) return stack.trap(TrapReason.ARRAY_OOB);
				for (i < r.1.length) {
					x.vals[int.!(dst_offset)+i] = ObjectI31.!(r.1[i]).val;
				}
			}
			x: HeapArrayRef => {
				var r = Runtime.getElems(instance, edecl, src_offset, size);
				if (!r.0) return stack.trap(TrapReason.ARRAY_OOB);
				if (ArrayUtil.boundsCheck(x.vals, dst_offset, size) < 0) return stack.trap(TrapReason.ARRAY_OOB);
				for (i < r.1.length) {
					x.vals[int.!(dst_offset)+i] = r.1[i];
				}
			}
			_ => {return stack.trap(TrapReason.ARRAY_OOB);}
		}
		return null;
	}
}

def bytesToBytes(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<byte>) {
	var start = ArrayUtil.boundsCheck(data, offset, length);
	if (start < 0) return (false, null);
	var limit = length + offset;
	var bytes = DataReader.new(data).reset(data, start, int.!(limit)).readN(int.!(length));
	return (true, bytes);
}
def bytesToI8s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u8>) {
	var start = ArrayUtil.boundsCheck(data, offset, length);
	if (start < 0) return (false, null);
	var vals = Array<u8>.new(int.!(length));
	var limit = length + offset;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u8();
	return (d.ok, if(d.ok, vals));
}
def bytesToI8sAsI32s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u32>) {
	var start = ArrayUtil.boundsCheck(data, offset, length);
	if (start < 0) return (false, null);
	var vals = Array<u32>.new(int.!(length));
	var limit = length + offset;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = u32.view(d.read_u8());
	return (d.ok, if(d.ok, vals));
}
def bytesToI16s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u16>) {
	var nbytes = length << 1;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var vals = Array<u16>.new(int.!(length));
	var limit = offset + nbytes;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u16();
	return (d.ok, if(d.ok, vals));
}
def bytesToI16sAsI32s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u32>) {
	var nbytes = length << 1;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var vals = Array<u32>.new(int.!(length));
	var limit = offset + nbytes;
	var d = ExtendedDataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = u32.view(d.read_u16());
	return (d.ok, if(d.ok, vals));
}
def bytesToI32s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u32>) {
	var nbytes = length << 2;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var vals = Array<u32>.new(int.!(length));
	var limit = offset + nbytes;
	var d = DataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u32();
	return (d.ok, if(d.ok, vals));
}
def bytesToI64s(data: Array<byte>, offset: u32, length: u32) -> (bool, Array<u64>) {
	var nbytes = length << 3;
	var start = ArrayUtil.boundsCheck(data, offset, nbytes);
	if (start < 0) return (false, null);
	var vals = Array<u64>.new(int.!(length));
	var limit = offset + nbytes;
	var d = DataReader.new(data).reset(data, start, int.!(limit));
	for (i < vals.length) vals[i] = d.read_u64();
	return (d.ok, if(d.ok, vals));
}

