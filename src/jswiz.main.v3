// == Global state ===========================================================
def MODULES = HandleTable<Module>.new();
def FUNCTIONS = HandleTable<FuncDecl>.new();
def BUFFERS = HandleTable<Array<byte>>.new();
def engine = Engine.new();

type funcref #unboxed; // TODO

// === Buffer management =====================================================
export def alloc_buffer(len: u32) -> (Pointer, u32) {
	var buffer = Array<byte>.new(int.!(len)); // TODO: OOB index
	var hbuf = BUFFERS.register(buffer);
	return (Pointer.atContents(buffer), len);
}
export def free_buffer(h: Handle<Array<byte>>) {
	BUFFERS.destroy(h);
}

// === Engine configuration ==================================================

// === Module loading ========================================================
export def load_module(ptr: Pointer, len: u32) -> Handle<Module> {
	var data = CiRuntime.forgeRange<byte>(ptr, int.!(len));
	var limits = Limits.new().set(engine.extensions);
	var bp = BinParser.new(engine.extensions, limits, "<input>");
	bp.tiering = Execute.tiering;
	var r = bp.pushr(data).finish();
	match (r) {
		Ok(module) => return MODULES.register(module);
		Error(code, filename, section, error_index, error_pos, error_msg) => {
			return ErrorBuilder.new()
				.render(code, "<input>", section, error_index, error_pos, error_msg)
				.error("BinParseError");
		}
	}
}
export def unload_module(h: Handle<Module>) {
	MODULES.destroy(h);
}
// === Module reflection ======================================================
export def get_module_type_count(hmod: Handle<Module>) -> int { var m = MODULES.get(hmod); return if(m != null, m.heaptypes.length); }
export def get_module_func_count(hmod: Handle<Module>) -> int { var m = MODULES.get(hmod); return if(m != null, m.functions.length); }
export def get_module_memory_count(hmod: Handle<Module>) -> u31;
export def get_module_table_count(hmod: Handle<Module>) -> u31;
export def get_module_export_count(hmod: Handle<Module>) -> u31;

export def get_module_type(hmod: Handle<Module>, index: u32) -> Handle<HeapTypeDecl>;
export def get_module_func(hmod: Handle<Module>, index: u32) -> Handle<FuncDecl>;
export def get_module_memory(hmod: Handle<Module>, index: u32) -> Handle<MemoryDecl>;
export def get_module_table(hmod: Handle<Module>, index: u32) -> Handle<TableDecl>;
//export def get_module_export(hmod: Handle<Module>, index: u32) -> Handle<ExportDecl>;

export def get_instance_type(hinst: Handle<Instance>, index: u32) -> Handle<HeapTypeDecl>;
export def get_instance_func(hinst: Handle<Instance>, index: u32) -> Handle<Function>;
export def get_instance_memory(hinst: Handle<Instance>, index: u32) -> Handle<Memory>;
export def get_instance_table(hinst: Handle<Instance>, index: u32) -> Handle<Table>;
export def get_instance_module(hinst: Handle<Instance>) -> Handle<Module>;

// === Binding ===============================================================
//export def add_func_binding(hmod: Handle<HostModule>, name: String, hfunc: Handle<Function>);
//export def add_memory_binding(hmod: Handle<HostModule>, name: String, hfunc: Handle<Memory>);
//export def add_table_binding(hmod: Handle<HostModule>, name: String, hfunc: Handle<Table>);

// === Instantiation =========================================================
export def new_instance(hmod: Handle<Module>) -> Handle<Instance>;

// === Instrumentation =======================================================
export def new_probe(f: funcref) -> Handle<Probe>;
export def insert_global_probe(hmod: Handle<Module>, hprob: Handle<Probe>);
export def remove_global_probe(hmod: Handle<Module>, hprob: Handle<Probe>);
export def insert_local_probe(hmod: Handle<Module>, func_index: int, pc: int, hprob: Handle<Probe>);
export def remove_local_probe(hmod: Handle<Module>, func_index: int, pc: int, hprob: Handle<Probe>);

// === Execution =============================================================
export def run(h: Handle<Function>, args: Handle<Args>) -> Result {
	var d: Result;
	return d;
}

// === Internals =============================================================
class Args { }
private type Handle<T>(index: u32) #unboxed;

private class HandleTable<T> {
	private var roots: Array<T>;
	private var pos = 1u;

	def register(v: T) -> Handle<T> {
		if (roots == null) roots = Array.new(11);
		else if (pos == roots.length) roots = Arrays.grow(roots, roots.length * 3);
		roots[pos] = v;
		return Handle<T>(pos++);
	}
	def find(v: T) -> Handle<T> {
		// XXX: linear search
		if (roots == null) return Handle<T>(0);
		for (i < pos) if (roots[i] == v) return Handle<T>(i);
		return Handle<T>(0);
	}
	def destroy(h: Handle<T>) {
		if (roots == null || h.index >= pos) return;
		def d: T;
		roots[h.index] = d;
	}
	def get(h: Handle<T>) -> T {
		def d: T;
		if (h.index >= pos) return d;
		return roots[h.index];
	}
}

// Prevent dead code elimination 
export def keepAlive() {
	keepHandle<Module>();
	keepHandle<FuncDecl>();
}
def keepHandle<T>() -> bool {
	return Handle<T>(0).index == Handle<T>(0x8000_0000).index;
}

