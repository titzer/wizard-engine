
python
import gdb
import os
from enum import Enum


class FieldType(Enum):
    LONG = "long"
    INT = "int"


FRAME_FIELDS = {
    "wasm_func":  (0,  FieldType.LONG),
    "mem0_base":  (8,  FieldType.LONG),
    "vfp":        (16, FieldType.LONG),
    "vsp":        (24, FieldType.LONG),
    "sidetable":  (32, FieldType.LONG),
    "stp":        (40, FieldType.LONG),
    "code":       (48, FieldType.LONG),
    "ip":         (56, FieldType.LONG),
    "eip":        (64, FieldType.LONG),
    "func_decl":  (72, FieldType.LONG),
    "instance":   (80, FieldType.LONG),
    "curpc":      (88, FieldType.INT),
    "accessor":   (96, FieldType.LONG),
}


def read_field(addr, offset, field_type):
    """Read a field at addr+offset with the given type."""
    try:
        typ = field_type.value
        val = gdb.Value(addr + offset).cast(gdb.lookup_type(typ).pointer()).dereference()
        return hex(val) if field_type == FieldType.LONG else val
    except gdb.error as e:
        return f"<error: {e}>"


class PrintFrame(gdb.Command):
    """Print the contents of an X86_64InterpreterFrame at the given address."""

    def __init__(self):
        super(PrintFrame, self).__init__("printframe", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            addr = int(gdb.parse_and_eval(arg))
        except Exception as e:
            print(f"Invalid address: {e}")
            return

        for name, (offset, field_type) in FRAME_FIELDS.items():
            val = read_field(addr, offset, field_type)
            print(f"{name:<12} @ +{offset:>2} = {val}")


class VSFrame(gdb.Command):
    """Print the contents of the value stack, based on the given frame address."""

    def __init__(self):
        super(VSFrame, self).__init__("vsframe", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            addr = int(gdb.parse_and_eval(arg))
        except Exception as e:
            print(f"Invalid address: {e}")
            return

        vfp_offset, vfp_type = FRAME_FIELDS["vfp"]
        vsp_offset, vsp_type = FRAME_FIELDS["vsp"]

        try:
            vfp = int(gdb.Value(addr + vfp_offset).cast(gdb.lookup_type(vfp_type.value).pointer()).dereference())
            vsp = int(gdb.Value(addr + vsp_offset).cast(gdb.lookup_type(vsp_type.value).pointer()).dereference())
            n_elems = (vsp - vfp) // 32

            print(f"VFP = {hex(vfp)}, VSP = {hex(vsp)}")

            if n_elems < 0 or n_elems > 10:
                print(f"Invalid number of elements {n_elems}, aborting")
                return

            print(f"Printing {n_elems} stack values\n")
            # Loop from VSP_ADDR to VFP_ADDR in reverse, 32-byte value slot increments
            # TODO: compatibility with untagged mode
            for i in range(vsp - 32, vfp - 32, -32):
                try:
                    tag = gdb.Value(i).cast(gdb.lookup_type("unsigned char").pointer()).dereference()

                    print(f"@ {hex(i)}:")
                    print(f"  Tag:   {hex(tag)}")
                    print(f"  Value: ", end="")

                    val_start = i + 16
                    for offset in range(4):
                        at = val_start + offset * 4
                        val = gdb.Value(at).cast(gdb.lookup_type("unsigned int").pointer()).dereference()
                        print(f"0x{int(val):08x}", end=" ")
                    print()
                except gdb.error as e:
                    print(f"Error reading at {hex(i)}: {e}")
                    break
        except Exception as e:
            print(f"Invalid address: {e}")
            return

PrintFrame()
VSFrame()

end

# Breakpoint for module compilation in --mode=spc.
# break X86_64SpcModuleCode.new

# Breakpoint for general-purpose wasm entrypoint.
break Execute.call

