
python
import gdb
from enum import Enum

import sys
sys.path.insert(0, "gdb")
import gdbgen


class FieldType(Enum):
    LONG = "long"
    INT = "int"
    UINT = "unsigned int"
    UCHAR = "unsigned char"


# Value stack layout constants
VALUE_SLOT_SIZE = 32
TAG_TO_VALUE_OFFSET = 16

FRAME_FIELDS = {
    "wasm_func":  (0,  FieldType.LONG),
    "mem0_base":  (8,  FieldType.LONG),
    "vfp":        (16, FieldType.LONG),
    "vsp":        (24, FieldType.LONG),
    "sidetable":  (32, FieldType.LONG),
    "stp":        (40, FieldType.LONG),
    "code":       (48, FieldType.LONG),
    "ip":         (56, FieldType.LONG),
    "eip":        (64, FieldType.LONG),
    "func_decl":  (72, FieldType.LONG),
    "instance":   (80, FieldType.LONG),
    "curpc":      (88, FieldType.INT),
    "accessor":   (96, FieldType.LONG),
}


def read_mem(addr, field_type):
    """Read a value at addr with the given type."""
    return gdb.Value(addr).cast(gdb.lookup_type(field_type.value).pointer()).dereference()


def read_frame_field(frame_addr, field_name):
    """Read a frame field by name, returning the integer value."""
    offset, field_type = FRAME_FIELDS[field_name]
    return int(read_mem(frame_addr + offset, field_type))


def parse_addr(arg):
    """Parse a gdb expression into an integer address."""
    return int(gdb.parse_and_eval(arg))


class PrintFrame(gdb.Command):
    """Print the contents of an X86_64InterpreterFrame at the given address."""

    def __init__(self):
        super().__init__("printframe", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            addr = parse_addr(arg)
        except Exception as e:
            print(f"Invalid address: {e}")
            return

        for name, (offset, field_type) in FRAME_FIELDS.items():
            try:
                val = read_mem(addr + offset, field_type)
                val = hex(val) if field_type == FieldType.LONG else int(val)
            except gdb.error as e:
                val = f"<error: {e}>"
            print(f"{name:<12} @ +{offset:>2} = {val}")


def print_value_stack(vfp, vsp):
    """Print the contents of the value stack between vfp and vsp."""
    n_elems = (vsp - vfp) // VALUE_SLOT_SIZE
    print(f"VFP = {hex(vfp)}, VSP = {hex(vsp)}")

    if n_elems < 0 or n_elems > 10:
        print(f"Invalid number of elements {n_elems}, aborting")
        return

    print(f"Printing {n_elems} stack values\n")
    # Loop from VSP to VFP in reverse, by value slot size
    # TODO: compatibility with untagged mode
    for slot_addr in range(vsp - VALUE_SLOT_SIZE, vfp - VALUE_SLOT_SIZE, -VALUE_SLOT_SIZE):
        try:
            tag = int(read_mem(slot_addr, FieldType.UCHAR))
            print(f"@ {hex(slot_addr)}:")
            print(f"  Tag:   {hex(tag)}")
            print(f"  Value: ", end="")

            val_addr = slot_addr + TAG_TO_VALUE_OFFSET
            for i in range(4):
                val = int(read_mem(val_addr + i * 4, FieldType.UINT))
                print(f"0x{val:08x}", end=" ")
            print()
        except gdb.error as e:
            print(f"Error reading at {hex(slot_addr)}: {e}")
            break


class VSFrame(gdb.Command):
    """Print the contents of the value stack, based on the given frame address."""

    def __init__(self):
        super().__init__("vsframe", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            addr = parse_addr(arg)
            vfp = read_frame_field(addr, "vfp")
            vsp = read_frame_field(addr, "vsp")
        except Exception as e:
            print(f"Error reading frame: {e}")
            return

        print_value_stack(vfp, vsp)


class VSReg(gdb.Command):
    """Print the contents of the value stack, given vfp and vsp directly."""

    def __init__(self):
        super().__init__("vsreg", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        args = arg.split()
        if len(args) != 2:
            print("Usage: vsreg <vfp> <vsp>")
            return

        try:
            vfp = parse_addr(args[0])
            vsp = parse_addr(args[1])
        except Exception as e:
            print(f"Invalid address: {e}")
            return

        print_value_stack(vfp, vsp)


PrintFrame()
VSFrame()
VSReg()

end

# Breakpoint for module compilation in --mode=spc.
# break X86_64SpcModuleCode.new

# Breakpoint for general-purpose wasm entrypoint.
break Execute.call

