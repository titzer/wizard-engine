import component wali {
	def SYS_open(pathname: Pointer, flags: i32, mode: i32) -> i64;
	def SYS_close(fd: i32) -> i64;
	def SYS_read(fd: i32, buf: Pointer, count: i32) -> i64;
	def SYS_write(fd: i32, buf: Pointer, count: i32) -> i64;
	def SYS_mmap(addr: Pointer, len: i32, prot: i32, flags: i32, fd: i32, offset: i64) -> i64;
	def SYS_munmap(addr: Pointer, len: i32) -> i64;
}

def STDOUT = 1;
def PROT_READ = 0x1;
def PROT_WRITE = 0x2;
def MAP_PRIVATE = 0x02;
def MAP_ANONYMOUS = 0x20;
def main() -> i64 {
	var length = 15;
	print("Page size: "); print_int(length); print("\n");
	var addr = wali.SYS_mmap(Pointer.NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (addr == -1) {
		print("Mmap failed\n");
		return 1;
	}
	print("Addr: "); print_long(addr); print("\n");
	var p = Pointer.NULL + int.!(addr);
	for (i < 15) {
		print("Accessing element: "); print_int(i); print("\n");
		p = p + 4;
		p.store<int>(i);
		var store_result = p.load<int>();
		print_int(store_result); print("\n");
	}
	wali.SYS_munmap(p, length);
	return 0;
}

def print(str: string) {
	wali.SYS_write(STDOUT, Pointer.atContents(str), str.length);
}

def print_int(val: int) {
	var buf = Array<byte>.new(10);
	var len = Ints.renderDecimal(val, buf, 0);
	wali.SYS_write(STDOUT, Pointer.atContents(buf), len);
}

def print_long(val: long) {
	var buf = Array<byte>.new(20);
	var len = Longs.renderDecimal(val, buf, 0);
	wali.SYS_write(STDOUT, Pointer.atContents(buf), len);
}


component Ints {
	// Render {val} in decimal at the position {pos} in {a}, returning
	// the number of characters output.
	def renderDecimal(val: int, a: Array<byte>, pos: int) -> int {
		if (val < 0) {
			a[pos++] = '-';
			return 1 + renderPosDecimal(u32.view(0 - val), a, pos);
		}
		return renderPosDecimal(u32.view(val), a, pos);
	}

	// Render {val} in decimal at the position {pos} in {a}, returning
	// the number of characters output.
	def renderPosDecimal(val: u32, a: Array<byte>, pos: int) -> int {
		var p = pos;
		if (val < 10) {  // fastpath for small integers.
			a[p] = byte.view('0' + val);
			return 1;
		}
		if (val < 100) { // fastpath for small integers.
			a[p++] = byte.view('0' + (val / 10));
			a[p++] = byte.view('0' + (val % 10));
			return 2;
		}
		var nonZero = false;
		// XXX(fast): worth it to compute digits low to high? 1 divide vs 2.
		for (radix = 1000000000u; radix > 0; radix = radix / 10) {
			var digit = val / radix;
			val = val % radix;
			if (digit != 0) nonZero = true;
			if (nonZero) a[p++] = byte.view('0' + digit);
		}
		return p - pos;
	}
}

component Longs {
	// Render {i} in decimal at the position {pos} in {a}, returning
	// the number of characters output.
	def renderDecimal(i: i64, a: Array<byte>, pos: int) -> int {
		var small = i32.view(i);
		if (small == i) return Ints.renderDecimal(small, a, pos); // faster
		if (i < 0) {
			a[pos++] = '-';
			return 1 + renderPosDecimal(u64.view(0 - i), a, pos);
		}
		return renderPosDecimal(u64.view(i), a, pos);
	}
	// Render {i} in decimal at the position {pos} in {a}, returning
	// the number of characters output.
	def renderPosDecimal(i: u64, a: Array<byte>, pos: int) -> int {
		var small = u32.view(i);
		if (small == i) return Ints.renderPosDecimal(small, a, pos); // faster
		var nonZero = false;
		// XXX(fast): divide by 1000000000 and print two (or three) ints, to avoid repeated 64-bit divide.
		// XXX(fast): worth it to compute digits low to high? 1 divide vs 2.
		var p = pos;
		for (radix = 10000000000000000000ul; radix > 0; radix = radix / 10) {
			var digit = i / radix;
			i = i % radix;
			if (digit != 0) nonZero = true;
			if (nonZero) a[p++] = byte.view('0' + digit);
		}
		return p - pos;
	}
}
