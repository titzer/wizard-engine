// Copyright 2025 Wizard authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def X_ = TestTiers.addTests([
	("ping_pong", test_ping_pong)
]);

def NONE = BpTypeCode.EmptyBlock.code;

def test_ping_pong(i: ExeTester) {
	// function with infinite loop
	var f2 = i.newFunction(SigCache.v_v, []);
	i.addCodeV(f2, [
		u8.view(Opcode.LOOP.code), NONE,
		u8.view(Opcode.BR.code), 0,
		u8.view(Opcode.END.code)
	]);

	i.sig(SigCache.i_i);
	i.codev([
		u8.!(Opcode.NOP.code),
		u8.!(Opcode.LOOP.code), NONE,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_SUB.code),
		u8.!(Opcode.LOCAL_TEE.code), 0,
		u8.!(Opcode.BR_IF.code), 0,
		u8.!(Opcode.END.code),
		u8.!(Opcode.LOCAL_GET.code), 0]
	);

	var instance = i.makeInstance(), func2 = instance.functions[f2.func_index];
	var other = Target.newWasmStack().reset(func2).bind([]);
	var probe = RoundRobinProbe.new();
	probe.stacks.put(other);

	Instrumentation.insertLocalProbe(i.module, i.func.func_index, 1,
		StackGetterProbe.new(fun s => void(probe.stacks.put(s))));
	Instrumentation.insertLocalProbe(i.module, i.func.func_index, 2, probe);
	Instrumentation.insertLocalProbe(i.module, f2.func_index, 1, probe);

	i.args_i(5).assert2_i(0);
	i.t.assert_eq(17, probe.fires);
}

class StackGetterProbe(f: WasmStack -> void) extends Probe {
	def fire(loc: DynamicLoc) -> ProbeAction {
		f(loc.frame.getWasmStack());
		return ProbeAction.Continue;
	}
}

class RoundRobinProbe extends Probe {
	def stacks = Vector<WasmStack>.new();
	var pos = 0;
	var fires = 0;
	def fire(loc: DynamicLoc) -> ProbeAction {
		if (((fires++) & 1) == 0) return ProbeAction.Continue;
		var next = stacks[pos++];
		if (pos >= stacks.length) pos = 0;
		return ProbeAction.Preempt(next);
	}
}