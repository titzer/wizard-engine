// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def X: Array<Value>;
var NO_CODE: Array<byte> = [];
def NONE = BpTypeCode.EmptyBlock.code;

// Registers a "unop" opcode test
def reg1<X, Z>(opcode: Opcode,
		f: (ExeTester, Opcode, Array<(Z, X)>) -> void,
		cases: Array<(Z, X)>) -> (string, ExeTester -> void) {
	return (opcode.mnemonic, f(_, opcode, cases));
}

// Registers a "binop" opcode test
def reg2<I, R>(opcode: Opcode,
		f: (ExeTester, Opcode, Array<((I, I), R)>) -> void,
		cases: Array<((I, I), R)>) -> (string, ExeTester -> void) {
	return (opcode.mnemonic, f(_, opcode, cases));
}

// Runs a "unop" opcode test
def test_x_z<X, Z>(i: ExeTester, opcode: Opcode, cases: Array<(Z, X)>, xv: X -> Value, zv: Z -> Value) {
	i.code_op(opcode);
	for (c in cases) {
		i.assert_v([xv(c.1)], zv(c.0));
	}
}
// Runs a "unop" opcode test that can generate traps
def test_x_r<X>(i: ExeTester, opcode: Opcode, cases: Array<(X, Result)>, xv: X -> Value) {
	i.code_op(opcode);
	for (c in cases) {
		i.assert_r([xv(c.0)], c.1);
	}
}
// Runs a "binop" opcode test that returns values
def test_xy_z<X, Y, Z>(i: ExeTester, opcode: Opcode, cases: Array<((X, Y), Z)>, xv: X -> Value, yv: Y -> Value, zv: Z -> Value) {
	i.code_op(opcode);
	for (c in cases) {
		i.assert_v([xv(c.0.0), yv(c.0.1)], zv(c.1));
	}
}
// Runs a "binop" opcode test that may generate traps
def test_xy_r<X, Y>(i: ExeTester, opcode: Opcode, cases: Array<((X, Y), Result)>, xv: X -> Value, yv: Y -> Value) {
	i.code_op(opcode);
	for (c in cases) {
		i.assert_r([xv(c.0.0), yv(c.0.1)], c.1);
	}
}

def T_u_u = reg1(_, test_x_z(_, _, _, Values.u_v, Values.u_v), _);
def T_w_w = reg1(_, test_x_z(_, _, _, Values.w_v, Values.w_v), _);
def T_w_u = reg1(_, test_x_z(_, _, _, Values.w_v, Values.u_v), _);
def T_u_w = reg1(_, test_x_z(_, _, _, Values.u_v, Values.w_v), _);
def T_f_f = reg1(_, test_x_z(_, _, _, Value.F32, Value.F32), _);
def T_d_d = reg1(_, test_x_z(_, _, _, Value.F64, Value.F64), _);
def T_i_f = reg1(_, test_x_z(_, _, _, Values.i_v, Value.F32), _);
def T_i_i = reg1(_, test_x_z(_, _, _, Values.i_v, Values.i_v), _);
def T_l_l = reg1(_, test_x_z(_, _, _, Values.l_v, Values.l_v), _);
def T_f_i = reg1(_, test_x_z(_, _, _, Value.F32, Values.i_v), _);
def T_f_r = reg1(_, test_x_r(_, _, _, Value.F32), _);
def T_f_l = reg1(_, test_x_z(_, _, _, Value.F32, Values.l_v), _);
def T_l_f = reg1(_, test_x_z(_, _, _, Values.l_v, Value.F32), _);
def T_i_d = reg1(_, test_x_z(_, _, _, Values.i_v, Value.F64), _);
def T_d_i = reg1(_, test_x_z(_, _, _, Value.F64, Values.i_v), _);
def T_d_l = reg1(_, test_x_z(_, _, _, Value.F64, Values.l_v), _);
def T_d_r = reg1(_, test_x_r(_, _, _, Value.F64), _);
def T_l_d = reg1(_, test_x_z(_, _, _, Values.l_v, Value.F64), _);

def T_ii_i = reg2(_, test_xy_z(_, _, _, Values.i_v, Values.i_v, Values.i_v), _);
def T_uu_u = reg2(_, test_xy_z(_, _, _, Values.u_v, Values.u_v, Values.u_v), _);
def T_ii_r = reg2(_, test_xy_r(_, _, _, Values.i_v, Values.i_v), _);
def T_ll_l = reg2(_, test_xy_z(_, _, _, Values.l_v, Values.l_v, Values.l_v), _);
def T_ll_r = reg2(_, test_xy_r(_, _, _, Values.l_v, Values.l_v), _);
def T_ww_w = reg2(_, test_xy_z(_, _, _, Values.w_v, Values.w_v, Values.w_v), _);
def T_ll_u = reg2(_, test_xy_z(_, _, _, Values.l_v, Values.l_v, Values.u_v), _);

def T_ff_f = reg2(_, test_xy_z(_, _, _, Value.F32, Value.F32, Value.F32), _);
def T_dd_d = reg2(_, test_xy_z(_, _, _, Value.F64, Value.F64, Value.F64), _);
def T_ff_i = reg2(_, test_xy_z(_, _, _, Value.F32, Value.F32, Value.I32), _);
def T_dd_i = reg2(_, test_xy_z(_, _, _, Value.F64, Value.F64, Value.I32), _);
def T_f_d = reg1(_, test_x_z(_, _, _, Value.F32, Value.F64), _);
def T_d_f = reg1(_, test_x_z(_, _, _, Value.F64, Value.F32), _);

def R_FUNREP = Traps.result(TrapReason.FLOAT_UNREPRESENTABLE);

def i_r(val: i32) -> Result {
	return Result.Value([Value.I32(u32.view(val))]);
}
def u_r(val: u32) -> Result {
	return Result.Value([Value.I32(val)]);
}
def l_r(val: i64) -> Result {
	return Result.Value([Value.I64(u64.view(val))]);
}
def w_r(val: u64) -> Result {
	return Result.Value([Value.I64(val)]);
}

//===========================================================
def ALL_EXE_TESTS: Array<(string, ExeTester -> void)> = [
	("empty", test_empty),
	("unreachable", test_unreachable),
	("nop", test_nop),
	("block0", test_block0),
	("block1", test_block1),
	("block2", test_block2),
	("loop0", test_loop0),
	("loop1", test_loop1),
	("if0", test_if0),
	("if1", test_if1),
	("br0", test_br0),
	("br1", test_br1),
	("br2", test_br2),
	("br_if", test_br_if),
	("br_table0", test_br_table0),
	("br_table1", test_br_table1),
	("br_table2", test_br_table2),
	("br_table3", test_br_table3),
	("return0", test_return0),
	("return1", test_return1),
	("return2", test_return2),
	("return3", test_return3),
	("call0", test_call0),
	("call1", test_call1),
	("call2", test_call2),
	("callN", test_callN),
	("call_trap", test_call_trap),
	("call_indirect", test_call_indirect),
	("call_host", test_call_host),
	("call.ref", test_call_ref),
	("rcall1", test_rcall1),
	("rcall2", test_rcall2),
	("rcall3", test_rcall3),
	("rcallN", test_rcallN),
	("rcall_host", test_rcall_host),
	("rcall_indirect", test_rcall_indirect),
	("rcall_ref", test_rcall_ref),
	("drop", test_drop),
	("select", test_select),
	("selectt", test_selectt),
	("locals0", test_locals0),
	("locals1", test_locals1),
	("locals2", test_locals2),
	("locals3", test_locals3),
	("locals4", test_locals4),
	("locals5", test_locals5),
	("params", test_params),
	("global.get", test_global_get),
	("global.set", test_global_set),
	("imm_global", test_imm_global),
	("i32.const", test_i32_const),
	("i64.const", test_i64_const),
	("f32.const", test_f32_const),
	("load8", test_load8),
	("load16", test_load16),
	("load32", test_load32),
	("load64", test_load64),
	("load_oob0", test_load_oob0),
	("load_oob1", test_load_oob1),
	("store8", test_store8),
	("store16", test_store16),
	("store32", test_store32),
	("store64", test_store64),
	("store_oob0", test_store_oob0),
	("store_oob1", test_store_oob1),
	("memory_size", test_memory_size),
	("memory_grow1", test_memory_grow1),
	("memory_grow2", test_memory_grow2),
	("stack_overflow1", test_stack_overflow1),
	("stack_overflow2", test_stack_overflow2),
	("sign_ext", test_sign_ext),
	("reinterpret", test_reinterpret),
	("invalid", test_invalid),
	("extleb", test_extleb),
	("ref_default", test_ref_default),
	("ref.null_extern", test_ref_null_extern),
	("ref.null_func", test_ref_null_func),
	("ref.is_null", test_ref_is_null),
	("ref.func", test_ref_func),
	("ref.as_non_null", test_ref_as_non_null),
	("memory.init", test_memory_init),
	("data.drop", test_data_drop),
	("memory.copy", test_memory_copy),
	("memory.fill", test_memory_fill),
	("table.init", test_table_init),
	("elem.drop", test_elem_drop),
	("table.get", test_table_get),
	("table.set", test_table_set),
	("table.copy", test_table_copy),
	("table.grow1", test_table_grow1),
	("table.grow2", test_table_grow2),
	("table.size", test_table_size),
	("table.fill", test_table_fill),
	("nans", test_nans),
	("host_tail_call1", test_host_tail_call1),
	("host_tail_call2", test_host_tail_call2),
	("struct.new", test_struct_new),
	("struct.new_default", test_struct_new_default),
	("struct.get", test_struct_get),
	("struct.get_su", test_struct_get_su),
	("struct.set", test_struct_set),
	("array.new", test_array_new),
	("array.new_default", test_array_new_default),
	("array.get", test_array_get),
	("array.get_su", test_array_get_su),
	("array.set", test_array_set),
	("array.len", test_array_len),
	("array.new_fixed", test_array_new_fixed),
	("i31.new", test_i31_new),
	("i31.get_s", test_i31_get_s),
	("i31.get_u", test_i31_get_u),
	("ref.test", test_ref_test),
	("ref.test_null", test_ref_test_null),
	("ref.cast", test_ref_cast),
	("ref.cast_null", test_ref_cast_null),
	("br_on_cast", test_br_on_cast),
	("br_on_cast_null", test_br_on_cast_null),
	("br_on_cast_fail", test_br_on_cast_fail),
	("br_on_cast_fail_null", test_br_on_cast_fail_null),
	("br_on_null", test_br_on_null),
	("br_on_non_null", test_br_on_non_null),
	("ref_eq", test_ref_eq),
	("abstype_default", test_abstype_default),
	("force_gc1", test_force_gc1),
	("force_gc2", test_force_gc2),
	("extern.internalize", test_internalize),
	("extern.externalize", test_externalize),

	T_u_u(Opcode.I32_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 1)]),
	T_ii_i(Opcode.I32_EQ, [
		((0, 0), 1),
		((0xFACEDEAD, 0xFACEDEAD), 1),
		((0xEACEEACE, 0xFACEEACE), 0)]),
	T_ii_i(Opcode.I32_NE, [
		((99, 99), 0),
		((0xFAEEDEAD, 0xFACEDEAD), 1),
		((0xFACEEACE, 0xFACEEACE), 0)]),
	T_ii_i(Opcode.I32_LT_S, [
		((55, 54), 0),
		((55, 55), 0),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LT_U, [
		((55, 54), 0),
		((55, 55), 0),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GT_S, [
		((55, 54), 1),
		((55, 55), 0),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GT_U, [
		((55, 54), 1),
		((55, 55), 0),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LE_S, [
		((55, 54), 0),
		((55, 55), 1),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 1)]),
	T_ii_i(Opcode.I32_LE_U, [
		((55, 54), 0),
		((55, 55), 1),
		((55, 56), 1),
		((-56, -55), 1),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GE_S, [
		((55, 54), 1),
		((55, 55), 1),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 0)]),
	T_ii_i(Opcode.I32_GE_U, [
		((55, 54), 1),
		((55, 55), 1),
		((55, 56), 0),
		((-56, -55), 0),
		((-55, 56), 1)]),

	T_w_u(Opcode.I64_EQZ, [
		(1, 0),
		(0, 0xFACEDEAD),
		(0, 0x00300000000),
		(0, 1)]),
	T_ll_u(Opcode.I64_EQ, [
		((0, 0), 1),
		((0xFACEDEAD, 0xFACEDEAD), 1),
		((0x10000000FACEDEAD, 0x20000000FACEDEAD), 0),
		((0xEACEEACE, 0xFACEEACE), 0)]),
	T_ll_u(Opcode.I64_NE, [
		((99, 99), 0),
		((0xFAEEDEAD55, 0xFACEDEAD55), 1),
		((0xFACEEACE11223344, 0xFACEEACE11223344), 0)]),
	T_ll_u(Opcode.I64_LT_S, [
		((55000000000, 54000000000), 0),
		((55000000000, 55000000000), 0),
		((55000000000, 56000000000), 1),
		((-56000000000, -55000000000), 1),
		((-55000000000, 56000000000), 1)]),
	T_ll_u(Opcode.I64_LT_U, [
		((55111111111, 54111111111), 0),
		((55111111111, 55111111111), 0),
		((55111111111, 56111111111), 1),
		((-56111111111, -55111111111), 1),
		((-55111111111, 56111111111), 0)]),
	T_ll_u(Opcode.I64_GT_S, [
		((55222222222, 54222222222), 1),
		((55222222222, 55222222222), 0),
		((55222222222, 56222222222), 0),
		((-56222222222, -55222222222), 0),
		((-55222222222, 56222222222), 0)]),
	T_ll_u(Opcode.I64_GT_U, [
		((55333333333, 54333333333), 1),
		((55333333333, 55333333333), 0),
		((55333333333, 56333333333), 0),
		((-56333333333, -55333333333), 0),
		((-55333333333, 56333333333), 1)]),
	T_ll_u(Opcode.I64_LE_S, [
		((55444444444, 54444444444), 0),
		((55444444444, 55444444444), 1),
		((55444444444, 56444444444), 1),
		((-56444444444, -55444444444), 1),
		((-55444444444, 56444444444), 1)]),
	T_ll_u(Opcode.I64_LE_U, [
		((55555555555, 54555555555), 0),
		((55555555555, 55555555555), 1),
		((55555555555, 56555555555), 1),
		((-56555555555, -55555555555), 1),
		((-55555555555, 56555555555), 0)]),
	T_ll_u(Opcode.I64_GE_S, [
		((55666666666, 54666666666), 1),
		((55666666666, 55666666666), 1),
		((55666666666, 56666666666), 0),
		((-56666666666, -55666666666), 0),
		((-55666666666, 56666666666), 0)]),
	T_ll_u(Opcode.I64_GE_U, [
		((55777777777, 54777777777), 1),
		((55777777777, 55777777777), 1),
		((55777777777, 56777777777), 0),
		((-56777777777, -55777777777), 0),
		((-55777777777, 56777777777), 1)]),
	T_ff_i(Opcode.F32_EQ, [
		((0, 0), 1),
		((Floats.f_1p31, Floats.f_minus1p31), 0),
		((Floats.f_minus0, 0), 1),
		((Floats.f_nan, 0), 0)]),
	T_ff_i(Opcode.F32_NE, [
		((0, 0), 0),
		((Floats.f_1p31, Floats.f_minus1p31), 1),
		((Floats.f_minus0, 0), 0),
		((Floats.f_nan, 0), 1)]),
	T_ff_i(Opcode.F32_LT, [
		((0, 0), 0),
		((Floats.f_1p31, Floats.f_minus1p31), 0),
		((Floats.f_minus1p31, Floats.f_1p31), 1),
		((Floats.f_minus0, 0), 0),
		((Floats.f_nan, 0), 0)]),
	T_ff_i(Opcode.F32_GT, [
		((0, 0), 0),
		((Floats.f_1p31, Floats.f_minus1p31), 1),
		((Floats.f_minus1p31, Floats.f_1p31), 0),
		((Floats.f_minus0, 0), 0),
		((Floats.f_nan, 0), 0)]),
	T_ff_i(Opcode.F32_GE, [
		((0, 0), 1),
		((Floats.f_1p31, Floats.f_minus1p31), 1),
		((Floats.f_minus1p31, Floats.f_1p31), 0),
		((Floats.f_minus0, 0), 1),
		((Floats.f_nan, 0), 0)]),
	T_ff_i(Opcode.F32_LE, [
		((0, 0), 1),
		((Floats.f_1p31, Floats.f_minus1p31), 0),
		((Floats.f_minus1p31, Floats.f_1p31), 1),
		((Floats.f_minus0, 0), 1),
		((Floats.f_nan, 0), 0)]),
	T_dd_i(Opcode.F64_EQ, [
		((0, 0), 1),
		((Floats.d_1p31, Floats.d_minus1p31), 0),
		((Floats.d_minus0, 0), 1),
		((Floats.d_nan, 0), 0)]),
	T_dd_i(Opcode.F64_NE, [
		((0, 0), 0),
		((Floats.d_1p31, Floats.d_minus1p31), 1),
		((Floats.d_minus0, 0), 0),
		((Floats.d_nan, 0), 1)]),
	T_dd_i(Opcode.F64_LT, [
		((0, 0), 0),
		((Floats.d_1p31, Floats.d_minus1p31), 0),
		((Floats.d_minus1p31, Floats.d_1p31), 1),
		((Floats.d_minus0, 0), 0),
		((Floats.d_nan, 0), 0)]),
	T_dd_i(Opcode.F64_GT, [
		((0, 0), 0),
		((Floats.d_1p31, Floats.d_minus1p31), 1),
		((Floats.d_minus1p31, Floats.d_1p31), 0),
		((Floats.d_minus0, 0), 0),
		((Floats.d_nan, 0), 0)]),
	T_dd_i(Opcode.F64_GE, [
		((0, 0), 1),
		((Floats.d_1p31, Floats.d_minus1p31), 1),
		((Floats.d_minus1p31, Floats.d_1p31), 0),
		((Floats.d_minus0, 0), 1),
		((Floats.d_nan, 0), 0)]),
	T_dd_i(Opcode.F64_LE, [
		((0, 0), 1),
		((Floats.d_1p31, Floats.d_minus1p31), 0),
		((Floats.d_minus1p31, Floats.d_1p31), 1),
		((Floats.d_minus0, 0), 1),
		((Floats.d_nan, 0), 0)]),
	T_u_u(Opcode.I32_CLZ, [
		(32, 0),
		(16, 0x8000),
		(0, 0x80000000),
		(31, 1)]),
	T_u_u(Opcode.I32_CTZ, [
		(32, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(0, 1)]),
	T_u_u(Opcode.I32_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(32, 0xFFFFFFFF)]),
	T_ii_i(Opcode.I32_ADD, [
		((4312, 9921), 14233),
		((0xffff0000, 0x00010000), 0x00000000),
		((0x0fff0000, 0x00010000), 0x10000000),
		((0xffff0000, 0x0000ffff), 0xffffffff)]),
	T_ii_i(Opcode.I32_SUB, [
		((76324872, 7623891), 68700981),
		((0, 1), 0xFFFFFFFF),
		((444, 444), 0)]),
	T_ii_i(Opcode.I32_MUL, [
		((8122, 67), 544174),
		((0xffff0000, 0), 0),
		((0x87234878, 0x1124783), 0x80975D68)]),
	T_ii_r(Opcode.I32_DIV_S, [
		((99, 3), u_r(33)),
		((99, -3), i_r(-33)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((i32.min, -1), Traps.result(TrapReason.DIV_UNREPRESENTABLE))]),
	T_ii_r(Opcode.I32_DIV_U, [
		((99, 3), u_r(33)),
		((99, -3), u_r(0)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((0x80000000, 0xFFFFFFFF), u_r(0))]),
	T_ii_r(Opcode.I32_REM_S, [
		((99, 10), u_r(9)),
		((107, -10), i_r(7)),
		((-107, -10), i_r(-7)),
		((-107, 10), i_r(-7)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((5559823, 1), u_r(0)),
		((0x80000000, 0xFFFFFFFF), u_r(0))]),
	T_ii_r(Opcode.I32_REM_U, [
		((13338, 10), u_r(8)),
		((99, -3), u_r(99)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((555, 1), u_r(0)),
		((0x80000000, 0xFFFFFFFF), u_r(0x80000000))]),
	T_uu_u(Opcode.I32_AND, [
		((0xFFFFF000, 0x000FFFFF), 0x000FF000)]),
	T_uu_u(Opcode.I32_OR, [
		((0x0FFFF000, 0x000FFFFF), 0x0FFFFFFF)]),
	T_uu_u(Opcode.I32_XOR, [
		((0x0FFFF000, 0x000FFFFF), 0x0FF00FFF)]),
	T_uu_u(Opcode.I32_SHL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xFFFFFFFF, 31), 0x80000000),
		((0x000FF000, 36), 0x00FF0000)]),
	T_uu_u(Opcode.I32_SHR_S, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0x0FFFFFFF, 27), 0x00000001),
		((0xFFFFFF00, 4), 0xFFFFFFF0),
		((0x000FF000, 36), 0x0000FF00)]),
	T_uu_u(Opcode.I32_SHR_U, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xFFFFFFFF, 31), 0x00000001),
		((0x000FF000, 36), 0x0000FF00)]),
	T_uu_u(Opcode.I32_ROTL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xABCD0123, 36), 0xBCD0123A)]),
	T_uu_u(Opcode.I32_ROTR, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF000),
		((0xABCD0123, 36), 0x3ABCD012)]),

	T_w_w(Opcode.I64_CLZ, [
		(64, 0),
		(48, 0x8000),
		(32, 0x80000000),
		(0, 0x8000000000000000),
		(63, 1)]),
	T_w_w(Opcode.I64_CTZ, [
		(64, 0),
		(15, 0x8000),
		(31, 0x80000000),
		(63, 0x8000000000000000),
		(0, 1)]),
	T_w_w(Opcode.I64_POPCNT, [
		(0, 0),
		(1, 1),
		(4, 0xF),
		(8, 0xF00000000F0),
		(32, 0x3333333333333333),
		(64, 0xFFFFFFFFFFFFFFFF),
		(32, 0xFFFFFFFF)]),
	T_ww_w(Opcode.I64_ADD, [
		((4312000111000, 9921111000111), 14233111111111),
		((0xffff0000, 0x00010000), 0x100000000),
		((0x0fff0000, 0x00010000), 0x10000000),
		((0xffff0000, 0x0000ffff), 0xffffffff)]),
	T_ll_l(Opcode.I64_SUB, [
		((76324872010101, 7623891010101), 68700981000000),
		((0, 1), -1),
		((4449988776655, 4449988776655), 0)]),
	T_ww_w(Opcode.I64_MUL, [
		((8122000, 67000), 544174000000),
		((0xffff0000, 0), 0),
		((0x87234878, 0x1124783), 0x90C98380975D68)]),
	T_ll_r(Opcode.I64_DIV_S, [
		((99, 3), w_r(33)),
		((99, -3), l_r(-33)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((i64.min, -1), Traps.result(TrapReason.DIV_UNREPRESENTABLE))]),
	T_ll_r(Opcode.I64_DIV_U, [
		((99, 3), w_r(33)),
		((99, -3), w_r(0)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((i64.min, -1), w_r(0))]),
	T_ll_r(Opcode.I64_REM_S, [
		((99, 10), w_r(9)),
		((107, -10), l_r(7)),
		((-107, -10), l_r(-7)),
		((-107, 10), l_r(-7)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((5559823, 1), w_r(0)),
		((i64.min, -1), w_r(0))]),
	T_ll_r(Opcode.I64_REM_U, [
		((13338, 10), w_r(8)),
		((99, -3), w_r(99)),
		((1, 0), Traps.result(TrapReason.DIV_BY_ZERO)),
		((555, 1), w_r(0)),
		((0x80000000u, -1), w_r(0x80000000u))]),
	T_ww_w(Opcode.I64_AND, [
		((0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF), 0xFF00FF00FF00FF00)]),
	T_ww_w(Opcode.I64_OR, [
		((0x0FFFFFFFF0000000, 0x0000000FFFFFFFFF), 0x0FFFFFFFFFFFFFFF)]),
	T_ww_w(Opcode.I64_XOR, [
		((0xFFFFFFFFFF00FF00, 0xFF00FF00FFFFFFFF), 0x00FF00FF00FF00FF)]),
	T_ww_w(Opcode.I64_SHL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x000FF000, 32), 0x000FF00000000000),
		((0xFFFFFFFF, 31), 0x7FFFFFFF80000000),
		((0x000FF000, 68), 0x00FF0000),
		((0x000FF000, 36), 0x00FF000000000000)]),
	T_ww_w(Opcode.I64_SHR_S, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x000FF00000000000, 32), 0x000FF000),
		((0x0FFFFFFF, 27), 0x00000001),
		((0xFFFFFFFFFFFFFF00, 4), 0xFFFFFFFFFFFFFFF0),
		((0x000FF000, 68), 0x0000FF00)]),
	T_ww_w(Opcode.I64_SHR_U, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF00011223344, 32), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0xFFFFFFFFFFFFFFFF, 63), 0x00000001),
		((0x000FF000, 68), 0x0000FF00)]),
	T_ww_w(Opcode.I64_ROTL, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF00000000000, 32), 0x000FF000),
		((0x000FF000, 64), 0x000FF000),
		((0x0123456789ABCDEF, 68), 0x123456789ABCDEF0)]),
	T_ww_w(Opcode.I64_ROTR, [
		((0x000FF000, 0), 0x000FF000),
		((0x000FF000, 32), 0x000FF00000000000),
		((0x000FF000, 64), 0x000FF000),
		((0x0123456789ABCDEF, 68), 0xF0123456789ABCDE)]),
	T_f_f(Opcode.F32_ABS, [
		(0x40b00000, 0xc0b00000),
		(0x55555555, 0x55555555),
		(0, 0)]),
	T_f_f(Opcode.F32_NEG, [
		(0x40b00000, 0xc0b00000),
		(0xd5555555, 0x55555555),
		(0, 0x80000000)]),
	T_ff_f(Opcode.F32_ADD, [ // TODO: -0 and NaN cases for all floats
		((0x40b00000, 0xc0600000), 0x40000000),
		((0, 0), 0)]),
	T_ff_f(Opcode.F32_SUB, [
		((0x40b00000, 0xc0600000), 0x41100000),
		((0, 0), 0)]),
	T_ff_f(Opcode.F32_MUL, [
		((0x40b00000, 0xc0600000), 0xc19a0000),
		((0, 0), 0)]),
	T_ff_f(Opcode.F32_DIV, [
		((0x40b00000, 0xc0600000), 0xBFC92492),
		((0x4080000, 0), 0x7f800000)]),
	T_ff_f(Opcode.F32_MIN, [
		((0, Floats.f_1p31), 0),
		((Floats.f_1p31, 0), 0),
		((Floats.f_minus1p31, Floats.f_1p31), Floats.f_minus1p31),
		((0, Floats.f_minus0), Floats.f_minus0),
		((Floats.f_minus0, 0), Floats.f_minus0),
		((0x42280000, Floats.f_nan), Floats.f_nan),
		((Floats.f_nan, 0x42280000), Floats.f_nan)]),
	T_ff_f(Opcode.F32_MAX, [
		((0, Floats.f_1p31), Floats.f_1p31),
		((Floats.f_1p31, 0), Floats.f_1p31),
		((Floats.f_minus1p31, Floats.f_1p31), Floats.f_1p31),
		((0, Floats.f_minus0), 0),
		((Floats.f_minus0, 0), 0),
		((0x42280000, Floats.f_nan), Floats.f_nan),
		((Floats.f_nan, 0x42280000), Floats.f_nan)]),
	T_f_f(Opcode.F32_CEIL, [
		(0x40000000, 0x3fc00000),
		(0x40000000, 0x3fd9999a),
		(0xbf800000, 0xbfd9999a),
		(0xbf800000, 0xbfc00000)]),
	T_f_f(Opcode.F32_FLOOR, [
		(0x3f800000, 0x3fc00000),
		(0x3f800000, 0x3fd9999a),
		(0xC0000000, 0xbfd9999a),
		(0xC0000000, 0xbfc00000)]),
	T_f_f(Opcode.F32_TRUNC, [
		(0x3f800000, 0x3fc00000),
		(0x3f800000, 0x3fd9999a),
		(0xbf800000, 0xbfd9999a),
		(0xbf800000, 0xbfc00000)]),
	T_f_f(Opcode.F32_NEAREST, [
		(0, 0),
		(0x3f800000, 0x3fa66666),
		(0xc0000000, 0xbfd9999a)]),
	T_f_f(Opcode.F32_SQRT, [
		(0, 0),
		(0x40000000, 0x40800000)]),
	T_ff_f(Opcode.F32_COPYSIGN, [
		((u32.max, 0), 0x7fffffff),
		((0x87654321, 0x06666666), 0x07654321),
		((0x07654321, 0xA6666666), 0x87654321)]),
	T_d_d(Opcode.F64_ABS, [
		(0x40b0000012345678, 0xc0b0000012345678),
		(0x5555555598765432, 0x5555555598765432),
		(0, 0)]),
	T_d_d(Opcode.F64_NEG, [
		(0x40b00000aabbccdd, 0xc0b00000aabbccdd),
		(0xd5555555eeff2233, 0x55555555eeff2233),
		(0, 0x8000000000000000)]),
	T_dd_d(Opcode.F64_ADD, [ // TODO: -0 and NaN cases for all floats
		((0x401a000000000000, 0x4026800000000000), 0x4031c00000000000),
		((0, 0), 0)]),
	T_dd_d(Opcode.F64_SUB, [
		((0x401a000000000000, 0x4026800000000000), 0xc013000000000000),
		((0, 0), 0)]),
	T_dd_d(Opcode.F64_MUL, [
		((0x401a000000000000, 0x4026800000000000), 0x4052480000000000),
		((0, 0), 0)]),
	T_dd_d(Opcode.F64_DIV, [
		((0x401a000000000000, 0x4026800000000000), 0x3FE27D27D27D27D2),
		((0x401a000000000000, 0), 0x7ff0000000000000)]),
	T_dd_d(Opcode.F64_MIN, [
		((0, Floats.d_1p31), 0),
		((Floats.d_1p31, 0), 0),
		((Floats.d_minus1p31, Floats.d_1p31), Floats.d_minus1p31),
		((0, Floats.d_minus0), Floats.d_minus0),
		((Floats.d_minus0, 0), Floats.d_minus0),
		((0x42280000, Floats.d_nan), Floats.d_nan),
		((Floats.d_nan, 0x42280000), Floats.d_nan)]),
	T_dd_d(Opcode.F64_MAX, [
		((0, Floats.d_1p31), Floats.d_1p31),
		((Floats.d_1p31, 0), Floats.d_1p31),
		((Floats.d_minus1p31, Floats.d_1p31), Floats.d_1p31),
		((0, Floats.d_minus0), 0),
		((Floats.d_minus0, 0), 0),
		((0x42280000, Floats.d_nan), Floats.d_nan),
		((Floats.d_nan, 0x42280000), Floats.d_nan)]),
	T_d_d(Opcode.F64_CEIL, [
		(0x4000000000000000, 0x3ff8000000000000),
		(0xbff0000000000000, 0xbffb333333333333),
		(0xbff0000000000000, 0xbff8000000000000),
		(0x4000000000000000, 0x3ffb333333333333)]),
	T_d_d(Opcode.F64_FLOOR, [
		(0x3ff0000000000000, 0x3ff8000000000000),
		(0xC000000000000000, 0xbffb333333333333),
		(0xC000000000000000, 0xbff8000000000000),
		(0x3ff0000000000000, 0x3ffb333333333333)]),
	T_d_d(Opcode.F64_TRUNC, [
		(0x3ff0000000000000, 0x3ff8000000000000),
		(0xbff0000000000000, 0xbffb333333333333),
		(0xbff0000000000000, 0xbff8000000000000),
		(0x3ff0000000000000, 0x3ffb333333333333)]),
	T_d_d(Opcode.F64_NEAREST, [
		(0, 0),
		(0xc058c00000000000, 0xc058c010624dd2f2),
		(0x4096900000000000, 0x40968f8f5c28f5c3)]),
	T_d_d(Opcode.F64_SQRT, [
		(0, 0),
		(0x4008000000000000, 0x4022000000000000)]),
	T_dd_d(Opcode.F64_COPYSIGN, [
		((u64.max, 0), 0x7fffffffFFFFffff),
		((0x8765432199887766, 0x0666666677778888), 0x0765432199887766),
		((0x0765432199887766, 0xA666666677778888), 0x8765432199887766)]),
	T_w_u(Opcode.I32_WRAP_I64, [
		(1, 1),
		(0xFACEDEAD, 0xFACEDEAD),
		(0x7ACEDEAD, 0x17ACEDEAD),
		(0xFFFFFFFF, 0xFFFFFFFFFFFFFFFF),
		(99889988, 99889988)]),
	T_f_r(Opcode.I32_TRUNC_F32_S, [
		(0, u_r(0)),
		(0x449c8000, i_r(1252)),
		(Floats.f_minus1p31, i_r(i32.min)),
		(Floats.f_1p31, R_FUNREP),
		(Floats.f_1p32, R_FUNREP)]),
	T_f_r(Opcode.I32_TRUNC_F32_U, [
		(0, u_r(0)),
		(Floats.f_minus0, u_r(0)),
		(0x80000001, u_r(0)),
		(0x449c8000, i_r(1252)),
		(Floats.f_minus1p31, R_FUNREP),
		(Floats.f_1p31, i_r(1 << 31)),
		(Floats.f_1p32, R_FUNREP)]),
	T_d_r(Opcode.I32_TRUNC_F64_S, [
		(0, u_r(0)),
		(0x4093900000000000, i_r(1252)),
		(Floats.d_minus1p31, i_r(i32.min)),
		(Floats.d_1p31, R_FUNREP),
		(Floats.d_1p32, R_FUNREP)]),
	T_d_r(Opcode.I32_TRUNC_F64_U, [
		(0, u_r(0)),
		(0x4093900000000000, i_r(1252)),
		(Floats.d_minus1p31, R_FUNREP),
		(Floats.d_1p31, i_r(1 << 31)),
		(Floats.d_1p32, R_FUNREP)]),
	T_f_r(Opcode.I64_TRUNC_F32_S, [
		(0, l_r(0)),
		(0x449c8000, l_r(1252)),
		(Floats.f_minus1p31, l_r(i32.min)),
		(Floats.f_minus1p32, l_r(i33.min)),
		(Floats.f_minus1p33, l_r(i34.min)),
		(Floats.f_1p31, l_r(1L << 31)),
		(Floats.f_1p32, l_r(1L << 32)),
		(Floats.f_1p33, l_r(1L << 33)),
		(Floats.f_1p63, R_FUNREP),
		(Floats.f_1p64, R_FUNREP)]),
	T_f_r(Opcode.I64_TRUNC_F32_U, [
		(0, l_r(0)),
		(0x449c8000, l_r(1252)),
		(Floats.f_minus1p31, R_FUNREP),
		(Floats.f_minus1p32, R_FUNREP),
		(Floats.f_minus1p33, R_FUNREP),
		(Floats.f_1p31, l_r(1L << 31)),
		(Floats.f_1p32, l_r(1L << 32)),
		(Floats.f_1p33, l_r(1L << 33)),
		(Floats.f_1p63, l_r(1L << 63)),
		(Floats.f_1p64, R_FUNREP)]),
	T_d_r(Opcode.I64_TRUNC_F64_S, [
		(0, l_r(0)),
		(0x4093900000000000, l_r(1252)),
		(Floats.d_minus1p31, l_r(i32.min)),
		(Floats.d_minus1p32, l_r(i33.min)),
		(Floats.d_minus1p33, l_r(i34.min)),
		(Floats.d_1p31, l_r(1L << 31)),
		(Floats.d_1p32, l_r(1L << 32)),
		(Floats.d_1p33, l_r(1L << 33)),
		(Floats.d_1p63, R_FUNREP),
		(Floats.d_1p64, R_FUNREP)]),
	T_d_r(Opcode.I64_TRUNC_F64_U, [
		(0, l_r(0)),
		(0x4093900000000000, l_r(1252)),
		(Floats.d_minus1p31, R_FUNREP),
		(Floats.d_minus1p32, R_FUNREP),
		(Floats.d_minus1p33, R_FUNREP),
		(Floats.d_1p31, l_r(1L << 31)),
		(Floats.d_1p32, l_r(1L << 32)),
		(Floats.d_1p33, l_r(1L << 33)),
		(Floats.d_1p63, l_r(1L << 63)),
		(Floats.d_1p64, R_FUNREP)]),
	T_u_w(Opcode.I64_EXTEND_I32_U, [
		(1, 1),
		(0xFACEDEAD, 0xFACEDEAD),
		(0x7ACEDEAD, 0x7ACEDEAD),
		(0xFFFFFFFF, 0xFFFFFFFF),
		(99889988, 99889988)]),
	T_u_w(Opcode.I64_EXTEND_I32_S, [
		(1, 1),
		(0xFFFFFFFFFACEDEAD, 0xFACEDEAD),
		(0x7ACEDEAD, 0x7ACEDEAD),
		(0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF),
		(99889988, 99889988)]),
	T_i_f(Opcode.F32_CONVERT_I32_S, [
		(0x42380000, 46),
		(0xcde01d0c, -469999999),
		(0xcefffffb, -2147483000),
		(0x4efffffb, 2147483001)]),
	T_i_f(Opcode.F32_CONVERT_I32_U, [
		(0x4f000000, i32.view(2147483648u)),
		(0x4f32d05e, i32.view(3000000000u))]),
	T_l_f(Opcode.F32_CONVERT_I64_S, [
		(0xc5bb8000, -6000),
		(Floats.f_minus1p31, -2147483648),
		(Floats.f_1p63, 9223372036854775802)]),
	T_l_f(Opcode.F32_CONVERT_I64_U, [
		(0, 0),
		(Floats.f_1p31, u31.max),
		(Floats.f_1p32, u32.max),
		(Floats.f_1p33, u33.max),
		(Floats.f_1p63, u63.max),
		(Floats.f_1p64, -1)]),
	T_d_f(Opcode.F32_DEMOTE_F64, [
		(0x7f800000, 0x7ff0000000000000), // infinity
		(Floats.f_nan, Floats.d_nan), // nan
		(0x80000000, 0x8000000000000000), // -0
		(0x40c00000, 0x4018000000000000)]),
	T_i_d(Opcode.F64_CONVERT_I32_S, [
		(0x4047800000000000, 47),
		(0xc1bc03a17f000000, -469999999),
		(0xc1dfffff5e000000, -2147483000),
		(0x41dfffff5e400000, 2147483001)]),
	T_i_d(Opcode.F64_CONVERT_I32_U, [
		(Floats.d_1p31, i32.view(2147483648u)),
		(0x41e65a0bc0000000, i32.view(3000000000u))]),
	T_l_d(Opcode.F64_CONVERT_I64_S, [
		(0xc0b7700000000000, -6000),
		(0xc1e0000000000000, -2147483648),
		(Floats.d_1p63, 9223372036854775802)]),
	T_l_d(Opcode.F64_CONVERT_I64_U, [
		(0, 0),
		(Floats.d_1p31, 1L << 31),
		(Floats.d_1p32, 1L << 32),
		(Floats.d_1p33, 1L << 33),
		(Floats.d_1p63, 1L << 63),
		(Floats.d_1p64, -1)]),
	T_f_d(Opcode.F64_PROMOTE_F32, [
		(0x7ff0000000000000, 0x7f800000), // infinity
		(Floats.d_nan, Floats.f_nan), // nan
		(0x8000000000000000, 0x80000000), // -0
		(0x4018000000000000, 0x40c00000)]),
	T_i_i(Opcode.I32_EXTEND8_S, [
		(0, 0),
		(127, 127),
		(0xFFFF_FF80, 0x80),
		(0xFFFF_FFBD, 0xaaaa10BD)
		]),
	T_i_i(Opcode.I32_EXTEND16_S, [
		(0, 0),
		(127, 127),
		(0x80, 0x80),
		(0xFFFF_BD01, 0xaa10_BD01)
		]),
	T_l_l(Opcode.I64_EXTEND8_S, [
		(0, 0),
		(127, 127),
		(0xFFFF_FFFF_FFFF_FF80L, 0x80),
		(0xFFFF_FFFF_FFFF_FFBDL, 0xaaaa10BD),
		(0xFFFF_FFFF_FFFF_FFBDL, 0x1111_3333_aaaa_10BD)
		]),
	T_l_l(Opcode.I64_EXTEND16_S, [
		(0, 0),
		(127, 127),
		(0x80, 0x80),
		(0xFFFF_FFFF_FFFF_BD01L, 0xaa10_BD01),
		(0xFFFF_FFFF_FFFF_BD02L, 0x2222_4444_aa10_BD02)
		]),
	T_l_l(Opcode.I64_EXTEND32_S, [
		(1, 1),
		(0xFFFFFFFFFACEDEAD, 0xFACEDEAD),
		(0x7ACEDEAD, 0x7ACEDEAD),
		(0xFFFFFFFF_FFFFFFFF, 0xFFFFFFFF),
		(0xFFFFFFFF_87654321, 0x12345678_87654321L),
		(99889988, 99889988)
		]),
	T_f_i(Opcode.I32_TRUNC_SAT_F32_S, [
		(0, 0),
		(i32.max, Floats.f_1p31),
		(0, Floats.f_nan),
		(i32.min, Floats.f_minus1p31),
		(i32.min, 0xcf32d05e)]),
	T_f_i(Opcode.I32_TRUNC_SAT_F32_U, [
		(0, 0),
		(1 << 31, Floats.f_1p31),
		(-1, Floats.f_1p32),
		(0, Floats.f_nan),
		(0, Floats.f_minus1p31),
		(0, 0xcf32d05e)]),
	T_d_i(Opcode.I32_TRUNC_SAT_F64_S, [
		(0, 0),
		(i32.max, Floats.d_1p32),
		(i32.max, 0x41f8000000000000),
		(0, Floats.d_nan),
		(i32.min, 0xc1e65a0bc0000000)]),
	T_d_i(Opcode.I32_TRUNC_SAT_F64_U, [
		(0, 0),
		(1 << 31, Floats.d_1p31),
		(-1, Floats.d_1p32),
		(-1, 0x41f8000000000000),
		(0, Floats.d_nan),
		(0, 0xc1e65a0bc0000000)]),
	T_f_l(Opcode.I64_TRUNC_SAT_F32_S, [
		(0, 0),
		(1L << 31, Floats.f_1p31),
		(1L << 32, Floats.f_1p32),
		(long.max, Floats.f_1p63),
		(long.max, Floats.f_1p64),
		(0, Floats.f_nan),
		(long.min, Floats.f_minus1p63),
		(long.min, 0xdf123456)]),
	T_f_l(Opcode.I64_TRUNC_SAT_F32_U, [
		(0, 0),
		(1L << 31, Floats.f_1p31),
		(1L << 32, Floats.f_1p32),
		(1L << 63, Floats.f_1p63),
		(-1L, Floats.f_1p64),
		(0, Floats.f_nan),
		(0, Floats.f_minus1p63),
		(0, 0xdf123456)]),
	T_d_l(Opcode.I64_TRUNC_SAT_F64_S, [
		(0, 0),
		(1L << 31, Floats.d_1p31),
		(1L << 32, Floats.d_1p32),
		(long.max, Floats.d_1p63),
		(long.max, Floats.d_1p64),
		(0, Floats.d_nan),
		(long.min, Floats.d_minus1p63),
		(long.min, 0xc3e0010020030000)]),
	T_d_l(Opcode.I64_TRUNC_SAT_F64_U, [
		(0, 0),
		(1L << 31, Floats.d_1p31),
		(1L << 32, Floats.d_1p32),
		(1L << 63, Floats.d_1p63),
		(-1, Floats.d_1p64),
		(0, Floats.d_nan),
		(0, Floats.d_minus1p63),
		(0, 0xc3e0010020030000)])
	// TODO: tests for reference locals of all type constructors
];

// Registration for test tiers on various platforms.
component TestTiers {
	def X = register("int:", null); // always register interpreter tests

	def register(prefix: string, preRun: (Function, ErrorGen) -> void) {
		for (t in ALL_EXE_TESTS) {
			UnitTests.registerT(prefix, t.0, ExeTester.new(_, preRun), t.1);
		}
	}
}

def NO_IMPORTS = Array<Exportable>.new(0);

def newSig = SigDecl.new(ValueTypes.NO_HEAPTYPES, _, _);

class ExeTester(t: Tester, preRun: (Function, ErrorGen) -> void) extends ModuleBuilder {
	var max_call_depth = 100u;
	var imports = NO_IMPORTS;

	new() { Execute.reset(); }

	def codev(raw: Array<byte>) -> this {
		code(raw);
		var v = CodeValidator.new(extensions, Limits.new().set(extensions), module, ErrorGen.new(module.filename));
		var r = v.validateFunc(func);
		match (r) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("invalid code @+%d: %s", pc, msg);
		}
	}
	def run(args: Array<Value>) -> (Instance, Result) {
		var err = ErrorGen.new("ExeTest.v3");
		var instance = Instantiator.new(extensions, module, imports, err).run();
		if (!err.ok()) {
			t.fail(err.error_msg);
			return (instance, Traps.result(TrapReason.ERROR));
		}
		var f = instance.functions[0];
		if (preRun != null) {
			preRun(f, err);
			if (!err.ok()) {
				t.fail(err.error_msg);
				return (instance, Traps.result(TrapReason.ERROR));
			}
		}
		Execute.limits.max_call_depth = max_call_depth;
		var buf: StringBuilder;
		if (Trace.interpreter) {
			buf = StringBuilder.new();
			buf.puts("run ");
			Values.renderVals(buf, args);
			buf.ln();
			System.puts(buf.extract());
		}
		var r = Execute.call(f, args);

		if (Trace.interpreter) {
			buf.put1(" -> %q\n", r.render);
			System.puts(buf.extract());
		}
		return (instance, r);
	}
	def assert_u32(args: Array<Value>, expected: u32) {
		assert_v(args, Value.I32(expected));
	}
	def assert_u64(args: Array<Value>, expected: u64) {
		assert_v(args, Value.I64(expected));
	}
	def assert_f32(args: Array<Value>, expected: u32) {
		assert_v(args, Value.F32(expected));
	}
	def assert_f64(args: Array<Value>, expected: u64) {
		assert_v(args, Value.F64(expected));
	}
	def assert_i_i(arg: u32, expected: u32) {
		assert_u32([Value.I32(arg)], expected);
	}
	def assert_i(expected: u32) {
		assert_u32(X, expected);
	}
	def assert_l_l(arg: u64, expected: u64) {
		assert_u64([Value.I64(arg)], expected);
	}
	def assert_i_l(arg: u32, expected: u64) {
		assert_u64([Value.I32(arg)], expected);
	}
	def assert_ii_i(args: (u32, u32), expected: u32) {
		assert_u32([Value.I32(args.0), Value.I32(args.1)], expected);
	}
	def assert_mem(args: Array<Value>, offset: u32, expected: Array<byte>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		if (instance == null) return t.fail("instance is null");
		var mem = instance.memories[0];
		if (mem == null) return t.fail("memory is null");
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var got = mem.read1(0, u32.view(addr)).1;
			if (expected[i] != got) return t.fail3("expected mem[%x] = %x, got %x", addr, expected[i], got);
		}
	}
	def assert_ftable(args: Array<Value>, offset: u32, expected: Array<FuncDecl>) {
		var tr = run(args), instance = tr.0, r = tr.1;
		checkNop(r);
		var elems = instance.tables[0].elems;
		if (elems.length < expected.length) return t.fail2("expected table.length >= %d, got %d", expected.length, elems.length);
		for (i < expected.length) {
			var addr = int.!(offset) + i;
			var exp = expected[i];
			var got = Value.Ref.!(elems[addr]).val;
			if (exp == null) {
				if (got != null) return t.fail1("expected table[%d] == null", addr);
			} else {
				if (!WasmFunction.?(got)) return t.fail2("expected table[%d] : WasmFunction%s ", addr, if(got == null, ", got null", ""));
				var wgot = WasmFunction.!(got);
				if (exp != wgot.decl) return t.fail3("expected table[%d] = #%d, got #%d", addr, expected[i].func_index, wgot.decl.func_index);
			}
		}
	}
	def assert_r(args: Array<Value>, expected: Result) {
		assert_req(run(args).1, expected);
	}
	def assert_req(got: Result, expected: Result) {
		if (!expected.equals(got)) t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_v(args: Array<Value>, expected: Value) {
		assert_r(args, Result.Value([expected]));
	}
	def assert_nan(args: Array<Value>) {
		var got = run(args).1;
		match (got) {
			Value(vals) => match (vals[0]) {
				F32(bits) => if (Floats.isNan32(bits)) return;
				F64(bits) => if (Floats.isNan64(bits)) return;
				_ => ;
			}
			_ => ;
		}
		t.fail1("expected NaN, got %q", got.render);
	}
	def assert_g(args: Array<Value>, findex: int) {
		var r = run(args), instance = r.0, got = r.1;
		var expected = Result.Value([Value.Ref(instance.functions[findex])]);
		if (expected.equals(got)) return;
		t.fail2("expected %q, got %q", expected.render, got.render);
	}
	def assert_trap(args: Array<Value>, expected: TrapReason) {
		assert_r(args, Traps.result(expected));
	}
	def assert_nop(args: Array<Value>) {
		var r = run(args);
		checkNop(r.1);
	}
	def assert_val1<V>(got: Result, kind: string) -> (bool, V) {
		match (got) {
			Value(vals) => if (vals.length == 1) {
				var v = vals[0];
				if (V.?(v)) return (true, V.!(v));
			}
			_ => ;
		}
		t.fail2("expected 1 %s value, got %q", kind, got.render);
		var d: V;
		return (false, d);
	}
	def assert_struct(got: Result, expected_struct: StructDecl, rtt: HeapTypeDecl, fields: Array<Value>) {
		var r = assert_val1<Value.Ref>(got, "struct"), ok = r.0, hr = r.1;
		if (!ok) return;
		if (!HeapStruct.?(hr.val)) return t.fail1("expected struct, got %q", got.render);
		var obj = HeapStruct.!(hr.val);
		if (obj.decl != expected_struct) return t.fail2("expected heap %q, got %q",
			expected_struct.render, obj.decl.render);
		if (rtt != null && obj.decl != rtt) return t.fail2("expected rtt %q, got %q", rtt.render, obj.decl.render);
		t.assertar("fields", fields, obj.vals, Value.render);
	}
	def assert_array(got: Result, expected_array: ArrayDecl, rtt: HeapTypeDecl, elems: Array<Value>) {
		var r = assert_val1<Value.Ref>(got, "array"), ok = r.0, hr = r.1;
		if (!ok) return;
		if (!HeapArray.?(hr.val)) return t.fail1("expected array, got %q", got.render);
		var obj = HeapArray.!(hr.val);
		if (obj.decl != expected_array) return t.fail2("expected heap %q, got %q",
			expected_array.render, obj.decl.render);
		if (rtt != null && obj.decl != rtt) return t.fail2("expected rtt %q, got %q", rtt.render, obj.decl.render);
		t.assertar("elements", elems, obj.vals, Value.render);
	}
	def checkNop(r: Result) {
		match (r) {
			Break => t.fail("unexpected breakpoint");
			Throw(thrown) => t.fail1("unexpected trap: %q", thrown.render);
			Value(vals) => {
				var len = if(vals != null, vals.length);
				if (len > 0) t.fail1("expected no values, got %d value(s)", len);
			}
		}
	}
}

//===========================================================
// Begin actual tests
//===========================================================
def test_empty(i: ExeTester) {
	i.sig(SigCache.v_v).code([]).assert_nop(X);
}

def test_unreachable(i: ExeTester) {
	i.code([Opcode.UNREACHABLE.code]).assert_trap(X, TrapReason.UNREACHABLE);
}

def test_nop(i: ExeTester) {
	i.sig(SigCache.v_v).code([Opcode.NOP.code]).assert_nop(X);
}

def test_block0(i: ExeTester) {
	i.sig(SigCache.v_v);
	i.code([Opcode.BLOCK.code, NONE,
		Opcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.code([Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_i_i(9, 9);
	i.assert_i_i(7, 7);

	i.sig(SigCache.l_l);
	i.code([Opcode.BLOCK.code, BpTypeCode.I64.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_l_l(9, 9);
	i.assert_l_l(7, 7);
}

def test_block1(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.BLOCK.code, BpTypeCode.I32.code | byte.view(0x80), 0x7f, // 2-byte signed LEB
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_i_i(9, 9);
	i.assert_i_i(7, 7);

	i.sig(SigCache.l_l);
	i.code([Opcode.BLOCK.code, BpTypeCode.I64.code | byte.view(0x80), 0xff, 0x7f, // 3-byte signed LEB
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_l_l(9, 9);
	i.assert_l_l(7, 7);
}

def test_block2(i: ExeTester) {
	i.extensions |= Extension.GC;
	i.sig(SigDecl.new(ValueTypes.NO_HEAPTYPES, SigCache.arr_g, SigCache.arr_g));
	i.code([Opcode.BLOCK.code, BpTypeCode.REF_NULL.code,  BpTypeCode.FUNCREF.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code]);
	i.assert_v([Values.REF_NULL], Values.REF_NULL);
	def hf = HostFunctionN.new(null, SigCache.i_i, null);
	i.assert_v([Value.Ref(hf)], Value.Ref(hf));
}

def test_loop0(i: ExeTester) {
	i.sig(SigCache.v_v);
	i.code([Opcode.LOOP.code, NONE, Opcode.END.code]);
	i.assert_nop(X);

	i.sig(SigCache.i_i);
	i.codev([Opcode.LOOP.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(1, 0);
	i.assert_i_i(5, 0);

	i.codev([Opcode.LOOP.code, BpTypeCode.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code]);
	i.assert_i_i(1, 1);
	i.assert_i_i(5, 1);
}

def test_loop1(i: ExeTester) {
	i.sig(SigCache.i_v);
	i.codev([
		Opcode.I32_CONST.code, 10,
		Opcode.LOCAL_SET.code, 0,
		Opcode.LOOP.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 1,
		Opcode.I32_SUB.code,
		Opcode.LOCAL_TEE.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.END.code]);
	i.assert_nop([Values.i_v(99)]);
}

// TODO: test loops with fall through values
// TODO: test loops with arguments

def test_if0(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 11,
		Opcode.RETURN.code,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 22,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 33]);
	i.assert_i_i(9, 11);
	i.assert_i_i(0, 22);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 33,
		Opcode.LOCAL_SET.code, 0,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 44,
		Opcode.LOCAL_SET.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(7, 33);
	i.assert_i_i(0, 44);

	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, NONE,
		Opcode.I32_CONST.code, 13,
		Opcode.LOCAL_SET.code, 0,
		Opcode.END.code,
		Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(7, 13);
	i.assert_i_i(0, 0);
}
def test_if1(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypeCode.I32.code,
		Opcode.I32_CONST.code, 17,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 27,
		Opcode.END.code]);
	i.assert_i_i(6, 17);
	i.assert_i_i(0, 27);

	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypeCode.I32.code,
		Opcode.I32_CONST.code, 18,
		Opcode.BR.code, 0,
		Opcode.ELSE.code,
		Opcode.I32_CONST.code, 28,
		Opcode.BR.code, 0,
		Opcode.END.code]);
	i.assert_i_i(4, 18);
	i.assert_i_i(0, 28);
}
def test_br0(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.LOCAL_GET.code, 0, Opcode.BR.code, 0]);
	i.assert_i_i(3, 3);
	i.assert_i_i(9, 9);

	i.sig(SigCache.ii_i);
	i.codev([Opcode.LOCAL_GET.code, 1, Opcode.LOCAL_GET.code, 0, Opcode.BR.code, 0]);
	i.assert_ii_i((7, 11), 7);
	i.assert_ii_i((5, 99), 5);
}
def test_br1(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code]);
	i.assert_i_i(37, 37);
	i.assert_i_i(94, 94);

	i.sig(SigCache.ii_i);
	i.codev([Opcode.LOCAL_GET.code, 1,
		Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code,
		Opcode.RETURN.code]);
	i.assert_ii_i((71, 11), 71);
	i.assert_ii_i((52, 99), 52);
}
def test_br2(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.I32_CONST.code, 9,
		Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.I32_CONST.code, 5,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR.code, 0,
		Opcode.END.code,
		Opcode.I32_ADD.code]);
	i.assert_i_i(37, 46);
	i.assert_i_i(94, 103);
}
def test_br_if(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_IF.code, 0,
		Opcode.DROP.code,
		Opcode.I32_CONST.code, 8]);
	i.assert_i_i(11, 7);
	i.assert_i_i(0, 8);

	i.sig(SigCache.i_i);
	i.codev([Opcode.BLOCK.code, NONE,
		Opcode.I32_CONST.code, 9,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_IF.code, 1,
		Opcode.DROP.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 5]);
	i.assert_i_i(17, 9);
	i.assert_i_i(0, 5);
}
def test_br_table0(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([Opcode.I32_CONST.code, 7,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 0, 0,
		Opcode.UNREACHABLE.code]);
	i.assert_i_i(0, 7);
	i.assert_i_i(1, 7);
	i.assert_i_i(2, 7);
	i.assert_i_i(3, 7);
	i.assert_i_i(4, 7);
	i.assert_i_i(0xFFFFFFFF, 7);

	i.codev([Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 2, 1,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 16,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 17,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 18,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.UNREACHABLE.code
		]);
	i.assert_i_i(0, 16);
	i.assert_i_i(1, 18);
	i.assert_i_i(2, 17);
	i.assert_i_i(3, 17);
	i.assert_i_i(4, 17);
	i.assert_i_i(0xFFFFFFFF, 17);
}
def test_br_table1(i: ExeTester) {
	i.sig(SigCache.ii_i);

	i.codev([Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2,
		0, 2, 1,
		Opcode.UNREACHABLE.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 16,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 17,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code,
		Opcode.I32_CONST.code, 18,
		Opcode.I32_ADD.code,
		Opcode.RETURN.code,
		Opcode.END.code
		]);
	i.assert_ii_i((0, 0), 16);
	i.assert_ii_i((0, 10), 26);
	i.assert_ii_i((1, 0), 18);
	i.assert_ii_i((1, 20), 38);
	i.assert_ii_i((2, 0), 17);
	i.assert_ii_i((2, 30), 47);
	i.assert_ii_i((3, 0), 17);
	i.assert_ii_i((3, 40), 57);
	i.assert_ii_i((4, 0), 17);
	i.assert_ii_i((4, 50), 67);
	i.assert_ii_i((0xFFFFFFFF, 0), 17);
	i.assert_ii_i((0xFFFFFFFF, 60), 77);
}
def test_br_table2(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.I32_CONST.code, 9,
		Opcode.BLOCK.code, BpTypeCode.I32.code,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 42,
		Opcode.I32_CONST.code, 5,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 0, 0,
		Opcode.END.code,
		Opcode.I32_ADD.code]);
	i.assert_i_i(0, 14);
	i.assert_i_i(1, 14);
	i.assert_i_i(444, 14);
}
def test_br_table3(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.codev([
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.BLOCK.code, NONE,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_TABLE.code, 2, 2, 1, 0,
		Opcode.END.code,
		Opcode.I32_CONST.code, 44,
		Opcode.BR.code, 2,
		Opcode.END.code,
		Opcode.I32_CONST.code, 43,
		Opcode.BR.code, 1,
		Opcode.END.code,
		Opcode.I32_CONST.code, 42,
		Opcode.BR.code, 0,
		Opcode.I32_CONST.code, 41]);
	i.assert_i_i(0, 42);
	i.assert_i_i(1, 43);
	i.assert_i_i(2, 44);
	i.assert_i_i(3, 44);
}
def test_return0(i: ExeTester) {
	i.sig(SigCache.v_v).code([Opcode.RETURN.code]).assert_nop(X);
}
def test_return1(i: ExeTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0,
				  Opcode.RETURN.code]).assert_i_i(97, 97);
}
def test_return2(i: ExeTester) {
	i.sig(SigCache.v_v).code([Opcode.I32_CONST.code, 0,
				  Opcode.RETURN.code]).assert_nop(X);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 9,
				  Opcode.RETURN.code]).assert_i(9);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 7,
				  Opcode.I32_CONST.code, 13,
				  Opcode.RETURN.code]).assert_i(13);
}
def test_return3(i: ExeTester) {
	var sig_v_il = newSig(SigCache.arr_v, [ValueType.I32, ValueType.I64]);
	i.sig(sig_v_il);
	i.addLocals(1, ValueType.I32);
	i.code([Opcode.I32_CONST.code, 11, Opcode.I64_CONST.code, 22]);
	i.assert_r([], Result.Value([Value.I32(11), Value.I64(22)]));
}
def test_call0(i: ExeTester) {
	var f17 = byte.!(i.newFunction(SigCache.v_v, []).func_index);
	i.code([Opcode.I32_CONST.code, 17, Opcode.CALL.code, f17]).assert_i(17);
}
def test_call1(i: ExeTester) {
	var f17 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]).func_index);
	var f18 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 18]).func_index);
	var f19 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 19]).func_index);
	i.code([Opcode.CALL.code, f17]).assert_i(17);
	i.code([Opcode.CALL.code, f18]).assert_i(18);
	i.code([Opcode.CALL.code, f19]).assert_i(19);
}
def test_call2(i: ExeTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.newFunction(SigCache.i_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);

	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	var f3 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 1]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, f2]);
	i.assert_ii_i((22, 33), 22);
	i.assert_ii_i((44, 55), 44);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
	Opcode.CALL.code, f3]);
	i.assert_ii_i((77, 88), 88);
	i.assert_ii_i((88, 99), 99);
}
def test_callN(i: ExeTester) {
	var I = ValueType.I32;
	var sig_iiiii_i = newSig([I, I, I, I, I], [I]);
	i.sig(sig_iiiii_i);
	for (j < byte.!(5)) {
		var body = [Opcode.LOCAL_GET.code, j];
		var fx = byte.!(i.newFunction(sig_iiiii_i, body).func_index);
		i.codev([Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.LOCAL_GET.code, 2,
			Opcode.LOCAL_GET.code, 3,
			Opcode.LOCAL_GET.code, 4,
			Opcode.CALL.code, fx]);
		var args: Array<Value> = [Value.I32(j + 100u),
				Value.I32(j + 200u),
				Value.I32(j + 300u),
				Value.I32(j + 400u),
				Value.I32(j + 500u)];
		var result = args[j];
		i.assert_v(args, result);
	}
}
def test_call_trap(i: ExeTester) {
	var f17 = byte.!(i.newFunction(SigCache.v_v, [Opcode.UNREACHABLE.code]).func_index);
	i.code([Opcode.I32_CONST.code, 17, Opcode.CALL.code, f17]).assert_trap(X, TrapReason.UNREACHABLE);
}
def test_call_indirect(i: ExeTester) {
	i.sig(SigCache.ii_i);
	var f1 = i.newFunction(SigCache.i_i, [Opcode.I32_CONST.code, 11]);
	var f2 = i.newFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 22,
		Opcode.I32_ADD.code
	]);
	var f3 = i.newFunction(SigCache.v_v, []);
	i.addTable(7, 0, [f1.func_index, f2.func_index, f3.func_index, f1.func_index, f2.func_index, f3.func_index]);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL_INDIRECT.code, byte.!(f1.sig_index), 0]);
	i.assert_ii_i((0, 0), 11);
	i.assert_ii_i((0, 1), 22);
	i.assert_ii_i((44, 1), 66);
	i.assert_ii_i((0, 3), 11);
	i.assert_ii_i((0, 4), 22);
	i.assert_ii_i((49, 4), 71);
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(5)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(6)], TrapReason.FUNC_INVALID);
	i.assert_trap([Value.I32(0), Value.I32(7)], TrapReason.FUNC_INVALID);
}
def test_call_host_callback(a: Value, b: Value) -> HostResult {
	return HostResult.Value1(Values.i_v(99 - Values.v_i(a) - Values.v_i(b)));
}
def test_call_host(i: ExeTester) {
	var sig = i.newSig(SigCache.arr_ii, SigCache.arr_i);
	i.sig(sig);
	var fd = i.newFunc(sig);
	i.module.addImport("", "", [], fd);
	i.imports = [HostFunction2.new("test_call_host_callback", sig, test_call_host_callback)];
	i.code([Opcode.I32_CONST.code, 33,
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, byte.!(fd.func_index)]);

	i.assert_ii_i((44, 33), 22);
	i.assert_ii_i((1090909, 0xFAAA0123), 88431075);
}

def test_call_ref(i: ExeTester) {
	var sig_v_i = i.addSig(SigCache.v_i);
	var f17 = i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]);
	i.code([
		Opcode.REF_FUNC.code, byte.!(f17.func_index),
		Opcode.CALL_REF.code, heapIndexByte(sig_v_i)
	]);

	i.assert_i(17);

	i.code([
		Opcode.REF_NULL.code, BpTypeCode.FUNCREF.code,
		Opcode.CALL_REF.code, heapIndexByte(sig_v_i)
	]);

	i.assert_trap(X, TrapReason.NULL_DEREF);
}

def test_rcall1(i: ExeTester) {
	var f17 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]).func_index);
	var f18 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 18]).func_index);
	var f19 = byte.!(i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 19]).func_index);
	i.code([Opcode.RETURN_CALL.code, f17]).assert_i(17);
	i.code([Opcode.RETURN_CALL.code, f18]).assert_i(18);
	i.code([Opcode.RETURN_CALL.code, f19]).assert_i(19);
}
def test_rcall2(i: ExeTester) {
	i.sig(SigCache.i_i);
	var f1 = byte.!(i.newFunction(SigCache.i_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.RETURN_CALL.code, f1]);
	i.assert_i_i(197, 197);
	i.assert_i_i(36, 36);
	i.assert_i_i(31337, 31337);
}

def test_rcall3(i: ExeTester) {
	i.sig(SigCache.ii_i);
	var f2 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 0]).func_index);
	var f3 = byte.!(i.newFunction(SigCache.ii_i, [Opcode.LOCAL_GET.code, 1]).func_index);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL.code, f2,
		Opcode.UNREACHABLE.code]);
	i.assert_ii_i((22, 33), 22);
	i.assert_ii_i((44, 55), 44);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL.code, f3,
		Opcode.UNREACHABLE.code]);
	i.assert_ii_i((77, 88), 88);
	i.assert_ii_i((88, 99), 99);
}
def test_rcallN(i: ExeTester) {
	var I = ValueType.I32;
	var sig_iiiii_i = newSig([I, I, I, I, I], [I]);
	i.extensions |= Extension.TAIL_CALL;
	i.sig(sig_iiiii_i);
	for (j < byte.!(5)) {
		var body = [Opcode.LOCAL_GET.code, j];
		var fx = byte.!(i.newFunction(sig_iiiii_i, body).func_index);
		i.codev([Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.LOCAL_GET.code, 2,
			Opcode.LOCAL_GET.code, 3,
			Opcode.LOCAL_GET.code, 4,
			Opcode.RETURN_CALL.code, fx,
			Opcode.UNREACHABLE.code]);
		var args: Array<Value> = [Value.I32(j + 100u),
				Value.I32(j + 200u),
				Value.I32(j + 300u),
				Value.I32(j + 400u),
				Value.I32(j + 500u)];
		var result = args[j];
		i.assert_v(args, result);
	}
}
def test_rcall_host(i: ExeTester) {
	var sig = i.newSig(SigCache.arr_ii, SigCache.arr_i);
	i.sig(sig);
	var fd = i.newFunc(sig);
	i.module.addImport("", "", [], fd);
	i.imports = [HostFunction2.new("test_call_host_callback", sig, test_call_host_callback)];
	i.code([Opcode.I32_CONST.code, 33,
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL.code, byte.!(fd.func_index)]);

	i.assert_ii_i((44, 33), 22);
	i.assert_ii_i((1090909, 0xFAAA0123), 88431075);
}
def test_rcall_indirect(i: ExeTester) {
	i.sig(SigCache.ii_i);
	i.extensions |= Extension.TAIL_CALL;
	var f1 = i.newFunction(SigCache.i_i, [Opcode.I32_CONST.code, 11]);
	var f2 = i.newFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 22,
		Opcode.I32_ADD.code
	]);
	var f3 = i.newFunction(SigCache.v_v, []);
	i.addTable(7, 0, [f1.func_index, f2.func_index, f3.func_index, f1.func_index, f2.func_index, f3.func_index]);
	i.codev([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.RETURN_CALL_INDIRECT.code, byte.!(f1.sig_index), 0,
		Opcode.UNREACHABLE.code]);
	i.assert_ii_i((0, 0), 11);
	i.assert_ii_i((0, 1), 22);
	i.assert_ii_i((44, 1), 66);
	i.assert_ii_i((0, 3), 11);
	i.assert_ii_i((0, 4), 22);
	i.assert_ii_i((49, 4), 71);
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(5)], TrapReason.FUNC_SIG_MISMATCH);
	i.assert_trap([Value.I32(0), Value.I32(6)], TrapReason.FUNC_INVALID);
	i.assert_trap([Value.I32(0), Value.I32(7)], TrapReason.FUNC_INVALID);
}
def test_rcall_ref(i: ExeTester) {
	var sig_v_i = i.addSig(SigCache.v_i);
	var f17 = i.newFunction(SigCache.v_i, [Opcode.I32_CONST.code, 17]);
	i.code([
		Opcode.REF_FUNC.code, byte.!(f17.func_index),
		Opcode.RETURN_CALL_REF.code, heapIndexByte(sig_v_i)
	]);

	i.assert_i(17);

	i.code([
		Opcode.REF_NULL.code, BpTypeCode.FUNCREF.code,
		Opcode.RETURN_CALL_REF.code, heapIndexByte(sig_v_i)
	]);

	i.assert_trap(X, TrapReason.NULL_DEREF);
}


def test_drop(i: ExeTester) {
	i.sig(SigCache.v_v).code([Opcode.I32_CONST.code, 0, Opcode.DROP.code])
		.assert_nop(X);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 3,
				  Opcode.DROP.code,
				  Opcode.I32_CONST.code, 11])
		.assert_i(11);
	i.sig(SigCache.v_i).code([Opcode.I32_CONST.code, 4,
				  Opcode.I32_CONST.code, 5,
				  Opcode.DROP.code])
		.assert_i(4);
}
def test_select(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.I32_CONST.code, 11,
		Opcode.I32_CONST.code, 22,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_i_i(1, 11);
	i.assert_i_i(108, 11);
	i.assert_i_i(0, 22);

	i.sig(SigCache.i_l);
	i.code([Opcode.I64_CONST.code, 33,
		Opcode.I64_CONST.code, 44,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_u64([Value.I32(1)], 33);
	i.assert_u64([Value.I32(109)], 33);
	i.assert_u64([Value.I32(0)], 44);

	i.sig(SigCache.i_f);
	i.code([Opcode.F32_CONST.code, 0x11, 0x22, 0x33, 0x44,
		Opcode.F32_CONST.code, 0x55, 0x66, 0x77, 0x88,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_f32([Value.I32(1)], 0x44332211);
	i.assert_f32([Value.I32(66)], 0x44332211);
	i.assert_f32([Value.I32(0)], 0x88776655);

	i.sig(SigCache.i_d);
	i.code([Opcode.F64_CONST.code, 0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,
		Opcode.F64_CONST.code, 0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
		Opcode.LOCAL_GET.code, 0,
		Opcode.SELECT.code]);
	i.assert_f64([Value.I32(1)], 0x8877665544332211);
	i.assert_f64([Value.I32(66)], 0x8877665544332211);
	i.assert_f64([Value.I32(0)], 0x0807060504030201);
}
def test_selectt(i: ExeTester) {
	i.sig0([ValueTypes.EXTERNREF, ValueTypes.EXTERNREF, ValueType.I32], SigCache.arr_e);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.SELECT_T.code, 1, BpTypeCode.EXTERNREF.code]);
	var v1: Value = Value.Ref(HostObject.new());
	var v2: Value = Value.Ref(HostObject.new());
	i.assert_v([v1, v2, Value.I32(0)], v2);
	i.assert_v([v1, v2, Value.I32(1)], v1);

	// Multi-value select
	var v3: Value = Value.Ref(HostObject.new());
	var v4: Value = Value.Ref(HostObject.new());
	i.sig0(
		[ValueTypes.EXTERNREF, ValueTypes.EXTERNREF, ValueTypes.EXTERNREF, ValueTypes.EXTERNREF, ValueType.I32],
		[ValueTypes.EXTERNREF, ValueTypes.EXTERNREF]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.LOCAL_GET.code, 3,
		Opcode.LOCAL_GET.code, 4,
		Opcode.SELECT_T.code, 2, BpTypeCode.EXTERNREF.code, BpTypeCode.EXTERNREF.code]);
	i.assert_r([v1, v2, v3, v4, Value.I32(0)], Result.Value([v3, v4]));
	i.assert_r([v1, v2, v3, v4, Value.I32(1)], Result.Value([v1, v2]));
}

def test_locals0(i: ExeTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(11, 11);

	i.sig(SigCache.l_l).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_l_l(99887766554433, 99887766554433);

	i.sig(SigCache.f_f).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f32([Value.F32(0x11223344)], 0x11223344);

	i.sig(SigCache.d_d).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f64([Value.F64(0x5566778811223344)], 0x5566778811223344);
}
def test_locals1(i: ExeTester) {
	i.sig(SigCache.i_i);
	var i1 = byte.!(i.addLocal(ValueType.I32));
	i.code([Opcode.LOCAL_GET.code, i1]);
	i.assert_i_i(17, 0);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_SET.code, i1,
		Opcode.LOCAL_GET.code, i1]);
	i.assert_i_i(19, 19);

	var i2 = byte.!(i.addLocal(ValueType.I32));
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_SET.code, i1,
		Opcode.LOCAL_GET.code, i2]);
	i.assert_i_i(23, 0);
}
def test_locals2(i: ExeTester) {
	var l1 = byte.!(i.addLocal(ValueType.I64));
	i.sig(SigCache.v_l).code([
		Opcode.LOCAL_GET.code, l1
	]);
	i.assert_u64(X, 0);

	var f1 = byte.!(i.addLocal(ValueType.F32));
	i.sig(SigCache.v_f).code([
		Opcode.LOCAL_GET.code, f1
	]);
	i.assert_f32(X, 0);

	var d1 = byte.!(i.addLocal(ValueType.F64));
	i.sig(SigCache.v_d).code([
		Opcode.LOCAL_GET.code, d1
	]);
	i.assert_f64(X, 0);
}
def test_locals3(i: ExeTester) {
	i.sig(SigCache.ii_i).code([
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_TEE.code, 0
	]);
	i.assert_ii_i((0, 1), 1);
	i.assert_ii_i((0, 7), 7);
	i.assert_ii_i((0, 9999999), 9999999);
}
def test_locals4(i: ExeTester) {
	i.sig(SigCache.ii_i);
	i.addLocals(260, ValueType.I32);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I32_ADD.code,
		Opcode.LOCAL_TEE.code, 0xC0, 0x0,
		Opcode.LOCAL_SET.code, 0xC0, 0x1,
		Opcode.LOCAL_GET.code, 0xC0, 0x0,
		Opcode.LOCAL_GET.code, 0xC0, 0x1,
		Opcode.I32_MUL.code]);
	i.assert_ii_i((1, 2), 9);
	i.assert_ii_i((65, 993), 1119364);
}
def test_locals5(i: ExeTester) {
	var sig_v_i = i.addSig(SigCache.v_i);
	var ft = ValueType.Ref(true, HeapType.Func(sig_v_i));
	i.sig(SigDecl.new(ValueTypes.NO_HEAPTYPES, SigCache.arr_g, SigCache.arr_g));
	var l = i.addLocals(1, ft);
	i.code([
		Opcode.LOCAL_GET.code, byte.!(l)
	]);
	i.assert_v([Values.REF_NULL], Values.REF_NULL);
}
def test_params(i: ExeTester) {
	i.sig(SigCache.i_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_i_i(13, 13);
	i.assert_i_i(9991, 9991);

	i.sig(SigCache.l_l).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_u64([Value.I64(137)], 137);
	i.assert_u64([Value.I64(999145)], 999145);

	i.sig(SigCache.f_f).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f32([Value.F32(137u)], 137u);
	i.assert_f32([Value.F32(999145u)], 999145u);

	i.sig(SigCache.d_d).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_f64([Value.F64(137u)], 137u);
	i.assert_f64([Value.F64(999145u)], 999145u);

	i.sig(SigCache.ii_i).code([Opcode.LOCAL_GET.code, 0]);
	i.assert_ii_i((12, 15), 12);
	i.assert_ii_i((9791, 66), 9791);

	i.sig(SigCache.ii_i).code([Opcode.LOCAL_GET.code, 1]);
	i.assert_ii_i((12, 157), 157);
	i.assert_ii_i((9791, 8791), 8791);
}
def test_global_get(i: ExeTester) {
	var index = byte.!(i.newGlobal(ValueType.I32, InitExpr.I32(34)).global_index);
	i.code([Opcode.GLOBAL_GET.code, index]).assert_i(34);

	i.sig(SigCache.v_l);
	index = byte.!(i.newGlobal(ValueType.I64, InitExpr.I64(55)).global_index);
	i.code([Opcode.GLOBAL_GET.code, index]).assert_u64(X, 55);
}
def test_global_set(i: ExeTester) {
	var index = byte.!(i.newGlobal(ValueType.I32, InitExpr.I32(34)).global_index);
	i.code([Opcode.I32_CONST.code, 55,
		Opcode.GLOBAL_SET.code, index,
		Opcode.GLOBAL_GET.code, index]).assert_i(55);

	i.sig(SigCache.v_l);
	index = byte.!(i.newGlobal(ValueType.I64, InitExpr.I64(77)).global_index);
	i.code([Opcode.I64_CONST.code, 47,
		Opcode.GLOBAL_SET.code, index,
		Opcode.GLOBAL_GET.code, index]).assert_u64(X, 47);
}
def test_imm_global(i: ExeTester) {
	var index = byte.!(i.newImmGlobal(ValueType.I32, InitExpr.I32(9999)).global_index);
	i.code([Opcode.GLOBAL_GET.code, index]).assert_i(9999);

	i.sig(SigCache.v_l);
	index = byte.!(i.newImmGlobal(ValueType.I64, InitExpr.I64(777788889999)).global_index);
	i.code([Opcode.GLOBAL_GET.code, index]).assert_u64(X, 777788889999);
}


def test_i32_const(i: ExeTester) {
	i.sig(SigCache.v_i);
	i.code([Opcode.I32_CONST.code, 1]).assert_i(1);
	i.code([Opcode.I32_CONST.code, 33]).assert_i(33);
	i.code([Opcode.I32_CONST.code, 0xA7, 0x7F]).assert_i(u32.view(-89));
	i.code([Opcode.I32_CONST.code, 0x70]).assert_i(u32.view(-16));
	i.code([Opcode.I32_CONST.code, 0xA7, 0xF0, 0xF1, 0xF2,
		0x7E]).assert_i(3999037479u);
}
def test_i64_const(i: ExeTester) {
	i.sig(SigCache.v_l);
	i.code([Opcode.I64_CONST.code, 1]).assert_u64(X, 1);
	i.code([Opcode.I64_CONST.code, 33]).assert_u64(X, 33);
	i.code([Opcode.I64_CONST.code, 0x70]).assert_u64(X, u64.view(-16));
	i.code([Opcode.I64_CONST.code, 0x81, 0x82, 0x83, 0x84,
		0x85, 0x86, 0x87, 0x88, 0x09]).assert_u64(X, 653052939803345153);
}
def test_f32_const(i: ExeTester) {
	i.sig(SigCache.v_f);
	i.code([Opcode.F32_CONST.code, 0x44, 0x33, 0x22, 0x11]).assert_f32(X, 0x11223344);
	i.code([Opcode.F32_CONST.code, 0x66, 0x77, 0x88, 0x99]).assert_f32(X, 0x99887766);
}

def test_load8(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, Max.Set(1));
	i.addData(4, [0xF0, 0xF1]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD8_U.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(3, 0);
	i.assert_i_i(4, 0xF0);
	i.assert_i_i(5, 0xF1);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD8_S.code, 0, 2]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(2, 0xFFFFFFF0);
	i.assert_i_i(3, 0xFFFFFFF1);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD8_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(3, 0xF0);
	i.assert_i_l(4, 0xF1);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD8_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(1, 0xFFFFFFFFFFFFFFF0);
	i.assert_i_l(2, 0xFFFFFFFFFFFFFFF1);
}
def test_load16(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, Max.Set(1));
	i.addData(8, [0xF2, 0xF3, 0xCC, 0xDD]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD16_U.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(3, 0);
	i.assert_i_i(8, 0xF3F2);
	i.assert_i_i(9, 0xCCF3);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD16_S.code, 0, 2]);
	i.assert_i_i(0, 0);
	i.assert_i_i(4, 0);
	i.assert_i_i(6, 0xFFFFF3F2);
	i.assert_i_i(7, 0xFFFFCCF3);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD16_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(7, 0xF3F2);
	i.assert_i_l(9, 0xDDCC);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD16_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(5, 0xFFFFFFFFFFFFF3F2);
	i.assert_i_l(7, 0xFFFFFFFFFFFFDDCC);
}
def test_load32(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.addMemory(1, Max.Set(1));
	i.addData(10, [0xF5, 0xF6, 0xAA, 0xBB, 0xCC, 0xDD]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(6, 0);
	i.assert_i_i(10, 0xBBAAF6F5);
	i.assert_i_i(12, 0xDDCCBBAA);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 8]);
	i.assert_i_i(0, 0xF6F50000);
	i.assert_i_i(6, 0x0000DDCC);

	i.sig(SigCache.i_l);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD32_U.code, 0, 1]);
	i.assert_i_l(0, 0);
	i.assert_i_l(8, 0xAAF6F500);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD32_S.code, 0, 3]);
	i.assert_i_l(0, 0);
	i.assert_i_l(7, 0xFFFFFFFFBBAAF6F5);
	i.assert_i_l(9, 0xFFFFFFFFDDCCBBAA);
}
def test_load64(i: ExeTester) {
	i.sig(SigCache.i_l);
	i.addMemory(1, Max.Set(1));
	i.addData(12, [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I64_LOAD.code, 0, 0]);
	i.assert_i_l(0, 0);
	i.assert_i_l(3, 0);
	i.assert_i_l(12, 0x8877665544332211);
	i.assert_i_l(13, 0x0088776655443322);
}
def test_load_oob0(i: ExeTester) {
	i.addMemory(0, Max.Set(0));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_r([Value.I32(0)], Traps.result(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_load_oob1(i: ExeTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_LOAD.code, 0, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(65532, 0);
	i.assert_r([Value.I32(65533)], Traps.result(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_store8(i: ExeTester) {
	i.addMemory(1, Max.Set(1));
	i.sig0(SigCache.arr_i, SigCache.arr_v);
	i.addData(5, [0x99, 0x88, 0x77]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 3,
		Opcode.I32_STORE8.code, 0, 2]);
	i.assert_mem([Value.I32(3)], 4, [0,    3, 0x88, 0x77, 0]);
	i.assert_mem([Value.I32(4)], 4, [0, 0x99,    3, 0x77, 0]);
	i.assert_mem([Value.I32(5)], 4, [0, 0x99, 0x88,    3, 0]);
	i.assert_mem([Value.I32(6)], 4, [0, 0x99, 0x88, 0x77, 3]);
}
def test_store16(i: ExeTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_v);
	i.addData(11, [0x99, 0x88, 0x77]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 0x83, 0x08,
		Opcode.I32_STORE16.code, 0, 7]);
	i.assert_mem([Value.I32(4)], 10, [0,    3,    4, 0x77, 0, 0]);
	i.assert_mem([Value.I32(5)], 10, [0, 0x99,    3,    4, 0, 0]);
	i.assert_mem([Value.I32(6)], 10, [0, 0x99, 0x88,    3, 4, 0]);
	i.assert_mem([Value.I32(7)], 10, [0, 0x99, 0x88, 0x77, 3, 4]);
}
def test_store32(i: ExeTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_v);
	i.addData(19, [0x99, 0x88, 0x77, 0x66, 0x55]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 0x91, 0xC4, 0xCC, 0xA1, 0x04,
		Opcode.I32_STORE.code, 0, 9]);
	i.assert_mem([Value.I32(10)], 18, [0, 0x11, 0x22, 0x33, 0x44, 0x55, 0, 0]);
	i.assert_mem([Value.I32(11)], 18, [0, 0x99, 0x11, 0x22, 0x33, 0x44, 0, 0]);
	i.assert_mem([Value.I32(12)], 18, [0, 0x99, 0x88, 0x11, 0x22, 0x33, 0x44, 0]);
}
def test_store64(i: ExeTester) {
	i.addMemory(1, Max.Set(1));
	i.sig0([ValueType.I32, ValueType.I64], SigCache.arr_v);
	i.addData(33, [0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22]);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.I64_STORE.code, 0, 22]);
	i.assert_mem([Value.I32(12), Value.I64(0x0807060504030201)], 32, [0, 0x99, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);
	i.assert_mem([Value.I32(14), Value.I64(0xA8B7C6D5E4F30201)], 32, [0, 0x99, 0x88, 0x77, 0x01, 0x02, 0xF3, 0xE4, 0xD5, 0xC6, 0xB7, 0xA8]);
}
def test_store_oob0(i: ExeTester) {
	i.addMemory(0, Max.Set(0));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_STORE.code, 0, 0,
		Opcode.I32_CONST.code, 3]);
	i.assert_r([Value.I32(0)], Traps.result(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_store_oob1(i: ExeTester) {
	i.addMemory(1, Max.Set(1));
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_CONST.code, 5,
		Opcode.I32_STORE.code, 0, 0,
		Opcode.I32_CONST.code, 42]);
	i.assert_i_i(0, 42);
	i.assert_i_i(65532, 42);
	i.assert_r([Value.I32(65533)], Traps.result(TrapReason.MEM_OUT_OF_BOUNDS));
}
def test_memory_size(i: ExeTester) {
	i.addMemory(0, Max.Set(0));
	i.sig(SigCache.v_i);
	i.code([Opcode.MEMORY_SIZE.code, 0]);
	i.assert_i(0);

	i.addMemory(2, Max.Set(2));
	i.sig(SigCache.v_i);
	i.code([Opcode.MEMORY_SIZE.code, 1]);
	i.assert_i(2);
}
def test_memory_grow1(i: ExeTester) {
	i.addMemory(0, Max.Set(5));
	i.sig(SigCache.i_i);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(5, 0);
	i.assert_i_i(6, 0xFFFFFFFF);

	i.addMemory(1, Max.Set(2));
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 1]);
	i.assert_i_i(0, 1);
	i.assert_i_i(1, 1);
	i.assert_i_i(2, 0xFFFFFFFF);
}

def test_memory_grow2(i: ExeTester) {
	i.addMemory(0, Max.None);
	i.sig(SigCache.i_i);

	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.MEMORY_GROW.code, 0]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 0);
	i.assert_i_i(Target.limit_memory_pages + 1, 0xFFFFFFFF);
}

def test_stack_overflow1(i: ExeTester) {
	i.code([Opcode.CALL.code, 0]);
	i.max_call_depth = 10;
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.STACK_OVERFLOW);
}

def test_stack_overflow2(i: ExeTester) {
	i.addLocals(2000, ValueType.I32);
	i.code([Opcode.CALL.code, 0]);
	i.max_call_depth = 10;
	i.assert_trap([Value.I32(0), Value.I32(2)], TrapReason.STACK_OVERFLOW);
}

def test_sign_ext(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_EXTEND8_S.code]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 1);
	i.assert_i_i(127, 127);
	i.assert_i_i(0x80, 0xFFFFFF80);
	i.assert_i_i(0x100, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_EXTEND16_S.code]);
	i.assert_i_i(0, 0);
	i.assert_i_i(1, 1);
	i.assert_i_i(127, 127);
	i.assert_i_i(0x82, 0x82);
	i.assert_i_i(0x8030, 0xFFFF8030);
	i.assert_i_i(0x10000, 0);

	i.sig(SigCache.l_l);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND8_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(127, 127);
	i.assert_l_l(0x87, 0xFFFFFFFFFFFFFF87);
	i.assert_l_l(0x300, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND16_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(0x7FFF, 0x7FFF);
	i.assert_l_l(0x19a, 0x19a);
	i.assert_l_l(0x8720, 0xFFFFFFFFFFFF8720);
	i.assert_l_l(0x50000, 0);

	i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_EXTEND32_S.code]);
	i.assert_l_l(0, 0);
	i.assert_l_l(1, 1);
	i.assert_l_l(0x7FFF, 0x7FFF);
	i.assert_l_l(0x7FFF1234, 0x7FFF1234);
	i.assert_l_l(0x19a, 0x19a);
	i.assert_l_l(0x8720abcd, 0xFFFFFFFF8720abcd);
}

def test_reinterpret(i: ExeTester) {
	for (bits in [0x11223344u, 0x55662233u]) {
		i.sig(SigCache.f_i);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_REINTERPRET_F32.code]);
		i.assert_r([Value.F32(bits)], Result.Value([Value.I32(bits)]));

		i.sig(SigCache.i_f);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.F32_REINTERPRET_I32.code]);
		i.assert_r([Value.I32(bits)], Result.Value([Value.F32(bits)]));
	}
	for (bits in [0x1122334455667788u, 0x5566223344117799u]) {
		i.sig(SigCache.d_l);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.I64_REINTERPRET_F64.code]);
		i.assert_r([Value.F64(bits)], Result.Value([Value.I64(bits)]));

		i.sig(SigCache.l_d);
		i.code([Opcode.LOCAL_GET.code, 0, Opcode.F64_REINTERPRET_I64.code]);
		i.assert_r([Value.I64(bits)], Result.Value([Value.F64(bits)]));
	}
}

def test_invalid(i: ExeTester) {
	i.sig(SigCache.i_i);
	i.code([Opcode.LOCAL_GET.code, 0, 0xFF]);
	i.assert_r([Values.i_v(33)], Traps.result(TrapReason.INVALID_OPCODE));

	for (page in Opcodes.code_pages) {
		if (page.prefix == 0xFD) continue; // TODO: SIMD space fully filled?
		i.code([Opcode.LOCAL_GET.code, 0, page.prefix, 0x7F]);
		i.assert_r([Values.i_v(37)], Traps.result(TrapReason.INVALID_OPCODE));
	}
}

def test_extleb(i: ExeTester) {
	i.sig(SigCache.f_i);
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.I32_TRUNC_SAT_F32_S.prefix,
		Opcode.I32_TRUNC_SAT_F32_S.code | byte.!(0x80u), // manually extended LEB
		0]);
	i.assert_r([Value.F32(Floats.f_1p31)], Result.Value([Values.i_v(i32.max)]));
}

// TODO: tests for multi-value block, if, loop
// TODO: tests for multi-value return
// TODO: tests for block, if, loop with value args
// TODO: lots more tests for br_table
// TODO: tests for multi_memory

def test_ref_default(i: ExeTester) {
	i.extensions |= Extension.GC;
	for (t in [ValueTypes.ANYREF, ValueTypes.I31REF, ValueTypes.FUNCREF, ValueTypes.EXTERNREF]) {
		i.sig(newSig(SigCache.arr_v, [t]));
		i.addLocal(t);
		i.code([Opcode.LOCAL_GET.code, 0]);
		i.assert_v(X, Values.REF_NULL);
	}
}

def test_ref_null_extern(i: ExeTester) {
	i.sig(SigCache.v_e);
	i.code([Opcode.REF_NULL.code, BpTypeCode.EXTERNREF.code]);
	i.assert_v(X, Values.REF_NULL);
}

def test_ref_null_func(i: ExeTester) {
	i.sig(SigCache.v_g);
	i.code([Opcode.REF_NULL.code, BpTypeCode.FUNCREF.code]);
	i.assert_v(X, Values.FUNCREF_NULL);
}

def test_ref_is_null(i: ExeTester) {
	// externs
	i.sig(SigCache.e_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.REF_IS_NULL.code]);
	i.assert_v([Values.REF_NULL], Values.I32_1);
	i.assert_v([Value.Ref(null)], Values.I32_1);
	i.assert_v([Value.Ref(HostObject.new())], Values.I32_0);
	// funcs
	i.sig(SigCache.g_i);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.REF_IS_NULL.code]);
	i.assert_v([Values.FUNCREF_NULL], Values.I32_1);
	i.assert_v([Value.Ref(Function.new(SigCache.i_i))], Values.I32_0);
}

def test_ref_func(i: ExeTester) {
	i.sig(SigCache.v_g);
	i.code([Opcode.REF_FUNC.code, 0]);
	i.assert_g(X, 0);
}

def test_ref_as_non_null(i: ExeTester) {
	i.sig(SigCache.r_r);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_AS_NON_NULL.code]);
	i.assert_trap([Values.REF_NULL], TrapReason.NULL_DEREF);
	var f = Function.new(SigCache.i_i);
	i.assert_v([Value.Ref(f)], Value.Ref(f));
}

def test_memory_init(i: ExeTester) {
	i.sig(SigCache.iii_v);
	i.addMemory(1, Max.Set(1));
	i.addPassiveData([11, 22, 33, 44, 55]);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.MEMORY_INIT.prefix, Opcode.MEMORY_INIT.code, 0, 0
	]);
	i.assert_mem(uuu(0, 0, 5), 0, [11, 22, 33, 44, 55]);
	i.assert_mem(uuu(0, 1, 3), 0, [22, 33, 44, 0]);
	i.assert_mem(uuu(1, 2, 3), 0, [0, 33, 44, 55, 0]);
	i.assert_trap(uuu(65533, 0, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 0, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(1, 0, 6), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(1, 2, 5), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0xFFFFFFF0, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
}

def test_data_drop(i: ExeTester) {
	i.sig(SigCache.v_v);
	i.addMemory(1, Max.Set(1));
	i.addData(0, [0]);
	i.code([Opcode.DATA_DROP.prefix, Opcode.DATA_DROP.code, 0]);
	var t = i.run(X), instance = t.0;
	if (instance.dropped_data[0] != true) i.t.fail("expected dropped data[0]");
}

def uuu(a: u32, b: u32, c: u32) -> Array<Value> {
	return [Value.I32(a), Value.I32(b), Value.I32(c)];
}

def test_memory_copy(i: ExeTester) {
	i.sig(SigCache.iii_v);
	i.addMemory(1, Max.Set(1));
	var init: Array<byte> = [33, 44, 55];
	i.addData(3, init);
	i.code([Opcode.MEMORY_COPY.prefix, Opcode.MEMORY_COPY.code, 0, 0]);
	i.assert_mem(uuu(0, 0, 0), 3, init);
	i.assert_mem(uuu(0, 2, 5), 0, [0, 33, 44, 55, 0, 55, 0]);
	i.assert_mem(uuu(7, 3, 3), 0, [0, 0, 0, 33, 44, 55, 0, 33, 44, 55]);
	i.assert_mem(uuu(65533, 3, 3), 65533, [33, 44, 55]);
	i.assert_trap(uuu(65533, 3, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 3, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65533, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65535, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 4), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0xFFFFFFF0, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
}


def test_memory_fill(i: ExeTester) {
	i.sig(SigCache.iii_v);
	i.addMemory(1, Max.Set(1));
	i.code([Opcode.MEMORY_FILL.prefix, Opcode.MEMORY_FILL.code, 0]);
	i.assert_mem(uuu(0, 0, 0), 0, [0]);
	i.assert_mem(uuu(3, 77, 2), 0, [0, 0, 0, 77, 77, 0]);
	i.assert_mem(uuu(4, 99, 4), 0, [0, 0, 0, 0, 99, 99, 99, 99, 0]);
	i.assert_mem(uuu(65536, 99, 0), 0, []);
	i.assert_trap(uuu(65536, 91, 1), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 92, 2), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65537, 93, 1), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65537, 94, 0xFFFFFFF0), TrapReason.MEM_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 95, 0xF0), TrapReason.MEM_OUT_OF_BOUNDS);
}

def test_table_init(i: ExeTester) {
	var f2 = i.newFunction(SigCache.v_v, NO_CODE);
	var f3 = i.newFunction(SigCache.v_v, NO_CODE);
	var f4 = i.newFunction(SigCache.v_v, NO_CODE);
	var f5 = i.newFunction(SigCache.v_v, NO_CODE);
	i.sig(SigCache.iii_v);
	i.addTable(6, 0, null);
	i.addPassiveElems([f2.func_index, f3.func_index, f4.func_index, f5.func_index]);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_INIT.prefix, Opcode.TABLE_INIT.code, 0, 0
	]);
	i.assert_ftable(uuu(0, 0, 0), 0, []);
	i.assert_ftable(uuu(0, 0, 1), 0, [f2]);
	i.assert_ftable(uuu(2, 2, 1), 2, [f4]);
	i.assert_ftable(uuu(0, 0, 4), 0, [f2, f3, f4, f5]);
	i.assert_trap(uuu(0, 0, 5), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0, 1, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_elem_drop(i: ExeTester) {
	i.sig(SigCache.v_v);
	i.addTable(1, 0, [0]);
	i.code([Opcode.ELEM_DROP.prefix, Opcode.ELEM_DROP.code, 0]);
	var t = i.run(X), instance = t.0;
	if (instance.dropped_elems[0] != true) i.t.fail("expected dropped elems[0]");
}

def test_table_get(i: ExeTester) {
	var f2 = i.newFunction(SigCache.v_v, NO_CODE);
	var f3 = i.newFunction(SigCache.v_v, NO_CODE);
	i.addTable(3, 0, [0, f2.func_index, f3.func_index]);
	i.sig0(SigCache.arr_i, [ValueTypes.FUNCREF]);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.TABLE_GET.code, 0]);
	i.assert_g([Value.I32(0)], 0);
	i.assert_g([Value.I32(1)], f2.func_index);
	i.assert_g([Value.I32(2)], f3.func_index);
	i.assert_trap([Value.I32(3)], TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_table_set(i: ExeTester) {
	var f2 = i.newFunction(SigCache.v_v, NO_CODE);
	var f3 = i.newFunction(SigCache.v_v, NO_CODE);
	i.addTable(3, 0, [0, f2.func_index, f3.func_index]);
	i.sig0([ValueType.I32, ValueTypes.FUNCREF], SigCache.arr_v);
	i.code([Opcode.LOCAL_GET.code, 0, Opcode.LOCAL_GET.code, 1, Opcode.TABLE_SET.code, 0]);

	var gv1 = Value.Ref(WasmFunction.new(null, f3));
	var t = i.run([Value.I32(1), gv1]), instance = t.0;
	var got = instance.tables[0].elems[1];
	if (gv1 != got) i.t.fail("wrong table[1] value");

	i.assert_trap([Value.I32(3), gv1], TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_table_copy(i: ExeTester) {
	var f2 = i.newFunction(SigCache.v_v, NO_CODE);
	var f3 = i.newFunction(SigCache.v_v, NO_CODE);
	i.addTable(6, 0, []);
	i.addTable(3, 0, [0, f2.func_index, f3.func_index]);

	i.sig(SigCache.iii_v);
	i.code([Opcode.TABLE_COPY.prefix, Opcode.TABLE_COPY.code, 0, 1]);
	i.assert_ftable(uuu(0, 0, 1), 0, [i.func, null, null]);
	i.assert_ftable(uuu(1, 2, 1), 0, [null, f3, null]);
	i.assert_ftable(uuu(3, 0, 3), 0, [null, null, null, i.func, f2, f3]);

	i.assert_trap(uuu(65533, 3, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(65535, 3, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65533, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 65535, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 4), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(0xFFFFFFF0, 3, 0xF0), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uuu(3, 0xFFFFFFF0, 0xF0), TrapReason.TABLE_OUT_OF_BOUNDS);
}

def test_table_grow1(i: ExeTester) {
	i.addTableOfSize(3, Max.Set(5));
	i.sig0([ValueTypes.FUNCREF, ValueType.I32], SigCache.arr_i);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0
	]);
	var n = Values.FUNCREF_NULL;
	i.assert_v([n, Value.I32(1)], Value.I32(3));
	i.assert_v([n, Value.I32(2)], Value.I32(3));
	i.assert_v([n, Value.I32(3)], Value.I32(0xFFFFFFFF));

	i.sig0([ValueTypes.FUNCREF, ValueType.I32], SigCache.arr_v);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0,
		Opcode.DROP.code
	]);
	var fv = Value.Ref(WasmFunction.new(null, i.func));
	i.assert_ftable([fv, Value.I32(1)], 0, [null, null, null, i.func]);
	i.assert_ftable([fv, Value.I32(2)], 0, [null, null, null, i.func, i.func]);
}

def test_table_grow2(i: ExeTester) {
	i.addTableOfSize(3, Max.None);
	i.sig0([ValueTypes.FUNCREF, ValueType.I32], SigCache.arr_i);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.TABLE_GROW.prefix, Opcode.TABLE_GROW.code, 0
	]);
	var n = Values.FUNCREF_NULL;
	i.assert_v([n, Value.I32(GlobalLimits.limit_table_size + 1)], Value.I32(0xFFFFFFFF));
}

def test_table_size(i: ExeTester) {
	i.addTable(3, 0, [0, 0, 0]);
	i.sig(SigCache.v_i);
	i.code([Opcode.TABLE_SIZE.prefix, Opcode.TABLE_SIZE.code, 0]);
	i.assert_i(3);
}

def uvu(a: u32, b: Value, c: u32) -> Array<Value> {
	return [Value.I32(a), b, Value.I32(c)];
}

def test_table_fill(i: ExeTester) {
	i.sig(SigDecl.new(ValueTypes.NO_HEAPTYPES, [ValueType.I32, ValueTypes.FUNCREF, ValueType.I32], SigCache.arr_v));
	i.addTable(6, 0, []);
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.TABLE_FILL.prefix, Opcode.TABLE_FILL.code, 0
	]);
	var f1 = Value.Ref(WasmFunction.new(null, i.func));
	i.assert_ftable(uvu(0, f1, 0), 0, [null]);
	i.assert_ftable(uvu(1, f1, 1), 0, [null, i.func]);
	i.assert_ftable(uvu(3, f1, 2), 0, [null, null, null, i.func, i.func]);
	i.assert_ftable(uvu(4, f1, 2), 0, [null, null, null, null, i.func, i.func]);
	i.assert_trap(uvu(5, f1, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(6, f1, 1), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65536, f1, 1), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65535, f1, 2), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65537, f1, 1), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(65537, f1, 0xFFFFFFF0), TrapReason.TABLE_OUT_OF_BOUNDS);
	i.assert_trap(uvu(0xFFFFFFF0, f1, 0xF0), TrapReason.TABLE_OUT_OF_BOUNDS);
}
def test_nans(i: ExeTester) {
	// TODO: test all nan cases for all bytecodes
	i.code_op(Opcode.F32_SQRT);
	i.assert_nan([Value.F32(0xc2c60000)]);

	i.code_op(Opcode.F64_SQRT);
	i.assert_nan([Value.F64(0xc08c100000000000)]);
}

def test_host_tail_call1(t: ExeTester) {
	t.sig(SigCache.i_i);
	t.code([Opcode.LOCAL_GET.code, 0, Opcode.I32_CONST.code, 5, Opcode.I32_ADD.code]);
	var instance = Instantiator.new(t.extensions, t.module, [], ErrorGen.new("InterpreterTest.v3")).run();
	var f = instance.functions[0];

	def fw = HostResult.TailCall(f, _);
	def hf = HostFunctionN.new(null, SigCache.i_i, fw);

	t.assert_req(Execute.call(hf, [Value.I32(44)]), Result.Value([Value.I32(49)]));
	t.assert_req(Execute.call(hf, [Value.I32(999)]), Result.Value([Value.I32(1004)]));
}

def add(args: Array<Value>) -> HostResult {
	var a = Values.v_u(args[0]);
	var b = Values.v_u(args[1]);
	return HostResult.Value1(Value.I32(a + b));
}

def test_host_tail_call2(t: ExeTester) {
	def fw = HostResult.TailCall(HostFunctionN.new("add", SigCache.ii_i, add), _);
	def hf = HostFunctionN.new("wrap", SigCache.ii_i, fw);

	t.assert_req(Execute.call(hf, [Value.I32(44), Value.I32(66)]), Result.Value([Value.I32(110)]));
	t.assert_req(Execute.call(hf, [Value.I32(909), Value.I32(90)]), Result.Value([Value.I32(999)]));
}

def heapIndexByte(ht: HeapTypeDecl) -> byte {
	return byte.!(ht.heaptype_index);
}

def I32_FIELD = StorageType(ValueType.I32, Packedness.UNPACKED, true);

def test_struct_new(t: ExeTester) {
	var st = t.newStruct([I32_FIELD]);
	t.extensions |= Extension.GC;
	t.sig0(SigCache.arr_i, [ValueTypes.RefStruct(false, st)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.STRUCT_NEW_CANON.prefix,
		Opcode.STRUCT_NEW_CANON.code,
		heapIndexByte(st)
	]);
	for (i in [666u, 777u, 0x88776655u]) {
		var vals: Array<Value> = [Value.I32(i)];
		t.assert_struct(t.run(vals).1, st, null, vals);
	}
}

def test_struct_new_default(t: ExeTester) {
	var st = t.newStruct([
		I32_FIELD,
		StorageType(ValueType.F32, Packedness.UNPACKED, true),
		StorageType(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.extensions |= Extension.GC;
	t.sig0(SigCache.arr_v, [ValueTypes.RefStruct(false, st)]);
	t.codev([
		Opcode.STRUCT_NEW_CANON_DEFAULT.prefix,
		Opcode.STRUCT_NEW_CANON_DEFAULT.code,
		heapIndexByte(st)
	]);
	var rtt = (st);
	for (i < 2) {
		t.assert_struct(t.run([]).1, st, rtt, [Values.I32_0, Values.F32_0, Values.F64_0]);
	}
}

def test_struct_get(t: ExeTester) {
	var st = t.newStruct([
		I32_FIELD,
		I32_FIELD,
		I32_FIELD
	]);
	t.extensions |= Extension.GC;
	t.sig0([ValueTypes.RefStruct(false, st)], SigCache.arr_i);
	var obj = HeapStruct.new(st, [Value.I32(99), Value.I32(98), Value.I32(97)]);
	for (f < st.field_types.length) {
		t.codev([
			Opcode.LOCAL_GET.code, 0,
			Opcode.STRUCT_GET.prefix, Opcode.STRUCT_GET.code,
			heapIndexByte(st), byte.view(f)
		]);
		for (i in [366u, 2777u, 0x18776655u]) {
			obj.vals[f] = Value.I32(i);
			t.assert_v([Value.Ref(obj)], Values.u_v(i));
		}
	}
}

def unpackI32(val: u32, packing: Packedness, signed: bool) -> u32 {
	var shift: u5 = if(packing == Packedness.PACKED_I8, 24, 16);
	val = val << shift;
	return if(signed, u32.view(i32.view(val) >> shift), val >> shift);
}

def test_struct_get_su(t: ExeTester) {
	t.extensions |= Extension.GC;
	var st = t.newStruct([
		StorageType(ValueType.I32, Packedness.PACKED_I8, true),
		StorageType(ValueType.I32, Packedness.PACKED_I16, true)
	]);
	t.sig0([ValueTypes.RefStruct(false, st)], SigCache.arr_i);

	var vals: Array<u32> = [0x87, 0x9765];
	var obj = HeapStruct.new(st, [Value.I32(vals[0]), Value.I32(vals[1])]);
	for (f < 2) {
		var shift: u5 = if(f == 0, 24, 16);
		for (opcode in [Opcode.STRUCT_GET_S, Opcode.STRUCT_GET_U]) {
			t.codev([
				Opcode.LOCAL_GET.code, 0,
				opcode.prefix, opcode.code,
				heapIndexByte(st), byte.view(f)
			]);
			var expected = unpackI32(vals[f], st.field_types[f].packing, opcode == Opcode.STRUCT_GET_S);
			t.assert_req(t.run([Value.Ref(obj)]).1, u_r(expected));
		}
	}
}

def test_struct_set(t: ExeTester) {
	t.extensions |= Extension.GC;
	var st = t.newStruct([
		I32_FIELD,
		I32_FIELD,
		I32_FIELD
	]);
	t.sig0([ValueTypes.RefStruct(false, st), ValueType.I32], SigCache.arr_v);
	var obj = HeapStruct.new(st, [Value.I32(99), Value.I32(98), Value.I32(97)]);
	for (f < st.field_types.length) {
		t.codev([
			Opcode.LOCAL_GET.code, 0,
			Opcode.LOCAL_GET.code, 1,
			Opcode.STRUCT_SET.prefix, Opcode.STRUCT_SET.code,
			heapIndexByte(st), byte.view(f)
		]);
		for (i in [366u, 2777u, 0x18776655u]) {
			var prev = Arrays.dup(obj.vals);
			var got = t.run([Value.Ref(obj), Values.u_v(i)]).1;
			t.assert_req(got, Result.Value([]));
			prev[f] = Values.u_v(i);
			t.t.assertar("fields", prev, obj.vals, Value.render);
		}
	}
}

def test_array_new(t: ExeTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([I32_FIELD]);
	t.sig0(SigCache.arr_i, [ValueTypes.RefArray(false, at)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_NEW_CANON.prefix, Opcode.ARRAY_NEW_CANON.code, heapIndexByte(at)
	]);
	for (i < 5u) {
		var v = Value.I32(i);
		var r = t.run([v]);
		var expected = Array<Value>.new(int.view(i));
		for (j < i) expected[j] = v;
		t.assert_array(r.1, at, null, expected);
	}
}

def test_array_new_default(t: ExeTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType(ValueType.F32, Packedness.UNPACKED, true)
	]);
	t.sig0(SigCache.arr_i, [ValueTypes.RefArray(false, at)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_NEW_CANON_DEFAULT.prefix, Opcode.ARRAY_NEW_CANON_DEFAULT.code, heapIndexByte(at)
	]);
	var rtt = (at);
	for (i < 5u) {
		var r = t.run([Value.I32(i)]);
		var expected = Array<Value>.new(int.view(i));
		for (j < i) expected[j] = Values.F32_0;
		t.assert_array(r.1, at, rtt, expected);
	}
}

def test_array_get(t: ExeTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueTypes.RefArray(false, at), ValueType.I32], SigCache.arr_d);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.ARRAY_GET.prefix, Opcode.ARRAY_GET.code, heapIndexByte(at)
	]);
	for (len < 5) {
		var elems = Array<Value>.new(len);
		var obj = Value.Ref(HeapArray.new(at, elems));
		for (j < len) elems[j] = Value.F64(0x99u + u32.view(len));

		for (i < len) {
			var r = t.run([obj, Value.I32(u32.view(i))]);
			t.assert_req(r.1, Result.Value([elems[i]]));
		}
		t.assert_trap([obj, Value.I32(99)], TrapReason.ARRAY_INDEX_OOB);
		t.assert_trap([obj, Value.I32(0x80000000u)], TrapReason.ARRAY_INDEX_OOB);
		t.assert_trap([obj, Value.I32(u32.max)], TrapReason.ARRAY_INDEX_OOB);
	}
	t.assert_trap([Value.Ref(null), Values.I32_0], TrapReason.NULL_DEREF);
}

def test_array_get_su(t: ExeTester) {
	t.extensions |= Extension.GC;
	for (packing in [Packedness.PACKED_I8, Packedness.PACKED_I16]) {
		var at = t.newArray([
			StorageType(ValueType.I32, packing, true)
		]);

		t.sig0([ValueTypes.RefArray(false, at), ValueType.I32], SigCache.arr_i);
		for (opcode in [Opcode.ARRAY_GET_S, Opcode.ARRAY_GET_U]) {
			t.codev([
				Opcode.LOCAL_GET.code, 0,
				Opcode.LOCAL_GET.code, 1,
				opcode.prefix, opcode.code, heapIndexByte(at)
			]);
			for (len < 5) {
				var elems = Array<Value>.new(len);
				var obj = Value.Ref(HeapArray.new(at, elems));
				for (j < len) elems[j] = Value.I32(0xFF7Fu + u32.view(j));

				for (i < len) {
					var r = t.run([obj, Value.I32(u32.view(i))]);
					var expected = unpackI32(Values.v_u(elems[i]), packing, opcode == Opcode.ARRAY_GET_S);
					t.assert_req(r.1, Result.Value([Value.I32(expected)]));
				}
				t.assert_trap([obj, Value.I32(99)], TrapReason.ARRAY_INDEX_OOB);
				t.assert_trap([obj, Value.I32(0x80000000u)], TrapReason.ARRAY_INDEX_OOB);
				t.assert_trap([obj, Value.I32(u32.max)], TrapReason.ARRAY_INDEX_OOB);
			}
			t.assert_trap([Value.Ref(null), Values.I32_0], TrapReason.NULL_DEREF);
		}
	}
}

def test_array_set(t: ExeTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueTypes.RefArray(false, at), ValueType.I32, ValueType.F64], SigCache.arr_v);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.LOCAL_GET.code, 2,
		Opcode.ARRAY_SET.prefix, Opcode.ARRAY_SET.code, heapIndexByte(at)
	]);
	var obj = HeapArray.new(at, [Value.F64(0x99999), Value.F64(55)]);
	var ref = Value.Ref(obj);
	for (i < obj.vals.length) {
		for (v in [366u, 2777u, 0x18776655u]) {
			var prev = Arrays.dup(obj.vals);
			var got = t.run([ref, Value.I32(u32.view(i)), Value.F64(v)]).1;
			t.assert_req(got, Result.Value([]));
			prev[i] = Value.F64(v);
			t.t.assertar("elems", prev, obj.vals, Value.render);
		}
	}
	t.assert_trap([ref, Value.I32(99), Values.F64_0], TrapReason.ARRAY_INDEX_OOB);
	t.assert_trap([Value.Ref(null), Values.I32_0, Values.F64_0], TrapReason.NULL_DEREF);
}

def test_array_len(t: ExeTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType(ValueType.F64, Packedness.UNPACKED, true)
	]);
	t.sig0([ValueTypes.RefArray(false, at)], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.ARRAY_LEN.prefix, Opcode.ARRAY_LEN.code, heapIndexByte(at)
	]);
	for (i < 5) {
		var obj = Value.Ref(HeapArray.new(at, Array<Value>.new(i)));
		var r = t.run([obj]);
		t.assert_req(r.1, i_r(i));
	}
	t.assert_trap([Value.Ref(null)], TrapReason.NULL_DEREF);
}

def test_array_new_fixed(t: ExeTester) {
	t.extensions |= Extension.GC;
	var at = t.newArray([
		StorageType(ValueType.I64, Packedness.UNPACKED, true)
	]);

	var code = Vector<byte>.new();
	var params = Vector<ValueType>.new();
	var args = Vector<Value>.new();
	var results: Array<ValueType> = [ValueTypes.RefArray(false, at)];
	var rtt_obj = (at);
	for (i < byte.view(5)) {
		var v = Value.I64(9999999u + i);
		for (j < i) {
			code.put(Opcode.LOCAL_GET.code).put(j);
			params.put(ValueType.I64);
			args.put(v);
		}
		code.puta([Opcode.ARRAY_NEW_CANON_FIXED.prefix, Opcode.ARRAY_NEW_CANON_FIXED.code, heapIndexByte(at), i]);
		var expected = args.copy();

		t.sig0(params.extract(), results);
		t.codev(code.extract());
		var r =  t.run(args.extract());
		t.assert_array(r.1, at, rtt_obj, expected);
	}
}

def test_i31_new(t: ExeTester) {
	t.extensions |= Extension.GC;
	t.sig0(SigCache.arr_i, [ValueTypes.I31REF]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_NEW.prefix, Opcode.I31_NEW.code
	]);
	for (v in [0x8u, 0x99u, 0x12345678u, 0x87654321u]) {
		t.assert_v([Value.I32(v)], Value.I31(u31.view(v)));
	}
}

def test_i31_get_s(t: ExeTester) {
	t.extensions |= Extension.GC;
	t.sig0([ValueTypes.I31REF], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_GET_S.prefix, Opcode.I31_GET_S.code
	]);
	for (v in [0x8u, 0x99u, 0x12345678u, 0x80000000u, 0xF7654321u]) {
		var ext = (i32.view(v) << 1) >> 1;
		t.assert_v([Value.I31(u31.view(v))], Value.I32(u32.view(ext)));
	}
	t.assert_trap([Values.REF_NULL], TrapReason.NULL_DEREF);
}

def test_i31_get_u(t: ExeTester) {
	t.extensions |= Extension.GC;
	t.sig0([ValueTypes.I31REF], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.I31_GET_U.prefix, Opcode.I31_GET_U.code
	]);
	for (v in [0x8u, 0x99u, 0x12345678u, 0x80000000u, 0xF7654321u]) {
		var ext = (u32.view(v) << 1) >> 1;
		t.assert_v([Value.I31(u31.view(v))], Value.I32(u32.view(ext)));
	}
	t.assert_trap([Values.REF_NULL], TrapReason.NULL_DEREF);
}

class RttTestVals(t: ExeTester) {
	def st1 = t.newStruct([]);
	def st2 = t.newStructP([st1], [I32_FIELD]);
	def rtt1 = (st1);
	def rtt2a = (st2);

	def o1 = Value.Ref(HeapStruct.new(rtt1, []));
	def o2a = Value.Ref(HeapStruct.new(rtt2a, [Values.I32_0]));
}

def test_ref_test(t: ExeTester) {
	t.extensions |= Extension.GC;
	var x = RttTestVals.new(t);
	t.sig0([ValueTypes.RefStruct(false, x.st1)], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_TEST.prefix, Opcode.REF_TEST.code,
		heapIndexByte(x.st1)
	]);

	t.assert_v([Values.REF_NULL], Values.I32_0);
	t.assert_v([x.o1], Values.I32_1);
	t.assert_v([x.o2a], Values.I32_1);
}

def test_ref_test_null(t: ExeTester) {
	t.extensions |= Extension.GC;
	var x = RttTestVals.new(t);
	t.sig0([ValueTypes.RefStruct(true, x.st1)], SigCache.arr_i);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_TEST_NULL.prefix, Opcode.REF_TEST_NULL.code,
		heapIndexByte(x.st1)
	]);

	t.assert_v([Values.REF_NULL], Values.I32_1);
	t.assert_v([x.o1], Values.I32_1);
	t.assert_v([x.o2a], Values.I32_1);
}

def test_ref_cast(t: ExeTester) {
	t.extensions |= Extension.GC;
	var x = RttTestVals.new(t);
	t.sig0([ValueTypes.RefStruct(false, x.st1)], [ValueTypes.RefStruct(false, x.st2)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_CAST.prefix, Opcode.REF_CAST.code, heapIndexByte(x.st2)
	]);

	var fail = TrapReason.FAILED_CAST;
	t.assert_trap([Values.REF_NULL], fail);
	t.assert_trap([x.o1], fail);
	t.assert_v([x.o2a], x.o2a);
}

def test_ref_cast_null(t: ExeTester) {
	t.extensions |= Extension.GC;
	var x = RttTestVals.new(t);
	t.sig0([ValueTypes.RefStruct(true, x.st1)], [ValueTypes.RefStruct(true, x.st2)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.REF_CAST_NULL.prefix, Opcode.REF_CAST_NULL.code, heapIndexByte(x.st2)
	]);

	var fail = TrapReason.FAILED_CAST;
	t.assert_v([Values.REF_NULL], Values.REF_NULL);
	t.assert_trap([x.o1], fail);
	t.assert_v([x.o2a], x.o2a);
}

def test_br_on_cast(t: ExeTester) {
	t.extensions |= Extension.GC;
	def x = RttTestVals.new(t);

	t.sig0([ValueTypes.RefStruct(false, x.st1)], [ValueTypes.RefStruct(false, x.st2)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_CAST.prefix, Opcode.BR_ON_CAST.code, 0, heapIndexByte(x.st2),
		Opcode.UNREACHABLE.code
	]);
	var fail = TrapReason.UNREACHABLE;
	t.assert_trap([Values.REF_NULL], fail);
	t.assert_trap([x.o1], fail);
	t.assert_v([x.o2a], x.o2a);
}

def test_br_on_cast_null(t: ExeTester) {
	t.extensions |= Extension.GC;
	def x = RttTestVals.new(t);

	t.sig0([ValueTypes.RefStruct(true, x.st1)], [ValueTypes.RefStruct(true, x.st2)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_CAST_NULL.prefix, Opcode.BR_ON_CAST_NULL.code, 0, heapIndexByte(x.st2),
		Opcode.UNREACHABLE.code
	]);
	var fail = TrapReason.UNREACHABLE;
	t.assert_v([Values.REF_NULL], Values.REF_NULL);
	t.assert_trap([x.o1], fail);
	t.assert_v([x.o2a], x.o2a);
}

def test_br_on_cast_fail(t: ExeTester) {
	t.extensions |= Extension.GC;
	def x = RttTestVals.new(t);

	t.sig0([ValueTypes.RefStruct(false, x.st1)], [ValueTypes.RefStruct(false, x.st1)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_CAST.prefix, Opcode.BR_ON_CAST_FAIL.code, 0, heapIndexByte(x.st2),
		Opcode.UNREACHABLE.code
	]);
	var fail = TrapReason.UNREACHABLE;
	t.assert_v([Values.REF_NULL], Values.REF_NULL);
	t.assert_v([x.o1], x.o1);
	t.assert_trap([x.o2a], fail);
}

def test_br_on_cast_fail_null(t: ExeTester) {
	t.extensions |= Extension.GC;
	def x = RttTestVals.new(t);

	t.sig0([ValueTypes.RefStruct(true, x.st1)], [ValueTypes.RefStruct(true, x.st1)]);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_CAST_NULL.prefix, Opcode.BR_ON_CAST_FAIL_NULL.code, 0, heapIndexByte(x.st2),
		Opcode.UNREACHABLE.code
	]);
	var fail = TrapReason.UNREACHABLE;
	t.assert_trap([Values.REF_NULL], fail);
	t.assert_v([x.o1], x.o1);
	t.assert_trap([x.o2a], fail);
}

def test_br_on_null(t: ExeTester) {
	t.extensions |= Extension.FUNCTION_REFERENCES;

	t.sig(SigCache.r_i);
	t.codev([
		Opcode.I32_CONST.code, 11,
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_NULL.code, 0,
		Opcode.UNREACHABLE.code
	]);

	t.assert_v([Values.REF_NULL], Values.i_v(11));
	t.assert_trap([Value.Ref(HostObject.new())], TrapReason.UNREACHABLE);
}

def test_br_on_non_null(t: ExeTester) {
	t.extensions |= Extension.FUNCTION_REFERENCES;

	t.sig(SigCache.r_r);
	t.codev([
		Opcode.LOCAL_GET.code, 0,
		Opcode.BR_ON_NON_NULL.code, 0,
		Opcode.UNREACHABLE.code
	]);

	t.assert_trap([Values.REF_NULL], TrapReason.UNREACHABLE);
	var v = Value.Ref(HostObject.new());
	t.assert_v([v], v);
}

def test_ref_eq(t: ExeTester) {
	t.extensions |= Extension.GC;

	t.sig(SigCache.rr_i);
	t.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.REF_EQ.code
	]);

	var nil = Values.REF_NULL, obj1 = Value.Ref(HostObject.new()), obj2 = Value.Ref(HostObject.new());
	t.assert_v([nil, nil], Values.I32_1);
	t.assert_v([obj1, nil], Values.I32_0);
	t.assert_v([nil, obj1], Values.I32_0);
	t.assert_v([obj1, obj1], Values.I32_1);
	t.assert_v([obj1, obj2], Values.I32_0);
	t.assert_v([obj2, obj2], Values.I32_1);
}

def test_abstype_default(t: ExeTester) {
	var cases = [
		(ValueType.I32, Values.I32_0),
		(ValueType.F32, Values.F32_0),
		(ValueTypes.ANYREF, Values.REF_NULL),
		(ValueTypes.EXTERNREF, Values.REF_NULL)
	];
	t.extensions |= Extension.TYPE_IMPORTS;

	for (c in cases) {
		var module = Module.new(null);
		var abs = AbsTypeDecl.new(true, c.0 == ValueTypes.EXTERNREF, []);
		var at = ValueType.Abstract(abs);
		var sig = SigDecl.new(ValueTypes.NO_HEAPTYPES, SigCache.arr_v, [at]);
		module.addDecl(abs);
		module.addImport("foo", "bar", [], abs);
		module.addDecl(sig);
		var func = FuncDecl.new(sig.heaptype_index);
		module.addDecl(func);
		func.setOrigCode([
			1,
			1, BpTypeCode.ABS.code, byte.!(abs.abstype_index),
			Opcode.LOCAL_GET.code, 0,
			Opcode.END.code
		]);

		func.num_locals = 1;
		var err = ErrorGen.new("ExeTester.v3");
		var instance = Instantiator.new(t.extensions, module, [ExportedValueType.new(null, c.0)], err).run();
		t.t.assertz(false, err.error());
		if (instance == null) return t.t.fail("instantiation failed");

		var f = instance.functions[0];
		t.assert_req(Execute.call(f, []), Result.Value([c.1]));
	}
}

def test_force_gc_callback(a: Value, b: Value) -> HostResult {
	// Allocations and forced GCs help randomize the heap layout to catch bugs in walking interpreter frames
	var x = [a, b];
	Target.forceGC();
	var y = [a, b];
	Target.forceGC();
	var z = [a, b];
	Target.forceGC();
	if (x[0] != y[0]) return HostResult.Value1(Values.i_v(-1));
	if (x[1] != y[1]) return HostResult.Value1(Values.i_v(-2));
	if (x[0] != z[0]) return HostResult.Value1(Values.i_v(-3));
	if (x[1] != z[1]) return HostResult.Value1(Values.i_v(-4));
	return HostResult.Value1(Values.i_v(99 - Values.v_i(a) - Values.v_i(b)));
}

def test_force_gc1(i: ExeTester) {
	var sig = i.newSig(SigCache.arr_ii, SigCache.arr_i);
	i.sig(sig);
	var fd = i.newFunc(sig);
	i.module.addImport("", "", [], fd);
	i.imports = [HostFunction2.new("test_force_gc_callback", sig, test_force_gc_callback)];
	i.code([Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, byte.!(fd.func_index)]);

	i.assert_ii_i((44, 33), 22);
	i.assert_ii_i((1090909, 0xFAAA0123), 88431075);
}

def test_force_gc_callback2(a: Value) -> HostResult {
	// Allocations and forced GCs help randomize the heap layout to catch bugs in walking interpreter frames
	var x = [a];
	Target.forceGC();
	var y = [a, a];
	Target.forceGC();
	var z = [a, a, a];
	Target.forceGC();
	return HostResult.Value1(a);
}

def test_force_gc2(i: ExeTester) {
	i.sig(i.newSig(SigCache.arr_r, SigCache.arr_rrr));
	var sig = i.newSig(SigCache.arr_r, SigCache.arr_r);
	var fd = i.newFunc(sig);
	i.module.addImport("", "", [], fd);
	i.imports = [HostFunction1.new("test_force_gc_callback2", sig, test_force_gc_callback2)];
	i.code([
		Opcode.I32_CONST.code, 33,
		Opcode.LOCAL_GET.code, 0,
		Opcode.CALL.code, byte.!(fd.func_index), // local 0 should be scanned by gc
		Opcode.LOCAL_GET.code, 0,
		Opcode.CALL.code, byte.!(fd.func_index), // local 0 should be scanned by gc
		Opcode.LOCAL_GET.code, 0]);

	var r = HeapObject.new(null, Values.NONE), v = Value.Ref(r);
	i.assert_r([v], Result.Value([v, v, v]));
	i.assert_r([v], Result.Value([v, v, v]));
}

def test_internalize(i: ExeTester) {
	i.extensions |= Extension.GC;
	i.sig(newSig([ValueTypes.EXTERNREF], [ValueTypes.ANYREF]));
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.EXTERN_INTERNALIZE.prefix, Opcode.EXTERN_INTERNALIZE.code
	]);
	i.assert_v([Values.REF_NULL], Values.REF_NULL);
	var hostref = Value.Ref(HostObject.new());
	i.assert_v([hostref], hostref);
}

def test_externalize(i: ExeTester) {
	i.extensions |= Extension.GC;
	i.sig(newSig([ValueTypes.ANYREF], [ValueTypes.EXTERNREF]));
	i.code([
		Opcode.LOCAL_GET.code, 0,
		Opcode.EXTERN_INTERNALIZE.prefix, Opcode.EXTERN_INTERNALIZE.code
	]);
	i.assert_v([Values.REF_NULL], Values.REF_NULL);
	var hostref = Value.Ref(HostObject.new());
	var st = i.newStruct([
		I32_FIELD
	]);
	var obj = HeapStruct.new(st, [Value.I32(99)]);
	var internref = Value.Ref(obj);
	i.assert_v([internref], internref);
}
