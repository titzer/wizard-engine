// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("bin:", _, BinParserTester.new, _);

def X: Array<Value>;
var dump = false;  // trace all test modules to console for external comparison

def DEFAULT_LIMITS = Limits.new();
def Z = void(
	T("typecons", test_typecons),
	T("empty", test_empty),
	T("magic", test_magic),
	T("version", test_version),
	T("invalid", test_invalid),
	T("buf_offset", test_buf_offset),
	T("hdr_split", test_hdr_split),
	T("sect_empty", test_sect_empty),
	T("sect_empty_s", test_sect_empty_s),
	T("sect_dup", test_sect_dup),
	T("sect_underflow", test_sect_underflow),
	T("sect_size0", test_sect_size0),
	T("sect_eof", test_sect_eof),
	T("sect_custom1", test_sect_custom1),
	T("sect_custom2", test_sect_custom2),
	T("sect_custom_ovf", test_sect_custom_ovf),
	T("types0", test_types0),
	T("types1", test_types1),
	T("func_max_params", test_func_max_params),
	T("func_max_results", test_func_max_results),
	T("imports0", test_imports0),
	T("imports1", test_imports1),
	T("imports2", test_imports2),
	T("imports3", test_imports3),
	T("funcs0", test_funcs0),
	T("funcs1", test_funcs1),
	T("funcs2", test_funcs2),
	T("tables0", test_tables0),
	T("table_limits", test_table_limits),
	T("memory0", test_memory0),
	T("memory_limits", test_memory_limits),
	T("globals0", test_globals0),
	T("globals1", test_globals1),
	T("globals2", test_globals2),
	T("exports0", test_exports0),
	T("start0", test_start0),
	T("start1", test_start1),
	T("start2", test_start2),
	T("elements0", test_elements0),
	T("elements1", test_elements1),
	T("elements2", test_elements2),
	T("elements3", test_elements3),
	T("elements4", test_elements4),
	T("typesN", test_typesN),
	T("importsN", test_importsN),
	T("funcsN", test_funcsN),
	T("tablesN", test_tablesN),
	T("memoriesN", test_memoriesN),
	T("globalsN", test_globalsN),
	T("exportsN", test_exportsN),
	T("elementsN", test_elementsN),
	T("dataN", test_dataN),
	T("code0", test_code0),
	T("code1", test_code1),
	T("code2", test_code2),
	T("code_missing", test_code_missing),
	T("data0", test_data0),
	T("count_limits", test_count_limits),
	T("max_num_memories", test_max_num_memories),
	T("max_num_tables", test_max_num_tables),
	T("data_count", test_data_count),
	T("repeat_types1", test_repeat_types1),
	T("repeat_types2", test_repeat_types2),
	T("repeat_funcs1", test_repeat_funcs1),
	T("repeat_funcs2", test_repeat_funcs2),
	T("repeat_imports1", test_repeat_imports1),
	T("repeat_imports2", test_repeat_imports2),
	T("func_ref_types0", test_func_ref_types0),
	T("func_ref_types1", test_func_ref_types1),
	T("recgrp0", test_recgrp0),
	T("recgrp1", test_recgrp1),
	T("recgrp2", test_recgrp2),
	T("recgrp3", test_recgrp3),
	T("sub0", test_sub0),
	T("sub1", test_sub1),
	T("sub2", test_sub2),
	T("bad_sub0", test_bad_sub0),
	T("bad_sub1", test_bad_sub1),
	T("bad_sub2", test_bad_sub2),
	T("bad_sub3", test_bad_sub3),
	// TODO: tests for proper decoding of struct and array types
	()
);

def doDump(raw: Array<byte>, pos: int, length: int) {
	var buf = StringBuilder.new();
	buf.puts("[");
	for (i = pos; i < pos + length; i++) {
		if (i > pos) buf.puts(", ");
		buf.puts("0x");
		buf.putx_8(raw[i]);
	}
	buf.puts("]\n");
	System.puts(buf.extract());
}

class BinParserTester(t: Tester) {
	var extensions: Extension.set;
	var limits = Limits.new();
	var test_split: bool = false;
	var validate_code = false;
	def valid(raw: Array<byte>) -> Module {
		return validN(raw, 0, raw.length);
	}
	def validN(raw: Array<byte>, pos: int, length: int) -> Module {
		if (dump) {
			System.puts("<valid> ");
			doDump(raw, pos, length);
		}
		if (test_split) {
			// Test split modules at every offset.
			var last: Module;
			for (i < length) {
				var m = mp();
				m.push(raw, pos, i);
				m.push(raw, pos + i, length - i);
				last = assert_valid(m);
				if (last == null) return null;
			}
			return last;
		}
		// Test only a complete module.
		var m = mp();
		m.push(raw, pos, length);
		return assert_valid(m);
	}
	def invalid(expected: WasmError, raw: Array<byte>) {
		invalidN(expected, (raw, 0, raw.length));
	}
	def invalidN(expected: WasmError, t: (Array<byte>, int, int)) {
		var raw = t.0, pos = t.1, length = t.2;
		if (dump) {
			System.puts(Strings.format1("<invalid:%s> ", expected.name));
			doDump(raw, pos, length);
		}
		if (test_split) {
			// Test split modules at every offset.
			for (i < length) {
				var m = mp();
				m.push(raw, pos, i);
				m.push(raw, pos + i, length - i);
				if (!assert_invalid(expected, m)) return;
			}
			return;
		}
		// Test only a complete module.
		var m = mp();
		m.push(raw, pos, length);
		assert_invalid(expected, m);
	}
	def assert_invalid(expected: WasmError, m: BinParser) -> bool {
		var module = m.finish();
		var e = m.err;
		if (e.error()) {
			if (module != null) t.fail("expected error, got non-null module");
			if (e.error_code == expected) return true;
			var buf = StringBuilder.new();
			buf.put2("expected error %s, but got %s: ", expected.name, e.error_code.name);
			buf.put2("@+%d %s", e.error_pos, e.error_msg);
			t.fail(buf.extract());
		}
		t.fail1("expected error %s, but passed", expected.name);
		return false;
	}
	def assert_valid(m: BinParser) -> Module {
		var module = m.finish();
		var e = m.err;
		if (e.error()) {
			var buf = StringBuilder.new();
			buf.put1("expected success, but got %s: ", e.error_code.name);
			buf.put2("@+%d %s", e.error_pos, e.error_msg);
			t.fail(buf.extract());
		}
		if (module == null) t.fail("expected success, got null module");
		return module;
	}
	def assert_sig(expected: SigDecl, m: Module, index: int) {
		if (m == null) return t.fail1("expected sig %q, got null module", expected.render);
		if (index >= m.heaptypes.length) return t.fail2("expected sig %q, got only %d signatures",
				expected.render, m.heaptypes.length);
		var g = m.heaptypes[index];
		if (!SigDecl.?(g)) return t.fail1("expected sig %q, got wrong type", expected.render);
		var got = SigDecl.!(g);
		if (!expected.isAssignableSig(got)) return t.fail2("expected sig %q, got %q", expected.render, got.render);
		if (!got.isAssignableSig(expected)) return t.fail2("expected sig %q, got %q", expected.render, got.render);
	}
	def mp() -> BinParser {
		var err = ErrorGen.new("test");
		var r = BinParser.new(extensions, limits, err, "test");
		r.validate_code = validate_code;
		return r;
	}
}

def VALID_HEADER = BinUtil.WASM_HEADER;

def test_typecons(t: BinParserTester) {
	for (tc in BpTypeCode) {
		if (u7.view(tc.val) != tc.code) t.t.fail3("BpTypeCode.%s fail, code=0x%x, val=%d", tc.name, tc.code, int.view(tc.val));
	}
	for (tc in BpHeapTypeCode) {
		if (u7.view(tc.val) != tc.code) t.t.fail3("BpHeapTypeCon.%s fail, code=0x%x, val=%d", tc.name, tc.code, int.view(tc.val));
	}
	for (tc in BpDefTypeCode) {
		if (u7.view(tc.val) != tc.code) t.t.fail3("BpDefTypeCon.%s fail, code=0x%x, val=%d", tc.name, tc.code, int.view(tc.val));
	}
}

def test_empty(t: BinParserTester) {
	for (i < VALID_HEADER.length) {
		var mod = Arrays.range(VALID_HEADER, 0, i);
		t.invalid(WasmError.INVALID_HEADER, mod);
	}
}

def test_magic(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i < 4) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_version(t: BinParserTester) {
	def template = Arrays.range(VALID_HEADER, 0, VALID_HEADER.length);
	for (i = 4; i < 8; i++) {
		var prev = template[i];
		template[i] = 0xFF;
		t.invalid(WasmError.INVALID_HEADER, template);
		template[i] = prev;
	}
}

def test_invalid(t: BinParserTester) {
	var b = BinBuilder.new();
	for (i < 256) {
		b.reset_header();
		var found = false;
		for (s in BpSection) {
			if (s.code == i) { found = true; break; }
		}
		if (found) continue;
		b.put(byte.!(i));
		t.invalidN(WasmError.INVALID_SECTION, b.storage());
	}
}

def test_buf_offset(t: BinParserTester) {
	def len = VALID_HEADER.length;
	var buffer = Array<byte>.new(3 * len);
	for (i < (len * 2) + 1) {
		ArrayUtil.copyInto(buffer, i, VALID_HEADER, 0, len);
		var m = t.mp();
		m.push(buffer, i, len);
		t.assert_valid(m);
	}
}

def test_hdr_split(t: BinParserTester) {
	def template = VALID_HEADER;
	t.test_split = true;
	t.valid(template);
}

def COUNTED_SECTIONS = [
	BpSection.Type,
	BpSection.Import,
	BpSection.Function,
	BpSection.Table,
	BpSection.Memory,
	BpSection.Global,
	BpSection.Export,
	BpSection.Element,
	BpSection.Code,
	BpSection.Data
];

def EMPTY_FUNC_TYPE: Array<byte> = [
	BpDefTypeCode.Function.code, 0, 0
];
def EMPTY_FUNC_BODY: Array<byte> = [
	0, u8.!(Opcode.UNREACHABLE.code), u8.!(Opcode.END.code)
];
def ONE_FUNC_TYPES_SECTION: Array<byte> = [
	BpSection.Type.code, 4, 1, BpDefTypeCode.Function.code, 0, 0
];
def ONE_FUNC_DECL_SECTION: Array<byte> = [
	BpSection.Function.code, 2, 1, 0
];
def ONE_FUNC_CODE_SECTION: Array<byte> = [
	BpSection.Code.code, 4, 1, 2, 0, u8.!(Opcode.END.code)
];
def ONE_IMPORTED_FUNC_SECTION: Array<byte> = [
	BpSection.Import.code, 7, 1, 1, 'M', 1, 'f', BpImportExportKind.Function.code, 0
];
def ONE_GLOBAL_SECTION: Array<byte> = [
	BpSection.Global.code, 6, 1, BpTypeCode.I32.code, 0,
		u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code)
];
def ONE_PAGE_MEMORY_SECTION: Array<byte> = [
	BpSection.Memory.code, 3, 1, 0, 1
];
def ONE_TABLE_SECTION: Array<byte> = [
	BpSection.Table.code, 4, 1, BpTypeCode.FUNCREF.code, 0, 0
];

class SingleEmptySectionTemplate {
	def len = VALID_HEADER.length;
	def template = Array<byte>.new(len + 3);
	def code_pos = len, size_pos = len + 1, count_pos = len + 2;
	new() {
		ArrayUtil.copyInto(template, 0, VALID_HEADER, 0, len);
		template[size_pos] = 1;
		template[count_pos] = 0;
	}
	def set(sect: BpSection, size: int, count: int) {
		template[code_pos] = sect.code;
		template[size_pos] = byte.!(size);
		template[count_pos] = byte.!(count);
	}
}

def test_sect_empty(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid(s.template);
	}
}

def test_sect_empty_s(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	t.test_split = true;
	for (sect in COUNTED_SECTIONS) {
		// valid case
		s.set(sect, 1, 0);
		t.valid(s.template);
	}
}

def test_sect_dup(t: BinParserTester) {
	t.test_split = true;
	var b = BinBuilder.new();

	for (sect in COUNTED_SECTIONS) {
		b.reset_header();
		b.puta([sect.code, 1, 0]);
		t.validN(b.storage());
		b.puta([sect.code, 1, 0]);
		t.invalidN(WasmError.DUPLICATE_SECTION, b.storage());
	}
}

def test_sect_underflow(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section read size smaller than expected
		s.set(sect, 2, 0);
		t.invalid(WasmError.INCOMPLETE_SECTION, s.template);
	}
}

def test_sect_size0(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// Section size not large enough to even include count
		s.set(sect, 0, 0);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_eof(t: BinParserTester) {
	var s = SingleEmptySectionTemplate.new();

	for (sect in COUNTED_SECTIONS) {
		// EOF before first item
		if (sect == BpSection.Code) continue; // extra count check
		s.set(sect, 1, 1);
		t.invalid(WasmError.OVERFLOW_SECTION, s.template);
	}
}

def test_sect_custom1(t: BinParserTester) {
	var b = BinBuilder.new().reset_header();
	t.test_split = true;
	b.put(BpSection.Unknown.code);
	var len = b.length;
	for (i < 5) {
		b.resize(len);
		b.put_u32leb(u32.!(11 + i));
		b.put_string("my_section");
		for (j < i) b.put(77);
		t.validN(b.storage());
	}
}

def test_sect_custom2(t: BinParserTester) {
	var b = BinBuilder.new().reset_header();
	t.test_split = true;
	b.put(BpSection.Unknown.code);
	var len = b.length;

	b.resize(len);
	b.put_u32leb(u32.!(2));
	b.put_string("\x99"); // invalid UTF8
	t.invalidN(WasmError.INVALID_UTF8_STRING, b.storage());
}

def test_sect_custom_ovf(t: BinParserTester) {
	def name = "x_section";
	var b = BinBuilder.new().reset_header();
	b.put(BpSection.Unknown.code);
	var len = b.length;
	for (i = name.length; i >= 0; i--) {
		b.resize(len);
		b.put_u32leb(u32.!(i));
		b.put_string(name);
		t.invalidN(WasmError.OVERFLOW_SECTION, b.storage());
	}
}

def test_types0(t: BinParserTester) {
	def EMPTY_FUNC: Array<byte> = [BpDefTypeCode.Function.code, 0, 0];
	var b = BinBuilder.new();
	for (i < 5) {
		b.reset_header();
		b.beginShortSection(BpSection.Type);
		b.put_u32leb(u32.!(i));
		for (j < i) b.puta(EMPTY_FUNC);
		b.endSection();
		t.validN(b.storage());
	}
}

def test_types1(t: BinParserTester) {
	var b = BinBuilder.new();
	for (count < 3) {
		for (p < 3) {
			for (r < 2) { // ext:multi-value
				b.reset_header();
				b.beginShortSection(BpSection.Type);
				b.put_u32leb(u32.!(count));
				for (j < count) {
					b.put(BpDefTypeCode.Function.code);
					b.put(byte.!(p));
					for (k < p) b.put(BpTypeCode.I32.code);
					b.put(byte.!(r));
					for (k < r) b.put(BpTypeCode.F32.code);
				}
				b.endSection();
				t.validN(b.storage());
			}
		}
	}
}

def test_func_max_params(t: BinParserTester) {
	var b = BinBuilder.new();
	// Test max params
	var max = DEFAULT_LIMITS.max_num_func_params;
	for (i = max - 1; i <= max + 1; i++) {
		if (i < 0) continue;
		b.reset_header();
		b.beginSection(BpSection.Type);
		b.put(1);
		b.put(BpDefTypeCode.Function.code);
		b.put_u32leb(i); // params
		for (j < i) b.put(BpTypeCode.I64.code);
		b.put(0); // results
		b.endSection();
		var x = b.storage();
		if (i <= max) t.validN(x);
		else t.invalidN(WasmError.EXCEEDED_LIMIT, x);
	}
}

def test_func_max_results(t: BinParserTester) {
	var b = BinBuilder.new();
	// Test max results
	var none: Extension.set;
	var max = t.limits.max_num_func_results;
	for (i = max - 1; i <= max + 1; i++) {
		b.reset_header();
		b.beginSection(BpSection.Type);
		b.put(1);
		b.put(BpDefTypeCode.Function.code);
		b.put(0); // params
		b.put_u32leb(i); // results
		for (j < i) b.put(BpTypeCode.F64.code);
		b.endSection();
		var x = b.storage();
		if (i <= max) t.validN(x);
		else t.invalidN(WasmError.EXCEEDED_LIMIT, x);
	}
}

class BinSectionTester(t: BinParserTester, sect: BpSection) {
	def b = BinBuilder.new().reset_header();
	var suffix: Array<byte>;
	def valid(raw: Array<byte>) -> Module {
		var prev = b.length;
		b.beginSection(sect);
		b.puta(raw);
		b.endSection();
		if (suffix != null) b.puta(suffix);
		var m = t.validN(b.storage());
		b.resize(prev);
		return m;
	}
	def invalid(err: WasmError, raw: Array<byte>) {
		var prev = b.length;
		b.beginSection(sect);
		b.puta(raw);
		b.endSection();
		if (suffix != null) b.puta(suffix);
		t.invalidN(err, b.storage());
		b.resize(prev);
	}
}

def test_imports0(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Import);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.valid([1, 1, 'M', 1, 'g',
		BpImportExportKind.Function.code, 0]);
	s.valid([1, 1, 'N', 1, 'h',
		BpImportExportKind.Table.code, BpTypeCode.FUNCREF.code, 0, 0]);
	s.valid([1, 1, 'O', 1, 'i',
		BpImportExportKind.Memory.code, 0, 0]);
	s.valid([1, 1, 'P', 1, 'j',
		BpImportExportKind.Global.code, BpTypeCode.I32.code, 0]);
	s.invalid(WasmError.OVERFLOW_SECTION, [1, 1, 'P', 1, 'j',
		BpImportExportKind.Global.code, BpTypeCode.I32.code]);
}

def test_imports1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Import);
	s.invalid(WasmError.INVALID_IMPORT_KIND,
		[1, 1, 'P', 1, 'j', /*invalid*/5]);
	s.invalid(WasmError.OOB_INDEX,
		[1, 1, 'M', 1, 'g', BpImportExportKind.Function.code, /*oob*/0]);
	s.invalid(WasmError.EXCEEDED_LIMIT, [1, 1, 'O', 1, 'i',
		BpImportExportKind.Memory.code, 0, /*limit*/0xFF, 0xFF, 0xFF, 0x0]);
	s.invalid(WasmError.INVALID_TYPE, [1, 1, 'P', 1, 'j',
		BpImportExportKind.Global.code, /*invalid*/0x2C, 0]);
	s.invalid(WasmError.INVALID_GLOBAL_FLAGS, [1, 1, 'P', 1, 'j',
		BpImportExportKind.Global.code, BpTypeCode.I32.code, 19]);
}

def test_imports2(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Import);
	s.invalid(WasmError.INVALID_IMPORT_KIND,
		[1, 1, 'P', 1, 'j', /*invalid*/5]);
}

def test_imports3(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Import);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.invalid(WasmError.INVALID_UTF8_STRING, [1, 1, '\x87', 1, 'g',
		BpImportExportKind.Function.code, 0]);
	s.invalid(WasmError.INVALID_UTF8_STRING, [1, 1, 'W', 1, '\x86',
		BpImportExportKind.Function.code, 0]);
}

def test_funcs0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Function);
	s.invalid(WasmError.OOB_INDEX, [1, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 1]);
	s.invalid(WasmError.OOB_INDEX, [1, 4]);

	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.suffix = ONE_FUNC_CODE_SECTION;
	s.valid([1, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 1]);
	s.invalid(WasmError.OOB_INDEX, [1, 4]);
	s.invalid(WasmError.OVERFLOW_SECTION, [1]);
}

def test_funcs1(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Function);
	s.b.beginSection(BpSection.Type);
	s.b.put(3);
	s.b.puta(EMPTY_FUNC_TYPE);
	s.b.puta(EMPTY_FUNC_TYPE);
	s.b.puta(EMPTY_FUNC_TYPE);
	s.b.endSection();
	s.suffix = ONE_FUNC_CODE_SECTION;
	s.valid([1, 0]);
	s.valid([1, 0x81, 0]);
	s.valid([1, 0x82, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 4]);
	s.invalid(WasmError.OOB_INDEX, [1, 5]);
}

def test_funcs2(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Function);

	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.puta(ONE_IMPORTED_FUNC_SECTION);
	s.suffix = ONE_FUNC_CODE_SECTION;
	s.valid([1, 0]);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [0]);
	s.invalid(WasmError.OOB_INDEX, [1, 1]);
	s.invalid(WasmError.OOB_INDEX, [1, 4]);
	s.invalid(WasmError.OVERFLOW_SECTION, [1]);
}

def test_tables0(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Table);
	s.valid([1, BpTypeCode.FUNCREF.code, 0, 0]);
	s.valid([1, BpTypeCode.FUNCREF.code, 0, 2]);
	s.valid([1, BpTypeCode.FUNCREF.code, 1, 2, 3]);
	s.invalid(WasmError.ILLEGAL_TYPE, [1, BpTypeCode.I32.code, 0, 0]);
	s.invalid(WasmError.OVERFLOW_SECTION, [1, BpTypeCode.FUNCREF.code, 1, 2]);
}

def test_table_limits(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Table);
	var b = BinBuilder.new();
	var max = DEFAULT_LIMITS.max_table_size;
	for (i = max - 1; i < max + 2; i++) {
		// initial
		b.puta([1, BpTypeCode.FUNCREF.code, 0]);
		b.put_u32leb(i);
		if (i <= max) s.valid(b.extract());
		else s.invalid(WasmError.EXCEEDED_LIMIT, b.extract());
		// maximum
		b.puta([1, BpTypeCode.FUNCREF.code, 1]);
		b.put(0);
		b.put_u32leb(i);
		if (i <= max) s.valid(b.extract());
		else s.invalid(WasmError.EXCEEDED_LIMIT, b.extract());
	}
}

def test_memory0(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Memory);
	s.valid([1, 0, 0]);
	s.valid([1, 0, 1]);
	s.valid([1, 0, 5]);
	s.valid([1, 1, 2, 5]);

	s.invalid(WasmError.OVERFLOW_SECTION, [1, 1, 0]);
}

def test_memory_limits(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Memory);
	var max = DEFAULT_LIMITS.max_legal_memory_pages;
	var b = BinBuilder.new();
	for (i = max - 1; i < max + 2; i++) {
		// initial
		b.puta([1, 0]);
		b.put_u64leb(i);
		if (i <= max) s.valid(b.extract());
		else s.invalid(WasmError.EXCEEDED_LIMIT, b.extract());
		// maximum
		b.puta([1, 1, 0]);
		b.put_u64leb(i);
		if (i <= max) s.valid(b.extract());
		else s.invalid(WasmError.EXCEEDED_LIMIT, b.extract());
	}
}

def test_globals0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Global);
	s.valid([1, BpTypeCode.I32.code, 0,
		u8.!(Opcode.I32_CONST.code), 1, u8.!(Opcode.END.code)]);
	s.valid([1, BpTypeCode.I32.code, 1,
		u8.!(Opcode.I32_CONST.code), 1, u8.!(Opcode.END.code)]);
	s.valid([1, BpTypeCode.I64.code, 0,
		u8.!(Opcode.I64_CONST.code), 2, u8.!(Opcode.END.code)]);
	s.valid([1, BpTypeCode.F32.code, 0,
		u8.!(Opcode.F32_CONST.code), 0, 0, 0, 0, u8.!(Opcode.END.code)]);
	s.valid([1, BpTypeCode.F64.code, 0,
		u8.!(Opcode.F64_CONST.code), 0, 0, 0, 0, 0, 0, 0, 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.INVALID_TYPE, [1, 0x2C, 0, u8.!(Opcode.END.code)]);

	s.invalid(WasmError.INVALID_GLOBAL_FLAGS, [1, BpTypeCode.I32.code, 2,
		u8.!(Opcode.I32_CONST.code), 1, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, BpTypeCode.F32.code, 0,
		u8.!(Opcode.I32_CONST.code), 1, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, BpTypeCode.F64.code, 0,
		u8.!(Opcode.I64_CONST.code), 2, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, BpTypeCode.I32.code, 0,
		u8.!(Opcode.F32_CONST.code), 0, 0, 0, 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, BpTypeCode.I64.code, 0,
		u8.!(Opcode.F64_CONST.code), 0, 0, 0, 0, 0, 0, 0, 0, u8.!(Opcode.END.code)]);
}

def test_globals1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Global);
	s.invalid(WasmError.INVALID_INIT_EXPR, [2,
		BpTypeCode.I32.code, 0, u8.!(Opcode.I32_CONST.code), 1, u8.!(Opcode.END.code),
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.INVALID_INIT_EXPR, [2,
		BpTypeCode.I64.code, 0, u8.!(Opcode.I64_CONST.code), 1, u8.!(Opcode.END.code),
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.OOB_INDEX, [1,
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);

	// relaxed with GC extension
	t.extensions |= Extension.GC;
	s.valid([2,
		BpTypeCode.I32.code, 0, u8.!(Opcode.I32_CONST.code), 1, u8.!(Opcode.END.code),
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.TYPE_MISMATCH, [2,
		BpTypeCode.I64.code, 0, u8.!(Opcode.I64_CONST.code), 1, u8.!(Opcode.END.code),
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);
}

def test_globals2(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Global);
	s.invalid(WasmError.INVALID_INIT_EXPR, [1, BpTypeCode.F32.code, 0,
		u8.!(Opcode.NOP.code), 0, 0, 0, 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.INVALID_INIT_EXPR, [2,
		BpTypeCode.I32.code, 0, u8.!(Opcode.I32_CONST.code), 2, u8.!(Opcode.END.code),
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.INVALID_INIT_EXPR, [2,
		BpTypeCode.I32.code, 1, u8.!(Opcode.I32_CONST.code), 2, u8.!(Opcode.END.code),
		BpTypeCode.I32.code, 0, u8.!(Opcode.GLOBAL_GET.code), 0, u8.!(Opcode.END.code)]);
}

def test_exports0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Export);
	def H = VALID_HEADER.length;
	s.invalid(WasmError.OOB_INDEX, [1, 1, 'f',
		BpImportExportKind.Function.code, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 1, 't',
		BpImportExportKind.Table.code,0]);
	s.invalid(WasmError.OOB_INDEX, [1, 1, 'm',
		BpImportExportKind.Memory.code, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 1, 'g',
		BpImportExportKind.Global.code, 0]);

	s.b.resize(H);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.puta(ONE_FUNC_DECL_SECTION);
	s.suffix = ONE_FUNC_CODE_SECTION;
	s.valid([1, 2, 'c', 'd',
		BpImportExportKind.Function.code, 0]);
	s.valid([2,
		2, 'c', 'd', BpImportExportKind.Function.code, 0,
		2, 'c', 'f', BpImportExportKind.Function.code, 0]);
	s.invalid(WasmError.DUPLICATE_EXPORT, [2,
		2, 'F', 'e', BpImportExportKind.Function.code, 0,
		2, 'F', 'e', BpImportExportKind.Function.code, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 2, 'c', 'd',
		BpImportExportKind.Function.code, 1]);

	s.b.resize(H);
	s.b.puta(ONE_TABLE_SECTION);
	s.suffix = null;
	s.valid([1, 2, 'f', 'g',
		BpImportExportKind.Table.code, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 2, 'f', 'g',
		BpImportExportKind.Table.code, 1]);

	s.b.resize(H);
	s.b.puta(ONE_PAGE_MEMORY_SECTION);
	s.valid([1, 3, 'x', 'y', 'z',
		BpImportExportKind.Memory.code, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 3, 'x', 'y', 'z',
		BpImportExportKind.Memory.code, 1]);

	s.b.resize(H);
	s.b.puta(ONE_GLOBAL_SECTION);
	s.valid([1, 0,
		BpImportExportKind.Global.code, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 0,
		BpImportExportKind.Global.code, 1]);
}

def test_start0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Start);
	s.invalid(WasmError.OOB_INDEX, [0]);
	s.invalid(WasmError.OOB_INDEX, [1]);

	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.puta(ONE_FUNC_DECL_SECTION);
	s.suffix = ONE_FUNC_CODE_SECTION;
	s.valid([0]);
	s.invalid(WasmError.OOB_INDEX, [1]);
	s.invalid(WasmError.INCOMPLETE_SECTION, [0, 0]);
}

def test_start1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Start);
	s.invalid(WasmError.OOB_INDEX, [0]);
	s.invalid(WasmError.OOB_INDEX, [1]);

	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.puta(ONE_IMPORTED_FUNC_SECTION);
	s.valid([0]);
	s.invalid(WasmError.OOB_INDEX, [1]);
	s.invalid(WasmError.INCOMPLETE_SECTION, [0, 0]);
}

def test_start2(t: BinParserTester) {
	var b = BinBuilder.new().reset_header();
	b.puta([BpSection.Type.code, 5, 1, BpDefTypeCode.Function.code, 1, BpTypeCode.I32.code, 0]);
	b.puta(ONE_FUNC_DECL_SECTION);
	b.puta([BpSection.Start.code, 1, 0]);
	t.invalidN(WasmError.ILLEGAL_TYPE, b.storage());

	b.reset_header();
	b.puta([BpSection.Type.code, 5, 1, BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code]);
	b.puta(ONE_FUNC_DECL_SECTION);
	b.puta([BpSection.Start.code, 1, 0]);
	t.invalidN(WasmError.ILLEGAL_TYPE, b.storage());
}

def test_elements0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Element);
	s.invalid(WasmError.OOB_INDEX, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.b.puta(ONE_TABLE_SECTION);
	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 0, u8.!(Opcode.I64_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 0]);

	s.b.resize(VALID_HEADER.length);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.puta(ONE_IMPORTED_FUNC_SECTION);
	s.b.puta(ONE_TABLE_SECTION);
	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 0]);
	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 3, 0, 0, 0]);
	s.invalid(WasmError.OOB_INDEX, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 1]);
}

def test_elements1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Element);
	s.b.puta([BpSection.Table.code, 4, 1, BpTypeCode.EXTERNREF.code, 0, 0]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.valid([1, 4, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 4, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code),
			1, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code)]);
}

def test_elements2(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Element);
	s.b.puta([BpSection.Table.code, 4, 1, BpTypeCode.FUNCREF.code, 0, 0]);
	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.valid([1, 4, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 4, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code),
			1, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code)]);
}

def test_elements3(t: BinParserTester) {
	t.extensions |= Extension.FUNCTION_REFERENCES;
	var s = BinSectionTester.new(t, BpSection.Element);
	s.b.puta([BpSection.Type.code, 8, 2,
		BpDefTypeCode.Function.code, 0, 0,
		BpDefTypeCode.Function.code, 1, BpTypeCode.I32.code, 0]);
	s.b.puta([BpSection.Import.code, 13, 2,
		1, 'M', 1, 'f', BpImportExportKind.Function.code, 0,
		1, 'M', 1, 'f', BpImportExportKind.Function.code, 1]);
	s.b.puta([BpSection.Table.code, 5, 1, BpTypeCode.REF_NULL.code, 0, 0, 0]);

	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 0]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 1]); // incorrect function sig
}

def test_elements4(t: BinParserTester) {
	t.extensions |= Extension.FUNCTION_REFERENCES;
	var s = BinSectionTester.new(t, BpSection.Element);
	s.b.puta([BpSection.Type.code, 8, 2,
		BpDefTypeCode.Function.code, 0, 0,
		BpDefTypeCode.Function.code, 1, BpTypeCode.I32.code, 0]);
	s.b.puta([BpSection.Import.code, 13, 2,
		1, 'M', 1, 'f', BpImportExportKind.Function.code, 0,
		1, 'M', 1, 'f', BpImportExportKind.Function.code, 1]);
	s.b.puta([BpSection.Table.code, 5, 1, BpTypeCode.REF_NULL.code, 0, 0, 0]);

	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 0]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 1, 1]); // incorrect function sig
}

def testCountedSection(t: BinParserTester, max: int, sect: BpSection,
	pre: Array<byte>, entry: Array<byte>) {
	var entries = Array<Array<byte>>.new(max);
	for (i < max) entries[i] = entry;
	testCountedSectionK(t, max, sect, pre, entries);
}
def testCountedSectionK(t: BinParserTester, max: int, sect: BpSection,
	pre: Array<byte>, entries: Array<Array<byte>>) {
	t.test_split = false; // test split at all points
	var b = BinBuilder.new().reset_header();
	if (pre != null) b.puta(pre);
	var len = b.length;
	var last = 0;
	for (count < max+1) {
		b.resize(len);
		b.beginShortSection(sect);
		last = b.length;
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(entries[j]);
		b.endSection();

		t.validN(b.storage());
	}
	var raw = b.extract();

	// Test truncated module by up to {max} entries.
	for (cut = last; cut < raw.length; cut++) {
		var m = t.mp();
		m.push(raw, 0, cut);
		t.assert_invalid(WasmError.INCOMPLETE_SECTION, m);
	}

	b.reset_header();
	if (pre != null) b.puta(pre);
	// Test underflow section by up to {max} entries.
	for (count < max+1) {
		b.resize(len);
		b.beginShortSection(sect);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(entries[j]);
		b.put(99);  // extraneous byte
		b.endSection();
		var m = t.mp();
		m.push(b.storage());
		t.assert_invalid(WasmError.INCOMPLETE_SECTION, m);
	}
}

def test_typesN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Type, null, [
		BpDefTypeCode.Function.code, 1, BpTypeCode.I32.code, 1, BpTypeCode.I32.code
	]);
}

def test_importsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Import, null, [
		1, 'M', 1, 'g', BpImportExportKind.Global.code, BpTypeCode.I32.code, 0
	]);
}

def test_funcsN(t: BinParserTester) {
	var b = BinBuilder.new().reset_header();
	b.puta(ONE_FUNC_TYPES_SECTION);
	var len = b.length;

	// Test valid function body/code pairs
	var func_entry: Array<byte> = [0];
	var func_body: Array<byte> = [2, 0, u8.!(Opcode.END.code)];
	for (count < 4) {
		// valid case.
		b.resize(len);
		// funcs
		b.beginShortSection(BpSection.Function);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(func_entry);
		b.endSection();
		// bodies
		b.beginShortSection(BpSection.Code);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(func_body);
		b.endSection();
		// validate
		t.validN(b.storage());

		// underflow case
		b.resize(len);
		// funcs
		b.beginShortSection(BpSection.Function);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(func_entry);
		b.put(99);  // extraneous byte
		b.endSection();
		// bodies
		b.beginShortSection(BpSection.Code);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(func_body);
		b.endSection();
		// validate
		var m = t.mp();
		m.push(b.storage());
		t.assert_invalid(WasmError.INCOMPLETE_SECTION, m);

		// overflow case
		b.resize(len);
		// funcs
		b.beginShortSection(BpSection.Function);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(func_entry);
		b.resize(b.length - 1);
		b.endSection();
		// bodies
		b.beginShortSection(BpSection.Code);
		b.put_u32leb(u32.!(count));
		for (j < count) b.puta(func_body);
		b.endSection();
		// validate
		m = t.mp();
		m.push(b.storage());
		t.assert_invalid(WasmError.OVERFLOW_SECTION, m);
	}
}

def test_tablesN(t: BinParserTester) {
	testCountedSection(t, 1/*ext:bulk-memory*/, BpSection.Table, null, [
		BpTypeCode.FUNCREF.code, 0, 0
	]);
}

def test_memoriesN(t: BinParserTester) {
	testCountedSection(t, 1/*ext:multi-memory*/, BpSection.Memory, null, [
		0, 0
	]);
}

def test_globalsN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Global, null, [
		BpTypeCode.I32.code, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code)
	]);
}

def test_exportsN(t: BinParserTester) {
	testCountedSectionK(t, 3, BpSection.Export, ONE_GLOBAL_SECTION, [
		[1, 'g', BpImportExportKind.Global.code, 0],
		[1, 'h', BpImportExportKind.Global.code, 0],
		[1, 'i', BpImportExportKind.Global.code, 0],
		[1, 'j', BpImportExportKind.Global.code, 0]
	]);
}

def test_elementsN(t: BinParserTester) {
	var b = BinBuilder.new();
	// Add one type
	b.puta(ONE_FUNC_TYPES_SECTION);
	// Add one function
	b.puta(ONE_IMPORTED_FUNC_SECTION);
	// Add one table
	b.beginShortSection(BpSection.Table);
	b.puta([1, BpTypeCode.FUNCREF.code, 0, 5]);
	b.endSection();
	var setup = b.extract();

	testCountedSection(t, 3, BpSection.Element, setup, [
		0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 3, 0, 0, 0
	]);
}

def test_dataN(t: BinParserTester) {
	testCountedSection(t, 3, BpSection.Data, ONE_PAGE_MEMORY_SECTION, [
		0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 3, 'a', 'b', 'c'
	]);
}

def test_code0(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Code);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.puta(ONE_FUNC_DECL_SECTION);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [0]);
	s.valid([1, 2, 0, u8.!(Opcode.END.code)]);
	s.valid([1, 3, 0, u8.!(Opcode.NOP.code), u8.!(Opcode.END.code)]);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [2, 0, 0]);
}

def test_code1(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Code);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.beginSection(BpSection.Function);
	s.b.put(3);
	s.b.puta([0, 0, 0]);
	s.b.endSection();

	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [0]);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [1, 0]);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [2, 0, 0]);
	s.valid([3, 2, 0, u8.!(Opcode.END.code),
			2, 0, u8.!(Opcode.END.code),
			2, 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [4, 0, 0, 0, 0]);
}

def test_code2(t: BinParserTester) {
	t.test_split = true;
	var s = BinSectionTester.new(t, BpSection.Code);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.b.beginSection(BpSection.Function);
	s.b.puta([1, 0]);
	s.b.endSection();
	s.valid([1, 2, 0, u8.!(Opcode.END.code)]);
	s.invalid(WasmError.INCOMPLETE_FUNCTION_BODY, [1]);
	s.invalid(WasmError.INCOMPLETE_FUNCTION_BODY, [1, 2, 0]);

	var b = BinBuilder.new();
	var max = DEFAULT_LIMITS.max_func_size;
	t.test_split = false;
	for (size in [66u, max - 1, max, max + 1]) {
		b.resize(0);
		b.put(1);
		b.put_u32leb(size);
		var error = if(size <= max,
				WasmError.INCOMPLETE_FUNCTION_BODY,
				WasmError.EXCEEDED_LIMIT);
		s.invalid(error, b.extract());
	}
}

def test_code_missing(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Function);
	s.b.puta(ONE_FUNC_TYPES_SECTION);
	s.invalid(WasmError.FUNC_COUNT_MISMATCH, [1, 0]);
}

def test_data0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Data);
	s.invalid(WasmError.OOB_INDEX, [1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.b.puta(ONE_PAGE_MEMORY_SECTION);
	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 0]);
	s.valid([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 2, 99, 88]);
	s.invalid(WasmError.TYPE_MISMATCH, [1, 0, u8.!(Opcode.I64_CONST.code), 0, u8.!(Opcode.END.code), 0]);


	var max = DEFAULT_LIMITS.max_data_segment_size;
	var b = BinBuilder.new();
	b.puta([1, 0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code)]);
	var pre_size = b.length;
	for (size in [7788u, max - 1, max, max + 1]) {
		b.resize(pre_size);
		b.put_u32leb(size);
		var error = if(size <= max,
			WasmError.OVERFLOW_SECTION,
			WasmError.EXCEEDED_LIMIT);
		s.invalid(error, b.copy());
	}

}

def test_count_limits(t: BinParserTester) {
	var limits = DEFAULT_LIMITS;
	var pairs = [
		(BpSection.Type, limits.max_num_types),
		(BpSection.Function, limits.max_num_functions),
		(BpSection.Import, limits.max_num_imports),
		(BpSection.Export, limits.max_num_exports),
		(BpSection.Global, limits.max_num_globals),
		(BpSection.Data, limits.max_num_data_segments),
		(BpSection.Table, limits.max_num_tables),
		(BpSection.Memory, limits.max_num_memories)
	];
	var b = BinBuilder.new();
	for (p in pairs) {
		var max = p.1;
		for (c = max -1; c <= max + 1; c++) {
			b.reset_header();
			b.beginSection(p.0);
			b.put_u32leb(c);
			b.endSection();
			if (c == 0) {
				t.validN(b.storage());
				continue;
			}
			var error = if(c <= max,
				WasmError.OVERFLOW_SECTION,
				WasmError.EXCEEDED_LIMIT);
			t.invalidN(error, b.storage());
		}
	}
}

def test_import_def_max(t: BinParserTester, max: u32,
	sect: BpSection, raw_import: Array<byte>, raw_def: Array<byte>) {

	var b = BinBuilder.new();
	for (count = max - 1; count <= max + 1; count++) {
		if (count == 0) continue; // skip vacuous test
		// {count} imports alone
		b.reset_header();
		b.beginSection(BpSection.Import);
		b.put_u32leb(count);
		for (i < count) b.puta(raw_import);
		b.endSection();
		if (count <= max) t.validN(b.storage());
		else t.invalidN(WasmError.EXCEEDED_LIMIT, b.storage());

		// {count} definitions alone
		b.reset_header();
		b.beginSection(sect);
		b.put_u32leb(count);
		for (i < count) b.puta(raw_def);
		b.endSection();
		if (count <= max) t.validN(b.storage());
		else t.invalidN(WasmError.EXCEEDED_LIMIT, b.storage());

		// {count-1} imports, 1 def
		b.reset_header();
		b.beginSection(BpSection.Import);
		b.put_u32leb(count - 1);
		for (i < count - 1) b.puta(raw_import);
		b.endSection();
		b.beginSection(sect);
		b.put_u32leb(1);
		b.puta(raw_def);
		b.endSection();
		if (count <= max) t.validN(b.storage());
		else t.invalidN(WasmError.EXCEEDED_LIMIT, b.storage());
	}
}

def test_max_num_memories(t: BinParserTester) {
	var none: Extension.set;
	for (p in [(none, 1u), (Extension.MULTI_MEMORY, 5u)]) {
		t.extensions = p.0;
		t.limits.max_num_memories = p.1;
		test_import_def_max(t, p.1,
			BpSection.Memory,
			[1, 'M', 1, 'm', BpImportExportKind.Memory.code, 0, 0], // import
			[1, 3, 4]); // define
	}
}

def test_max_num_tables(t: BinParserTester) {
	var none: Extension.set;
	for (p in [(none, 1u), (none, 5u)]) {
		t.extensions = p.0;
		t.limits.max_num_tables = p.1;
		test_import_def_max(t, p.1,
			BpSection.Table,
			[ 1, 'M', 1, 'm', BpImportExportKind.Table.code,
				BpTypeCode.FUNCREF.code, 0, 0], // import
			[BpTypeCode.FUNCREF.code, 0, 0]); // define
	}
}

// TODO: ILLEGAL_TYPE error for function sig
// TODO: limit tests for every kind of quantity whereever it can occur
// TODO: section constraints
// TODO: maximum number of element segments

def test_data_count(t: BinParserTester) {
	var b = BinBuilder.new();
	b.reset_header();

	b.beginSection(BpSection.DataCount);
	b.put_u32leb(0);
	b.endSection();
	t.validN(b.storage());

	b.beginSection(BpSection.Data);
	b.put_u32leb(0);
	b.endSection();
	t.validN(b.storage());

	b.reset_header();
	b.beginSection(BpSection.DataCount);
	b.put_u32leb(1);
	b.endSection();
	t.invalidN(WasmError.DATA_COUNT_MISMATCH, b.storage());

	b.beginSection(BpSection.Data);
	b.put_u32leb(0);
	b.endSection();
	t.invalidN(WasmError.DATA_COUNT_MISMATCH, b.storage());

	b.reset_header();
	b.beginSection(BpSection.DataCount);
	b.put_u32leb(1);
	b.endSection();
	def seg: Array<byte> = [0, u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.END.code), 3, 'a', 'b', 'c'];
	b.beginSection(BpSection.Data);
	b.put_u32leb(2);
	b.puta(seg);
	b.puta(seg);
	b.endSection();
	t.invalidN(WasmError.DATA_COUNT_MISMATCH, b.storage());
}

def test_repeat_types1(t: BinParserTester) {
	var b = BinBuilder.new();
	for (count = 2; count < 5; count++) {
		b.reset_header();
		for (i < count)	b.puta(ONE_FUNC_TYPES_SECTION);
		t.invalidN(WasmError.DUPLICATE_SECTION, b.storage());
	}
	t.extensions |= Extension.REPEAT_SECTIONS;
	for (count = 2; count < 5; count++) {
		b.reset_header();
		for (i < count)	b.puta(ONE_FUNC_TYPES_SECTION);
		t.validN(b.storage());
	}
}

def test_repeat_types2(t: BinParserTester) {
	var b = BinBuilder.new();
	t.extensions |= Extension.REPEAT_SECTIONS;
	for (max = 3u; max < 5u; max++) {
		t.limits.max_num_types = max;
		b.reset_header();
		for (i < max) b.puta(ONE_FUNC_TYPES_SECTION);
		t.validN(b.storage());
		b.puta(ONE_FUNC_TYPES_SECTION);
		t.invalidN(WasmError.EXCEEDED_LIMIT, b.storage());
	}
}

def test_repeat_funcs1(t: BinParserTester) {
	var b = BinBuilder.new();
	b.reset_header();
	b.puta(ONE_FUNC_TYPES_SECTION);
	var len = b.length;
	for (count = 2; count < 5; count++) {
		b.resize(len);
		for (i < count) {
			b.puta(ONE_FUNC_DECL_SECTION);
			b.puta(ONE_FUNC_CODE_SECTION);
		}
		t.invalidN(WasmError.DUPLICATE_SECTION, b.storage());
	}
	t.extensions |= Extension.REPEAT_SECTIONS;
	for (count = 2; count < 5; count++) {
		b.resize(len);
		for (i < count) {
			b.puta(ONE_FUNC_DECL_SECTION);
			b.puta(ONE_FUNC_CODE_SECTION);
		}
		t.validN(b.storage());
	}
}

def test_repeat_funcs2(t: BinParserTester) {
	var b = BinBuilder.new().reset_header();
	b.puta(ONE_FUNC_TYPES_SECTION);
	var len = b.length;
	t.extensions |= Extension.REPEAT_SECTIONS;
	for (imported in [false, true]) {
		for (max = 3u; max < 5u; max++) {
			t.limits.max_num_functions = max;
			b.resize(len);
			for (i < max) {
				b.puta(ONE_FUNC_DECL_SECTION);
				b.puta(ONE_FUNC_CODE_SECTION);
			}
			t.validN(b.storage());
			if (imported) {
				b.puta(ONE_IMPORTED_FUNC_SECTION);
			} else {
				b.puta(ONE_FUNC_DECL_SECTION);
				b.puta(ONE_FUNC_CODE_SECTION);
			}
			t.invalidN(WasmError.EXCEEDED_LIMIT, b.storage());
		}
	}
}

def test_repeat_imports1(t: BinParserTester) {
	var b = BinBuilder.new();
	b.reset_header();
	b.puta(ONE_FUNC_TYPES_SECTION);

	var len = b.length;
	for (count = 2; count < 5; count++) {
		b.resize(len);
		for (i < count) b.puta(ONE_IMPORTED_FUNC_SECTION);
		t.invalidN(WasmError.DUPLICATE_SECTION, b.storage());
	}
	t.extensions |= Extension.REPEAT_SECTIONS;
	for (count = 2; count < 5; count++) {
		b.resize(len);
		for (i < count) b.puta(ONE_IMPORTED_FUNC_SECTION);
		t.validN(b.storage());
	}
}

def test_repeat_imports2(t: BinParserTester) {
	t.extensions |= Extension.REPEAT_SECTIONS;

	var b = BinBuilder.new();
	b.reset_header();
	b.puta(ONE_FUNC_TYPES_SECTION);
	b.puta(ONE_IMPORTED_FUNC_SECTION);
	b.puta(ONE_FUNC_DECL_SECTION);
	b.puta(ONE_FUNC_CODE_SECTION);
	b.puta(ONE_IMPORTED_FUNC_SECTION);
	b.puta(ONE_FUNC_DECL_SECTION);
	b.puta(ONE_FUNC_CODE_SECTION);

	var module = t.validN(b.storage());
	if (module == null) return;
	if (module.heaptypes.length != 1) return t.t.fail("expected 1 type");
	if (module.functions.length != 4) return t.t.fail("expected 4 funcs");
	if (!module.functions[0].imported()) return t.t.fail("f[0] not imported");
	if (module.functions[1].imported()) return t.t.fail("f[1] imported");
	if (!module.functions[2].imported()) return t.t.fail("f[2] not imported");
	if (module.functions[3].imported()) return t.t.fail("f[3] imported");
}

def test_func_ref_types0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		2,
		BpDefTypeCode.Function.code, 0, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.REF.code, 0
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.FUNCTION_REFERENCES;
	s.valid(sect1);

	s.valid([
		2,
		BpDefTypeCode.Function.code, 0, 0,
		BpDefTypeCode.Function.code, 1, BpTypeCode.REF_NULL.code, 0, 0
	]);

	s.invalid(WasmError.OOB_INDEX, [
		2,
		BpDefTypeCode.Function.code, 0, 0,
		BpDefTypeCode.Function.code, 1, BpTypeCode.REF_NULL.code, 2 /*OOB*/, 0
	]);
}

def test_func_ref_types1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		2,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.REF.code, 1, // fw reference
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.FUNCTION_REFERENCES;
	s.invalid(WasmError.OOB_INDEX, sect1);
}

def test_recgrp0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		1,
		BpDefTypeCode.REC.code, 1,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.valid(sect1);
}

def test_recgrp1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		1,
		BpDefTypeCode.REC.code, 2,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.REF.code, 1, // fw reference
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.valid(sect1);
}

def test_recgrp2(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		1,
		BpDefTypeCode.REC.code, 2,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.REF.code, 2, // oob reference
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.invalid(WasmError.OOB_INDEX, sect1);
}

def test_recgrp3(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		1,
		BpDefTypeCode.REC.code, 2,
		BpDefTypeCode.REC.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.invalid(WasmError.INVALID_TYPE, sect1);
}

def test_sub0(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		1,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.valid(sect1);
}

def test_sub1(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		1,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.invalid(WasmError.INVALID_TYPE, sect1);
}

def test_sub2(t: BinParserTester) {
	var s = BinSectionTester.new(t, BpSection.Type);
	var sect1: Array<byte> = [
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	];
	s.invalid(WasmError.INVALID_TYPE, sect1);
	t.extensions |= Extension.GC;
	s.valid(sect1);
}

def test_bad_sub0(t: BinParserTester) {
	t.extensions |= Extension.GC;

	var s = BinSectionTester.new(t, BpSection.Type);
	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // func <: func
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I64.code
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // func <: struct
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Struct.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.F64.code
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // func <: array
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Array.code, BpTypeCode.I8.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.F32.code
	]);
}

def test_bad_sub1(t: BinParserTester) {
	t.extensions |= Extension.GC;

	var s = BinSectionTester.new(t, BpSection.Type);
	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // struct <: struct
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Struct.code, 1, BpTypeCode.I8.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Struct.code, 0
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // struct <: func
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.F64.code,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Struct.code, 0
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // struct <: array
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.F32.code,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Struct.code, 0
	]);
}

def test_bad_sub2(t: BinParserTester) {
	t.extensions |= Extension.GC;

	var s = BinSectionTester.new(t, BpSection.Type);
	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // array <: array
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Array.code, BpTypeCode.I8.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Array.code, BpTypeCode.I16.code, 0
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // array <: struct
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Struct.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Array.code, BpTypeCode.I8.code, 0
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // array <: func
		2,
		BpDefTypeCode.SUB.code, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.F32.code,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Array.code, BpTypeCode.I8.code, 0
	]);
}

def test_bad_sub3(t: BinParserTester) {
	t.extensions |= Extension.GC;

	var s = BinSectionTester.new(t, BpSection.Type);
	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // struct <: final struct
		2,
		BpDefTypeCode.Struct.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Struct.code, 0
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // array <: final array
		2,
		BpDefTypeCode.Array.code, BpTypeCode.I8.code, 0,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Array.code, BpTypeCode.I8.code, 0
	]);

	s.invalid(WasmError.ILLEGAL_SUPERTYPE, [ // func <: final func
		2,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code,
		BpDefTypeCode.SUB.code, 1, 0,
		BpDefTypeCode.Function.code, 0, 1, BpTypeCode.I32.code
	]);
}
