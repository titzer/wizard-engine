// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// provide short names
def op14l = Opcodes.op14l;
def op14h = Opcodes.op14h;

def T = UnitTests.registerT("validator:", _, CodeValidatorTester.new, _);
def X_ = void(
	T("local0", test_local0),
	T("local1", test_local1),
	T("localref", test_localref),
	T("globalref", test_globalref),
	T("refparam", test_refparam),
	T("ret0", test_ret0),
	T("ret1", test_ret1),
	T("br0", test_br0),
	T("br_table0", test_br_table0),
	T("br_table1", test_br_table1),
	T("if0", test_if0),
	T("if1", test_if1),
	T("if2", test_if2),
	T("if_end", test_if_end),
	T("if_unr1", test_if_unr1),
	T("if_unr2", test_if_unr2),
	T("select", test_select),
	T("selectn", test_selectn),
	T("selectt", test_selectt),
	T("loop0", test_loop0),
	T("loop_br", test_loop_br),
	T("loopv", test_loopv),
	T("blockp1", test_blockp1),
	T("blockp2", test_blockp2),
	T("blockv2", test_blockv2),
	T("blockinv", test_blockinv),
	T("unterm", test_unterm),
	T("else", test_else0),
	T("simple_ops_v", test_simple_ops_v),
	T("simple_ops_r", test_simple_ops_r),
	T("simple_ops0", test_simple_ops0),
	T("simple_ops1", test_simple_ops1),
	T("simple_ops2", test_simple_ops2),
	T("memindex1", test_memindex1),
	T("memindex2", test_memindex2),
	T("tabindex1", test_tabindex1),
	T("tabindex2", test_tabindex2),
	T("retcall1", test_retcall1),
	T("retcall2", test_retcall2),
	T("invalid1", test_invalid1),
	T("invalid2", test_invalid2),
	T("prefix1", test_prefix_ops1),
	T("ref.null", test_ref_null),
	T("ref.is_null", test_ref_is_null),
	T("ref.func", test_ref_func),
	T("ref.as_non_null", test_ref_as_non_null),
	T("br_on_null", test_br_on_null),
	T("br_on_non_null", test_br_on_non_null),
	T("memory.init", test_memory_init),
	T("data.drop", test_data_drop),
	T("memory.copy", test_memory_copy),
	T("memory.fill", test_memory_fill),
	T("table.init", test_table_init),
	T("elem.drop", test_elem_drop),
	T("table.get", test_table_get),
	T("table.set", test_table_set),
	T("table.copy1", test_table_copy1),
	T("table.copy2", test_table_copy2),
	T("table.grow", test_table_grow),
	T("table.size", test_table_size),
	T("table.fill", test_table_fill),
	T("call_ref0", test_call_ref0),
	T("retcall_ref0", test_retcall_ref0),
	T("ref.eq", test_ref_eq),
	T("struct.new", test_struct_new),
	T("struct.newdef", test_struct_newdef),
	T("struct.get", test_struct_get),
	T("struct.get_su", test_struct_get_su),
	T("struct.set", test_struct_set),
	T("array.new", test_array_new),
	T("array.newdef", test_array_newdef),
	T("array.get", test_array_get),
	T("array.get_su", test_array_get_su),
	T("array.set", test_array_set),
	T("array.len", test_array_len),
	T("array.new_fixed", test_array_new_fixed),
	T("array.new_data", test_array_new_data),
	T("array.new_elem", test_array_new_elem),
	T("i31.new", test_i31_new),
	T("i31.get_su", test_i31_get_su),
	T("ref.test", testDeclPairs(_, test_ref_test0)),
	T("ref.cast", testDeclPairs(_, test_ref_cast0)),
	T("br_on_cast0", testDeclPairs(_, test_br_on_cast0)),
	T("br_on_cast1", test_br_on_cast1),
	T("br_on_cast_fail0", test_br_on_cast_fail0),
	T("br_on_cast_fail1", testDeclPairs(_, test_br_on_cast_fail1)),
	T("simd.unop1", test_simd_unop1),
	T("simd.unop2", test_simd_unop2),
	T("simd.unop3", test_simd_unop3),
	T("simd.binop1", test_simd_binop1),
	T("simd.binop2", test_simd_binop2),
	T("simd.binop3", test_simd_binop3),
	()
);

def newSig = ValueTypes.newSig;

class CodeValidatorTester(t: Tester) extends ModuleBuilder {
	def err = ErrorGen.new("CodeValidatorTest.v3");
	var validator: CodeValidator; // FAST: reuse validator
	new() {
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def setExtensions(e: Extension.set) {
		extensions = e;
		validator = CodeValidator.new(extensions, Limits.new().set(extensions), module, err);
	}
	def valid(raw: Array<byte>) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => ;
			Error(error, pc, msg) => t.fail2("expected success, got error @+%d: %s", pc, msg);
		}
	}
	def invalid(expected: WasmError, raw: Array<byte>, error_pc: int) {
		code(raw);
		err.reset();
		match (validator.validateFunc(func)) {
			Ok => t.fail2("expected error %s @+%d, got success", expected.name, error_pc);
			Error(error, pc, msg) => {
				if (error != expected) {
					t.fail3("expected error %s, got %s @+%d\n",
						expected.name, error.name, pc);
				} else if (pc != error_pc) {
					t.fail3("expected error location @+%d, got @+%d (%s)", error_pc, pc, msg);
				}
			}
		}
	}
	def TypeError(code: Array<byte>, error_pc: int) {
		invalid(WasmError.TYPE_MISMATCH, code, error_pc);
	}
	def addRefFuncType(nullable: bool, sig: SigDecl) -> (ValueType.Ref, SigDecl) {
		sig = addSig(sig);
		return (ValueTypes.RefFunc(nullable, sig), sig);
	}
}

def EB = BpTypeCode.EmptyBlock.code;

def test_local0(t: CodeValidatorTester) {
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0];
	t.invalid(WasmError.OOB_INDEX, code1, 1);
	t.sig(SigCache.i_i);
	t.valid(code1);
}

def test_local1(t: CodeValidatorTester) {
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0];
	t.sig(SigCache.i_i);
	t.addLocals(10000000, ValueType.I32);
	t.invalid(WasmError.EXCEEDED_LIMIT, code1, 1);
}

def test_localref(t: CodeValidatorTester) {
	var lg = t.addLocals(1, ValueTypes.FUNCREF);
	var le = t.addLocals(1, ValueTypes.EXTERNREF);
	t.sig0([ValueTypes.FUNCREF, ValueTypes.EXTERNREF], SigCache.arr_v);
	t.valid([u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.LOCAL_SET.code), byte.!(lg)]);
	t.valid([u8.!(Opcode.LOCAL_GET.code), 1, u8.!(Opcode.LOCAL_SET.code), byte.!(le)]);

	t.invalid(WasmError.TYPE_MISMATCH, [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.LOCAL_SET.code), byte.!(le)], 7);
	t.invalid(WasmError.TYPE_MISMATCH, [u8.!(Opcode.LOCAL_GET.code), 1, u8.!(Opcode.LOCAL_SET.code), byte.!(lg)], 7);
}

def test_globalref(t: CodeValidatorTester) {
	var lg = byte.!(t.newGlobal(ValueTypes.FUNCREF, InitExpr.FuncRefNull).global_index);
	var le = byte.!(t.newGlobal(ValueTypes.EXTERNREF, InitExpr.ExternRefNull).global_index);

	t.sig0([ValueTypes.FUNCREF, ValueTypes.EXTERNREF], SigCache.arr_v);
	t.valid([u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.GLOBAL_SET.code), lg]);
	t.valid([u8.!(Opcode.LOCAL_GET.code), 1, u8.!(Opcode.GLOBAL_SET.code), le]);

	t.invalid(WasmError.TYPE_MISMATCH, [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.GLOBAL_SET.code), le], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [u8.!(Opcode.LOCAL_GET.code), 1, u8.!(Opcode.GLOBAL_SET.code), lg], 3);
}

def test_refparam(t: CodeValidatorTester) {
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0];
	var refs = [ValueTypes.FUNCREF, ValueTypes.EXTERNREF];
	for (p in refs) {
		for (r in refs) {
			t.sig0([p], [r]);
			if (p == r) t.valid(code1);
			else t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
		}
	}
}

def test_ret0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([]);
	t.valid([u8.!(Opcode.RETURN.code)]);

	t.TypeError([u8.!(Opcode.I32_CONST.code), 0], 3);
	t.TypeError([u8.!(Opcode.I64_CONST.code), 0], 3);
	t.TypeError([u8.!(Opcode.F32_CONST.code), 0, 0, 0, 0], 6);
	t.TypeError([u8.!(Opcode.F64_CONST.code), 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_ret1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.TypeError([], 1);
	t.TypeError([u8.!(Opcode.RETURN.code)], 1);

	t.valid([u8.!(Opcode.I32_CONST.code), 0]);
	t.TypeError([u8.!(Opcode.I64_CONST.code), 0], 3);
	t.TypeError([u8.!(Opcode.F32_CONST.code), 0, 0, 0, 0], 6);
	t.TypeError([u8.!(Opcode.F64_CONST.code), 0, 0, 0, 0, 0, 0, 0, 0], 10);
}

def test_br0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([u8.!(Opcode.BR.code), 0]);
	t.invalid(WasmError.OOB_LABEL, [u8.!(Opcode.BR.code), 1], 1);
	t.invalid(WasmError.OOB_LABEL, [
		u8.!(Opcode.BLOCK.code), EB,
		u8.!(Opcode.BR.code), 2,
		u8.!(Opcode.END.code)
	], 3);
}

def test_br_table0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 7,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_TABLE.code), 2, 0, 0, 0];
	t.sig(SigCache.i_i);
	t.valid(code1);

	t.sig(SigCache.f_i);
	t.TypeError(code1, 5);

	t.sig(SigCache.i_f);
	t.TypeError(code1, 5);

	var code2: Array<byte> = [
		u8.!(Opcode.BLOCK.code), BpTypeCode.I32.code,
		u8.!(Opcode.I32_CONST.code), 7,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_TABLE.code), 2, 0, 1, 0,
		u8.!(Opcode.END.code)];
	t.sig(SigCache.i_i);
	t.valid(code2);

	t.sig(SigCache.f_i);
	t.TypeError(code2, 7);
}

def test_br_table1(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		u8.!(Opcode.BLOCK.code), EB,
		u8.!(Opcode.I32_CONST.code), 8,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_TABLE.code), 2, 0, 1, 0,
		u8.!(Opcode.END.code)];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		u8.!(Opcode.F32_CONST.code), 0, 0, 0, 0,
		u8.!(Opcode.LOOP.code), BpTypeCode.F32.code,
		u8.!(Opcode.I32_CONST.code), 9,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_TABLE.code), 2, 0, 1, 0,
		u8.!(Opcode.END.code)];
	t.sig(SigCache.i_i);
	t.TypeError(code2, 12);
}

def test_if0(t: CodeValidatorTester) {
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	];
	t.sig(SigCache.i_v);
	t.valid(code1);

	t.sig(SigCache.l_v);
	t.TypeError(code1, 3);

	var code2: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.BR.code), 0,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.RETURN.code),
		u8.!(Opcode.END.code)
	];
	t.sig(SigCache.i_v);
	t.valid(code2);

	t.sig(SigCache.l_v);
	t.TypeError(code2, 3);

	var code3: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.BR.code), 1,
		u8.!(Opcode.END.code)
	];
	t.sig(SigCache.i_v);
	t.valid(code3);

	t.sig(SigCache.l_v);
	t.TypeError(code3, 3);
}

def test_if1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.I32.code,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	], 5);

	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.I32.code,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.END.code)
	], 5);

	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.I32.code,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	], 8);

	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.I32.code,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	]);

	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.I32.code,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.END.code)
	];
	t.sig(SigCache.ii_i);
	t.valid(code1);

	t.sig0(SigCache.arr_if, SigCache.arr_i);
	t.TypeError(code1, 7);

	var code2: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.F32.code,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	];
	t.sig(SigCache.ii_i);
	t.TypeError(code2, 9);
}

def test_if2(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), BpTypeCode.I32.code,
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.END.code)
	], 7);
}

def test_if_end(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var i_i = byte.!(t.addSig(SigCache.i_i).heaptype_index);
	var i_f = byte.!(t.addSig(SigCache.i_f).heaptype_index);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.END.code)
	]);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.END.code)
	], 9);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_f,
		u8.!(Opcode.F32_CONST.code), 3, 3, 3, 3,
		u8.!(Opcode.END.code)
	], 12);

}

def test_if_unr1(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	var i_i = byte.!(t.addSig(SigCache.i_i).heaptype_index);
	var v_i = byte.!(t.addSig(SigCache.v_i).heaptype_index);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), v_i,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	]);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), v_i,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	], 6);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.I64_CONST.code), 5,
		u8.!(Opcode.END.code)
	], 10);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), i_i,
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	]);
}
def test_if_unr2(t: CodeValidatorTester) {
	t.sig(SigCache.i_v);
	var i_i = byte.!(t.addSig(SigCache.i_i).heaptype_index);
	var v_i = byte.!(t.addSig(SigCache.v_i).heaptype_index);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	], 8);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code),
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	], 13);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code),
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	], 13);
}

def test_select(t: CodeValidatorTester) {
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.SELECT.code)
	];
	for (a in types) {
		for (b in types) {
			t.sig0([a, b], [a]);
			if (a == b) t.valid(code);
			else t.TypeError(code, 7);
		}
	}
}

def test_selectn(t: CodeValidatorTester) {
	var types = [ValueType.I32, ValueTypes.FUNCREF, ValueTypes.EXTERNREF];
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.SELECT.code)
	];
	for (a in types) {
		for (b in types) {
			t.sig0([a, b], [a]);
			if (a == b && ValueTypes.isNumeric(a)) t.valid(code);
			else t.TypeError(code, 7);
		}
	}
}

def test_selectt(t: CodeValidatorTester) {
	var cases = [
		(BpTypeCode.I32.code, ValueType.I32),
		(BpTypeCode.FUNCREF.code, ValueTypes.FUNCREF),
		(BpTypeCode.EXTERNREF.code, ValueTypes.EXTERNREF)
	];
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.SELECT_T.code), 1,
		0 /*tpos*/
	];
	var tpos = 8;
	for (a in cases) {
		code[tpos] = a.0;
		for (b in cases) {
			t.sig0([a.1, b.1], [a.1]);
			if (ValueTypes.isAssignable(b.1, a.1)) t.valid(code);
			else t.TypeError(code, 7);
			t.sig0([b.1, a.1], [a.1]);
			if (ValueTypes.isAssignable(b.1, a.1)) t.valid(code);
			else t.TypeError(code, 7);
			t.sig0([a.1, a.1], [b.1]);
			if (ValueTypes.isAssignable(a.1, b.1)) t.valid(code);
			else t.TypeError(code, 10);
		}
	}
}

def test_loop0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		u8.!(Opcode.LOOP.code), EB,
		u8.!(Opcode.END.code)
	]);
	t.sig(SigCache.v_i);
	t.valid([
		u8.!(Opcode.LOOP.code), BpTypeCode.I32.code,
		u8.!(Opcode.UNREACHABLE.code),
		u8.!(Opcode.END.code)
	]);
	t.sig(SigCache.v_i);
	t.valid([
		u8.!(Opcode.LOOP.code), BpTypeCode.I32.code,
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOOP.code), BpTypeCode.I32.code,
		u8.!(Opcode.I64_CONST.code), 0,
		u8.!(Opcode.END.code)
	], 5);
	t.TypeError([
		u8.!(Opcode.LOOP.code), BpTypeCode.I64.code,
		u8.!(Opcode.I64_CONST.code), 0,
		u8.!(Opcode.END.code)
	], 6);
}

def test_loop_br(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.valid([
		u8.!(Opcode.LOOP.code), EB,
		u8.!(Opcode.BR.code), 0,
		u8.!(Opcode.END.code)
	]);
	t.valid([
		u8.!(Opcode.LOOP.code), EB,
		u8.!(Opcode.BR.code), 1,
		u8.!(Opcode.END.code)
	]);
	t.invalid(WasmError.OOB_LABEL, [
		u8.!(Opcode.LOOP.code), EB,
		u8.!(Opcode.BR.code), 2,
		u8.!(Opcode.END.code)
	], 3);
	t.sig(SigCache.v_i);
	t.valid([
		u8.!(Opcode.LOOP.code), BpTypeCode.I32.code,
		u8.!(Opcode.BR.code), 0,
		u8.!(Opcode.END.code)
	]);
	t.valid([
		u8.!(Opcode.LOOP.code), BpTypeCode.I32.code,
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.BR.code), 1,
		u8.!(Opcode.END.code)
	]);
}

def test_loopv(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v).heaptype_index);
	var i_i = byte.!(t.addSig(SigCache.i_i).heaptype_index);
	var f_f = byte.!(t.addSig(SigCache.f_f).heaptype_index);
	var i_f = byte.!(t.addSig(SigCache.i_f).heaptype_index);

	t.sig(SigCache.if_v);
	t.TypeError([
		u8.!(Opcode.LOOP.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	], 1);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.LOOP.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	], 3);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOOP.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	]);
}

def test_blockp1(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v).heaptype_index);
	var f_v = byte.!(t.newSig(SigCache.arr_f, SigCache.arr_v).heaptype_index);

	t.sig(SigCache.if_v);
	t.TypeError([
		u8.!(Opcode.BLOCK.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	], 1);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	], 3);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BLOCK.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), i_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	], 3);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), f_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BLOCK.code), f_v,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.END.code)
	], 3);
}

def test_blockp2(t: CodeValidatorTester) {
	var i_v = byte.!(t.addSig(SigCache.i_v).heaptype_index);
	var f_f = byte.!(t.addSig(SigCache.f_f).heaptype_index);
	var f_l = byte.!(t.addSig(SigCache.f_l).heaptype_index);

	t.sig(SigCache.if_v);
	t.TypeError([
		u8.!(Opcode.BLOCK.code), f_f,
		u8.!(Opcode.END.code)
	], 1);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BLOCK.code), f_f,
		u8.!(Opcode.END.code),
		u8.!(Opcode.DROP.code)
	], 3);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), f_f,
		u8.!(Opcode.END.code),
		u8.!(Opcode.DROP.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), f_f,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.END.code),
		u8.!(Opcode.DROP.code)
	], 8);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), f_l,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.I64_CONST.code), 0,
		u8.!(Opcode.END.code),
		u8.!(Opcode.DROP.code)
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.BLOCK.code), f_l,
		u8.!(Opcode.DROP.code),
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.END.code),
		u8.!(Opcode.DROP.code)
	], 8);
}

def test_blockv2(t: CodeValidatorTester) {
	// TODO
}

def test_blockinv(t: CodeValidatorTester) {
	t.sig(SigCache.i_i);
	t.invalid(WasmError.INVALID_BLOCK_TYPE, [
		u8.!(Opcode.BLOCK.code), 33,
		u8.!(Opcode.END.code)
	], 2);
}

def test_unterm(t: CodeValidatorTester) {
	t.invalid(WasmError.UNTERMINATED_BODY, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.IF.code), EB
	], 6);
	t.invalid(WasmError.UNTERMINATED_BODY, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.ELSE.code)
	], 7);
	t.sig(SigCache.v_v);
	t.invalid(WasmError.OOB_LABEL, [u8.!(Opcode.END.code)], 2);
}

def test_else0(t: CodeValidatorTester) {
	t.sig(SigCache.v_v);
	t.invalid(WasmError.MISMATCHED_ELSE, [u8.!(Opcode.ELSE.code)], 1);

	t.invalid(WasmError.MISMATCHED_ELSE, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.IF.code), EB,
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.ELSE.code),
		u8.!(Opcode.END.code)
	], 6);

}
def isSimpleOp(op: Opcode) -> bool {
	return op.prefix == 0 && Opcodes.attributes[op.tag].SHORT_OP;
}

def test_simple_ops_v(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		t.sig(op.sig);
		for (i < op.sig.params.length) {
			code.put(u8.!(Opcode.LOCAL_GET.code));
			code.put(byte.!(i));
		}
		code.put(u8.!(op.code));
		t.valid(code.extract());
	}
}

def test_simple_ops_r(t: CodeValidatorTester) {
	var code = Vector<byte>.new();
	var types = [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		// Test all possible (expected) return types for all simple opcodes.
		for (rt in types) {
			t.sig0(op.sig.params, [rt]);
			for (i < op.sig.params.length) {
				code.put(u8.!(Opcode.LOCAL_GET.code));
				code.put(byte.!(i));
			}
			code.put(u8.!(op.code));
			if (op.sig.results.length == 1 && op.sig.results[0] == rt) {
				t.valid(code.extract());
			} else {
				var pt = code.length + 1;
				t.TypeError(code.extract(), pt);
			}
		}
	}

}

def test_simple_ops0(t: CodeValidatorTester) {
	var template: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code),
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.v_i); // for proper local numbering
	var locals = [
		t.addLocal(ValueType.I32),
		t.addLocal(ValueType.I64),
		t.addLocal(ValueType.F32),
		t.addLocal(ValueType.F64)
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 0) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l);
			template[opcode_pt] = u8.!(op.code);
			var pt = template.length + 9;
			t.TypeError(template, pt);
		}
	}
}

def test_simple_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code),
		/* local_pt */0,
		/* opcode_pt */0
	];
	var local_pt = 1, opcode_pt = 2;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[opcode_pt] = u8.!(op.code);
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_simple_ops2(t: CodeValidatorTester) {
	var template: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code),
		/* local0_pt */0,
		u8.!(Opcode.LOCAL_GET.code),
		/* local1_pt */0,
		/* opcode_pt */0
	];
	var local0_pt = 1, local1_pt = 3, opcode_pt = 4;

	t.sig(SigCache.ii_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (!isSimpleOp(op)) continue;
		if (op.sig.params.length != 2) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local0_pt] = 0;
			template[local1_pt] = byte.!(l.1);
			template[opcode_pt] = u8.!(op.code);
			if (l.0 == op.sig.params[1]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}

			template[local0_pt] = byte.!(l.1);
			template[local1_pt] = 1;
			template[opcode_pt] = u8.!(op.code);
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 8;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_memindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addMemory(1, Max.Set(1));
	t.valid([
		u8.!(Opcode.MEMORY_SIZE.code), 0
	]);
	t.valid([
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.MEMORY_GROW.code), 0
	]);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		u8.!(Opcode.MEMORY_SIZE.code), 1
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.MEMORY_GROW.code), 1
	], 4);

	// expect a zero byte if no multi-memory
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		u8.!(Opcode.MEMORY_SIZE.code), 0x80, 0
	], 2);
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.MEMORY_GROW.code), 0x80, 0
	], 4);

	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.valid([
		u8.!(Opcode.MEMORY_SIZE.code), 0x80, 0
	]);
	t.valid([
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.MEMORY_GROW.code), 0x80, 0
	]);
}

def test_memindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.MEMORY_SIZE.code), 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.MEMORY_GROW.code), 0
	], 4);
	// allow a full LEB if multi-memory
	t.setExtensions(Extension.MULTI_MEMORY);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.MEMORY_SIZE.code), 0x80, 0
	], 2);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.MEMORY_GROW.code), 0x80, 0
	], 4);
}

def test_tabindex1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	t.valid([
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.CALL_INDIRECT.code), 0, 0
	]);
	t.valid([
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.CALL_INDIRECT.code), 0, 0x80, 0
	]);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.CALL_INDIRECT.code), 0, 1
	], 5);
}

def test_tabindex2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.CALL_INDIRECT.code), 0, 0
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.CALL_INDIRECT.code), 0, 0x80, 0
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.CALL_INDIRECT.code), 0, 1
	], 5);
}

def test_retcall1(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	var code1: Array<byte> = [
		u8.!(Opcode.RETURN_CALL.code), 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.TAIL_CALL);
	t.valid(code1);

	var f2 = t.newFunction(SigCache.v_v, [u8.!(Opcode.END.code)]);
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.RETURN_CALL.code), byte.!(f2.func_index)
	], 1);
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.RETURN_CALL.code), byte.!(f2.func_index),
		u8.!(Opcode.I32_CONST.code), 1
	], 1);

	var f3 = t.newFunction(SigCache.v_l, [u8.!(Opcode.END.code)]);
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.RETURN_CALL.code), byte.!(f3.func_index)
	], 1);
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.RETURN_CALL.code), byte.!(f3.func_index),
		u8.!(Opcode.I32_CONST.code), 2
	], 1);
}

def test_retcall2(t: CodeValidatorTester) {
	t.sig(SigCache.v_i);
	t.addTable(1, 1, null);
	var code1: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.RETURN_CALL_INDIRECT.code), 0, 0
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.TAIL_CALL);
	t.valid(code1);

	var s2 = t.addSig(SigCache.v_v).heaptype_index;
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.RETURN_CALL_INDIRECT.code), byte.view(s2), 0
	], 3);
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.I32_CONST.code), 5,
		u8.!(Opcode.RETURN_CALL_INDIRECT.code), byte.view(s2), 0,
		u8.!(Opcode.I32_CONST.code), 2
	], 3);
}

def test_invalid1(t: CodeValidatorTester) {
	t.invalid(WasmError.INVALID_OPCODE, [0xFF], 1);
}

def test_invalid2(t: CodeValidatorTester) {
	var code: Array<byte> = [0];
	for (i < 256) {
		var b = byte.!(i);
		if (Opcodes.isOneByte(b)) continue;
		if (Opcodes.isPrefix(b)) continue;
		code[0] = b;
		t.invalid(WasmError.INVALID_OPCODE, code, 1);
	}
}

def test_prefix_ops1(t: CodeValidatorTester) {
	var template: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code),
		/* local_pt */0,
		/* prefix_pt */0,
		/* opcode_pt */0,
		/* for second byte, if any */0
	];
	var local_pt = 1, prefix_pt = 2, opcode_pt = 3;

	t.sig(SigCache.i_i); // for proper local numbering
	var locals = [
		(ValueType.I32, t.addLocal(ValueType.I32)),
		(ValueType.I64, t.addLocal(ValueType.I64)),
		(ValueType.F32, t.addLocal(ValueType.F32)),
		(ValueType.F64, t.addLocal(ValueType.F64))
	];
	for (op in Opcode) {
		if (op.prefix == 0) continue;
		if (op.prefix == 0xFD) continue; // TODO: simd
		if (op.prefix == 0xFE) continue; // TODO: prefix for atomics
		if (op.sig == null) continue;
		if (op.sig.params.length != 1) continue;
		t.sig(op.sig);
		for (l in locals) {
			template[local_pt] = byte.!(l.1);
			template[prefix_pt] = op.prefix;
			if (Opcodes.page_by_prefix[op.prefix].oneByte) {
				template[opcode_pt  ] = u8.!(op.code);
				template[opcode_pt+1] = u8.!(Opcode.NOP.code);
			} else {
				template[opcode_pt  ] = op14l(op.code);
				template[opcode_pt+1] = op14h(op.code);
			}
			if (l.0 == op.sig.params[0]) {
				t.valid(template);
			} else {
				var pt = template.length + 6;
				t.TypeError(template, pt);
			}
		}
	}
}

def test_ref_null(t: CodeValidatorTester) {
	t.TypeError([u8.!(Opcode.REF_NULL.code), BpTypeCode.EXTERNREF.code], 3);

	t.sig(SigCache.v_e);
	t.valid([u8.!(Opcode.REF_NULL.code), BpTypeCode.EXTERNREF.code]);
	t.TypeError([u8.!(Opcode.REF_NULL.code), BpTypeCode.FUNCREF.code], 3);

	t.sig(SigCache.v_g);
	t.valid([u8.!(Opcode.REF_NULL.code), BpTypeCode.FUNCREF.code]);
	t.TypeError([u8.!(Opcode.REF_NULL.code), BpTypeCode.EXTERNREF.code], 3);
	t.invalid(WasmError.INVALID_TYPE, [u8.!(Opcode.REF_NULL.code), BpTypeCode.I32.code], 2);
}

def test_ref_is_null(t: CodeValidatorTester) {
	t.TypeError([u8.!(Opcode.REF_IS_NULL.code)], 1);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.REF_IS_NULL.code)
	];
	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
	t.sig(SigCache.e_v);
	t.TypeError(code1, 4);
	t.sig(SigCache.g_i);
	t.valid(code1);
	t.sig(SigCache.e_i);
	t.valid(code1);
}

def test_ref_func(t: CodeValidatorTester) {
	t.invalid(WasmError.OOB_INDEX, [u8.!(Opcode.REF_FUNC.code), 11], 2);
	var f2 = t.newFunction(SigCache.v_v, [u8.!(Opcode.END.code)]);
	var code1: Array<byte> = [u8.!(Opcode.REF_FUNC.code), byte.!(f2.func_index)];
	t.sig(SigCache.v_g);
	t.invalid(WasmError.ILLEGAL_FUNCREF, code1, 1);
	f2.reffed = true;
	t.valid(code1);
	t.sig(SigCache.i_i);
	t.TypeError(code1, 3);
	t.sig(SigCache.v_e);
	t.TypeError(code1, 3);
}

def test_ref_as_non_null(t: CodeValidatorTester) {
	var nft = ValueTypes.RefFunc(true, SigCache.i_i), ft = ValueTypes.RefFunc(false, SigCache.i_i);
	t.sig0([nft], [ft]);
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.REF_AS_NON_NULL.code)];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.valid(code1);
	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
	t.sig0([nft], SigCache.arr_i);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 4);
}

def test_br_on_null(t: CodeValidatorTester) {
	var nft = ValueTypes.RefFunc(true, SigCache.i_i), ft = ValueTypes.RefFunc(false, SigCache.i_i);
	t.sig0([nft], [ft]);
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.BR_ON_NULL.code), 0];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
	t.valid([
		u8.!(Opcode.BLOCK.code), EB,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_ON_NULL.code), 0,
		u8.!(Opcode.BR.code), 1,
		u8.!(Opcode.END.code),
		u8.!(Opcode.UNREACHABLE.code)
	]);

	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
}

def test_br_on_non_null(t: CodeValidatorTester) {
	var nft = ValueTypes.RefFunc(true, SigCache.i_i), ft = ValueTypes.RefFunc(false, SigCache.i_i);
	t.sig0([nft], [ft]);
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.BR_ON_NON_NULL.code), 0, u8.!(Opcode.UNREACHABLE.code)];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.valid(code1);
	t.invalid(WasmError.TYPE_MISMATCH, [
		u8.!(Opcode.BLOCK.code), EB,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_ON_NON_NULL.code), 0,
		u8.!(Opcode.BR.code), 1,
		u8.!(Opcode.END.code),
		u8.!(Opcode.UNREACHABLE.code)
	], 7);
	t.valid([
		u8.!(Opcode.BLOCK.code), EB,
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.BR_ON_NON_NULL.code), 1,
		u8.!(Opcode.END.code),
		u8.!(Opcode.UNREACHABLE.code)
	]);

	t.sig(SigCache.i_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
}

def test_data_drop(t: CodeValidatorTester) {
	t.addData(0, [0]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.DATA_DROP.prefix, u8.!(Opcode.DATA_DROP.code), 0];
	t.invalid(WasmError.MISSING_DATA_COUNT, code1, 1);

	t.module.explicit_data_count = 1;
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.DATA_DROP.prefix, u8.!(Opcode.DATA_DROP.code), 1], 3);
}

def test_memory_init(t: CodeValidatorTester) {
	t.addMemory(1, Max.Set(1));
	t.addData(0, [0]);
	t.module.explicit_data_count = 1;
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_INIT.prefix, u8.!(Opcode.MEMORY_INIT.code), 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.MEMORY_INIT.prefix, u8.!(Opcode.MEMORY_INIT.code), 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.MEMORY_INIT.prefix, u8.!(Opcode.MEMORY_INIT.code), 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_memory_copy(t: CodeValidatorTester) {
	t.addMemory(1, Max.Set(1));
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_COPY.prefix, u8.!(Opcode.MEMORY_COPY.code), 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.MEMORY_COPY.prefix, u8.!(Opcode.MEMORY_COPY.code), 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.MEMORY_COPY.prefix, u8.!(Opcode.MEMORY_COPY.code), 1, 0
	];
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, code3, 9);
}

def test_memory_fill(t: CodeValidatorTester) {
	t.addMemory(1, Max.Set(1));
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.MEMORY_FILL.prefix, u8.!(Opcode.MEMORY_FILL.code), 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.MEMORY_FILL.prefix, u8.!(Opcode.MEMORY_FILL.code), 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.MEMORY_FILL.prefix, u8.!(Opcode.MEMORY_FILL.code), 1
	];
	t.invalid(WasmError.EXPECTED_ZERO_BYTE, code3, 9);
}

def test_table_init(t: CodeValidatorTester) {
	t.addTable(1, 1, [1]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.TABLE_INIT.prefix, u8.!(Opcode.TABLE_INIT.code), 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.TABLE_INIT.prefix, u8.!(Opcode.TABLE_INIT.code), 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.TABLE_INIT.prefix, u8.!(Opcode.TABLE_INIT.code), 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_table_copy1(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [Opcode.TABLE_COPY.prefix, u8.!(Opcode.TABLE_COPY.code), 0, 0];
	t.TypeError(code1, 1);

	var code2: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.TABLE_COPY.prefix, u8.!(Opcode.TABLE_COPY.code), 0, 0
	];
	t.valid(code2);
	var code3: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.TABLE_COPY.prefix, u8.!(Opcode.TABLE_COPY.code), 1, 0
	];
	t.invalid(WasmError.OOB_INDEX, code3, 9);
}

def test_table_copy2(t: CodeValidatorTester) {
	var table1 = TableDecl.new(ValueTypes.EXTERNREF, SizeConstraint(false, 0, Max.None));
	var table2 = TableDecl.new(ValueTypes.FUNCREF, SizeConstraint(false, 0, Max.None));
	t.module.addDecl(table1);
	t.module.addDecl(table2);
	t.sig(SigCache.v_v);
	var code1: Array<byte> = [
		u8.!(Opcode.I32_CONST.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		u8.!(Opcode.I32_CONST.code), 2,
		Opcode.TABLE_COPY.prefix, u8.!(Opcode.TABLE_COPY.code), byte.!(table1.table_index), byte.!(table2.table_index)
	];
	t.TypeError(code1, 7);
}

def test_elem_drop(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.v_v);

	t.valid([Opcode.ELEM_DROP.prefix, u8.!(Opcode.ELEM_DROP.code), 0]);
	t.invalid(WasmError.OOB_INDEX, [Opcode.ELEM_DROP.prefix, u8.!(Opcode.ELEM_DROP.code), 1], 3);
}

def test_table_get(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.v_g);
	t.sig(SigCache.v_e);
	t.invalid(WasmError.TYPE_MISMATCH, [u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.TABLE_GET.code), 0], 5);
	t.invalid(WasmError.OOB_INDEX, [u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.TABLE_GET.code), 1], 4);
}

def test_table_set(t: CodeValidatorTester) {
	t.addTable(1, 0, [0]);
	t.sig(SigCache.g_v);
	var code1: Array<byte> = [u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.TABLE_SET.code), 0];
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [u8.!(Opcode.I32_CONST.code), 0, u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.TABLE_SET.code), 2], 6);
	t.sig(SigCache.e_v);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 5);
}

def test_table_grow(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig0([ValueTypes.EXTERNREF, ValueType.I32], SigCache.arr_i);
	var code1: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.LOCAL_GET.code), 1, Opcode.TABLE_GROW.prefix, u8.!(Opcode.TABLE_GROW.code), 0];
	t.TypeError(code1, 5);
	t.sig0([ValueTypes.FUNCREF, ValueType.I32], SigCache.arr_i);
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.LOCAL_GET.code), 1, Opcode.TABLE_GROW.prefix, u8.!(Opcode.TABLE_GROW.code), 1], 7);
}

def test_table_size(t: CodeValidatorTester) {
	t.addTable(3, 0, [0, 0, 0]);
	t.sig(SigCache.v_i);
	var code1: Array<byte> = [Opcode.TABLE_SIZE.prefix, u8.!(Opcode.TABLE_SIZE.code), 0];
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [Opcode.TABLE_SIZE.prefix, u8.!(Opcode.TABLE_SIZE.code), 1], 3);
	t.sig(SigCache.v_f);
	t.TypeError(code1, 4);
}

def test_table_fill(t: CodeValidatorTester) {
	t.addTable(1, 1, [0]);
	t.sig0([ValueType.I32, ValueTypes.EXTERNREF, ValueType.I32], SigCache.arr_v);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.LOCAL_GET.code), 2,
		Opcode.TABLE_FILL.prefix, u8.!(Opcode.TABLE_FILL.code), 0
	];
	t.TypeError(code1, 7);
	t.sig0([ValueType.I32, ValueTypes.FUNCREF, ValueType.I32], SigCache.arr_v);
	t.valid(code1);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.LOCAL_GET.code), 2,
		Opcode.TABLE_FILL.prefix, u8.!(Opcode.TABLE_FILL.code), 1
	], 9);
}

def test_call_ref0(t: CodeValidatorTester) {
	var sig_i_i = t.addSig(SigCache.i_i);
	var sig_v_v = t.addSig(SigCache.v_v);
	var ref_i_i = ValueTypes.RefFunc(false, sig_i_i);
	var ref_v_v = ValueTypes.RefFunc(false, sig_v_v);

	var code1_i_i: Array<byte> = [u8.!(Opcode.CALL_REF.code), heapIndexByte(sig_i_i)];
	var code1_v_v: Array<byte> = [u8.!(Opcode.CALL_REF.code), heapIndexByte(sig_v_v)];
	var code2_i_i: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.CALL_REF.code), heapIndexByte(sig_i_i)];
	var code2_v_v: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.CALL_REF.code), heapIndexByte(sig_i_i)];

	t.sig(SigCache.i_i);
	t.invalid(WasmError.INVALID_OPCODE, [u8.!(Opcode.CALL_REF.code), heapIndexByte(sig_i_i)], 1);
	t.setExtensions(Extension.FUNCTION_REFERENCES);

	for (sig in [sig_i_i, sig_v_v]) {
		var code1: Array<byte> = [u8.!(Opcode.CALL_REF.code), heapIndexByte(sig)];
		t.sig(sig);
		t.TypeError(code1, 1);

		t.sig(newSig([ref_v_v], SigCache.arr_v));
		var code2: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.CALL_REF.code), heapIndexByte(sig)];
		if (sig == sig_v_v) t.valid(code2);
		else t.TypeError(code2, 3);
	}

	var code3: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.LOCAL_GET.code), 1, u8.!(Opcode.CALL_REF.code), heapIndexByte(sig_i_i)];
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_v);
	t.TypeError(code3, 7);
	t.sig0([ValueType.I32, ref_i_i], SigCache.arr_i);
	t.valid(code3);
	t.sig0([ValueType.F32, ref_i_i], SigCache.arr_i);
	t.TypeError(code3, 5);
}

def test_retcall_ref0(t: CodeValidatorTester) {
	var sig_v_v = t.addSig(SigCache.v_v);
	var sig_i_i = t.addSig(SigCache.i_i);
	var sig_i_v = t.addSig(SigCache.i_v);
	var sig_i_l = t.addSig(SigCache.i_l);

	t.sig(SigCache.i_i);
	var ref_v_v = ValueTypes.RefFunc(false, sig_v_v);
	var ref_i_i = ValueTypes.RefFunc(false, sig_i_i);
	var ref_i_v = ValueTypes.RefFunc(false, sig_i_v);
	var ref_i_l = ValueTypes.RefFunc(false, sig_i_l);
	var code1: Array<byte> = [u8.!(Opcode.RETURN_CALL_REF.code), heapIndexByte(sig_i_i)];
	t.invalid(WasmError.INVALID_OPCODE, code1, 1);

	t.setExtensions(Extension.FUNCTION_REFERENCES);
	t.TypeError(code1, 1);

	for (sig in [sig_v_v, sig_i_i, sig_i_v, sig_i_l]) {
		t.sig(sig_v_v);
		var code2: Array<byte> = [u8.!(Opcode.LOCAL_GET.code), 0, u8.!(Opcode.RETURN_CALL_REF.code), heapIndexByte(sig)];
		var ref = ValueType.Ref(false, HeapType.Func(sig));
		t.sig0([ref], SigCache.arr_v);
		if (sig == sig_v_v) t.valid(code2);
		else t.TypeError(code2, 3);

		var code3: Array<byte> = [
			u8.!(Opcode.LOCAL_GET.code), 0,
			u8.!(Opcode.LOCAL_GET.code), 1,
			u8.!(Opcode.RETURN_CALL_REF.code),
			heapIndexByte(sig)
		];

		for (p in [ValueType.I32, ValueType.I64, ValueType.F32, ValueType.F64]) {
			t.sig0([p, ref], SigCache.arr_v);
			if (sig == sig_v_v) t.valid(code3);
			else if (sig.params.length == 1 && sig.params[0] == p && sig.results.length == 0) t.valid(code3);
			else t.TypeError(code3, 5);

			t.sig0([p, ref], [p]);
			if (sig.results.length == 1 && sig.results[0] == p &&
				sig.params.length == 1 && sig.params[0] == p) t.valid(code3);
			else t.TypeError(code3, 5);
		}
	}
}

def unpackedT = StorageType(_, Packedness.UNPACKED, _);

def heapIndexByte(ht: HeapTypeDecl) -> byte {
	return byte.!(ht.heaptype_index);
}

def test_ref_eq(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st = t.newStruct([unpackedT(ValueType.F32, true)]);
	var cases = [
		ValueType.I32, ValueType.F32, ValueTypes.RefStruct(false, st), ValueTypes.ANYREF, ValueTypes.EQREF, ValueTypes.STRUCTREF, ValueTypes.I31REF
	];
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		u8.!(Opcode.REF_EQ.code)
	];
	// TODO: test externref and funcref
	for (x in cases) {
		for (y in cases) {
			t.sig0([x, y], SigCache.arr_i);
			if (!ValueTypes.isAssignable(x, ValueTypes.EQREF)) t.TypeError(code1, 5);
			else if (!ValueTypes.isAssignable(y, ValueTypes.EQREF)) t.TypeError(code1, 5);
			else t.valid(code1);
		}
	}
}

def test_struct_new(t: CodeValidatorTester) {
	var st = t.newStruct([unpackedT(ValueType.F32, true)]);
	t.sig(SigCache.d_d);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_NEW.prefix,
		u8.!(Opcode.STRUCT_NEW.code),
		heapIndexByte(st)
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 3);
	t.setExtensions(Extension.GC);
	t.TypeError(code1, 3);
	t.sig(SigCache.f_f);
	t.TypeError(code1, 6);
	t.sig0(SigCache.arr_f, [ValueTypes.RefStruct(false, st)]);
	t.valid(code1);

	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_NEW.prefix,
		u8.!(Opcode.STRUCT_NEW.code),
		byte.view(t.module.heaptypes.length) // oob
	], 5);

	var ft = t.addSig(SigCache.ff_i).heaptype_index;
	t.invalid(WasmError.ILLEGAL_TYPE, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_NEW.prefix,
		u8.!(Opcode.STRUCT_NEW.code),
		byte.view(ft) // func type reference
	], 5);
}

def test_struct_newdef(t: CodeValidatorTester) {
	var cases = [
		(ValueType.F64, true),
		(ValueTypes.RefFunc(true, SigCache.v_v), true),
		(ValueTypes.RefFunc(false, SigCache.i_i), false)
	];

	t.setExtensions(Extension.GC);
	for (c in cases) {
		var st = t.newStruct([unpackedT(c.0, true)]);
		var code1: Array<byte> = [
			Opcode.STRUCT_NEW_DEFAULT.prefix,
			u8.!(Opcode.STRUCT_NEW_DEFAULT.code),
			heapIndexByte(st)
		];

		if (c.1) {
			t.sig(SigCache.d_d);
			t.TypeError(code1, 4);
			t.sig0(SigCache.arr_v, [ValueTypes.RefStruct(false, st)]);
			t.valid(code1);
		} else {
			t.sig(SigCache.d_d);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 1);
			t.sig0(SigCache.arr_v, [ValueTypes.RefStruct(false, st)]);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 1);
		}
	}
}

def test_struct_get(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st = StructDecl.new(true, ValueTypes.NO_HEAPTYPES, [unpackedT(ValueType.I32, true), unpackedT(ValueType.F32, true)]);
	t.module.addDecl(st);

	t.sig0([ValueTypes.RefStruct(false, st)], SigCache.arr_i);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_GET.prefix, u8.!(Opcode.STRUCT_GET.code), heapIndexByte(st), 0
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_GET.prefix, u8.!(Opcode.STRUCT_GET.code), heapIndexByte(st), 1
	], 7);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_GET.prefix, u8.!(Opcode.STRUCT_GET.code), heapIndexByte(st), 2
	], 6);
}

def test_struct_get_su(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	for (pack in Packedness) {
		var st = t.newStruct([StorageType(ValueType.I32, pack, true)]);
		t.sig0([ValueTypes.RefStruct(false, st)], SigCache.arr_i);

		for (opcode in [Opcode.STRUCT_GET_S, Opcode.STRUCT_GET_U, Opcode.STRUCT_GET]) {
			var code1: Array<byte> = [
				u8.!(Opcode.LOCAL_GET.code), 0,
				opcode.prefix, u8.!(opcode.code), heapIndexByte(st), 0
			];
			var ok = (pack == Packedness.UNPACKED) == (opcode == Opcode.STRUCT_GET);
			if (ok) t.valid(code1);
			else t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
		}
	}
}

def test_struct_set(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st = t.newStruct([unpackedT(ValueType.I32, true), unpackedT(ValueType.I32, false)]);

	t.sig0([ValueTypes.RefStruct(false, st)], SigCache.arr_v);
	t.valid([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		Opcode.STRUCT_SET.prefix, u8.!(Opcode.STRUCT_SET.code), heapIndexByte(st), 0
	]);
	t.TypeError([
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I64_CONST.code), 1,
		Opcode.STRUCT_SET.prefix, u8.!(Opcode.STRUCT_SET.code), heapIndexByte(st), 0
	], 5);
	t.invalid(WasmError.ILLEGAL_ASSIGNMENT, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 1,
		Opcode.STRUCT_SET.prefix, u8.!(Opcode.STRUCT_SET.code), heapIndexByte(st), 1
	], 5);
	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.STRUCT_SET.prefix, u8.!(Opcode.STRUCT_SET.code), heapIndexByte(st), 2
	], 6);
}

def test_array_new(t: CodeValidatorTester) {
	var at = t.newArray([unpackedT(ValueType.F64, true)]);
	t.sig(SigCache.f_f);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 6,
		Opcode.ARRAY_NEW.prefix,
		u8.!(Opcode.ARRAY_NEW.code),
		heapIndexByte(at)
	];
	t.invalid(WasmError.INVALID_OPCODE, code1, 5);
	t.setExtensions(Extension.GC);
	t.TypeError(code1, 5);
	t.sig(SigCache.d_d);
	t.TypeError(code1, 8);
	t.sig0(SigCache.arr_d, [ValueTypes.RefArray(false, at)]);
	t.valid(code1);

	t.invalid(WasmError.OOB_INDEX, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 7,
		Opcode.ARRAY_NEW.prefix,
		u8.!(Opcode.ARRAY_NEW.code),
		byte.view(t.module.heaptypes.length) // oob
	], 7);

	var ft = t.addSig(SigCache.dd_i).heaptype_index;
	t.invalid(WasmError.ILLEGAL_TYPE, [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 8,
		Opcode.ARRAY_NEW.prefix,
		u8.!(Opcode.ARRAY_NEW.code),
		byte.view(ft) // func type reference
	], 7);
}

def test_array_newdef(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var cases = [
		(ValueType.F64, true),
		(ValueTypes.RefFunc(true, SigCache.v_v), true),
		(ValueTypes.RefFunc(false, SigCache.i_i), false)
	];

	for (c in cases) {
		var at = t.newArray([unpackedT(c.0, true)]);
		var code1: Array<byte> = [
			u8.!(Opcode.I32_CONST.code), 5,
			Opcode.ARRAY_NEW_DEFAULT.prefix,
			u8.!(Opcode.ARRAY_NEW_DEFAULT.code),
			heapIndexByte(at)
		];

		if (c.1) {
			t.sig(SigCache.d_d);
			t.TypeError(code1, 6);
			t.sig0(SigCache.arr_v, [ValueTypes.RefArray(false, at)]);
			t.valid([
				u8.!(Opcode.I32_CONST.code), 5,
				Opcode.ARRAY_NEW_DEFAULT.prefix,
				u8.!(Opcode.ARRAY_NEW_DEFAULT.code),
				heapIndexByte(at)
			]);
		} else {
			t.sig(SigCache.d_d);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
			t.sig0(SigCache.arr_v, [ValueTypes.RefArray(false, at)]);
			t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
		}
	}
}

def test_array_get(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.I64, true)]);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 3,
		Opcode.ARRAY_GET.prefix, u8.!(Opcode.ARRAY_GET.code), heapIndexByte(at)
	];
	t.sig(SigCache.f_f);
	t.TypeError(code1, 5);
	t.sig(SigCache.i_i);
	t.TypeError(code1, 5);
	t.sig0([ValueTypes.RefArray(false, at)], SigCache.arr_i);
	t.TypeError(code1, 8);
	t.sig0([ValueTypes.RefArray(false, at)], SigCache.arr_l);
	t.valid(code1);
}

def test_array_get_su(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	for (pack in Packedness) {
		var at = t.newArray([StorageType(ValueType.I32, pack, true)]);
		t.sig0([ValueTypes.RefArray(false, at)], SigCache.arr_i);
		for (opcode in [Opcode.ARRAY_GET_S, Opcode.ARRAY_GET_U, Opcode.ARRAY_GET]) {
			var code1: Array<byte> = [
				u8.!(Opcode.LOCAL_GET.code), 0,
				u8.!(Opcode.I32_CONST.code), 11,
				opcode.prefix, u8.!(opcode.code), heapIndexByte(at), 0
			];
			var ok = (pack == Packedness.UNPACKED) == (opcode == Opcode.ARRAY_GET);
			if (ok) t.valid(code1);
			else t.invalid(WasmError.ILLEGAL_TYPE, code1, 5);
		}
	}
}

def test_array_set(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.F32, true)]);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.I32_CONST.code), 3,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.ARRAY_SET.prefix, u8.!(Opcode.ARRAY_SET.code), heapIndexByte(at)
	];
	t.sig(SigCache.ff_f);
	t.TypeError(code1, 7);
	t.sig(SigCache.ii_i);
	t.TypeError(code1, 7);
	t.sig0([ValueTypes.RefArray(false, at), ValueType.I32], SigCache.arr_i);
	t.TypeError(code1, 7);
	t.sig0([ValueTypes.RefArray(false, at), ValueType.F32], SigCache.arr_f);
	t.TypeError(code1, 10);
	t.sig0([ValueTypes.RefArray(false, at), ValueType.F32], SigCache.arr_v);
	t.valid(code1);
}

def test_array_len(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.F64, true)]);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.ARRAY_LEN.prefix, u8.!(Opcode.ARRAY_LEN.code), heapIndexByte(at)
	];
	t.sig(SigCache.f_f);
	t.TypeError(code1, 3);
	t.sig(SigCache.i_i);
	t.TypeError(code1, 3);
	t.sig0([ValueTypes.RefArray(false, at)], SigCache.arr_d);
	t.TypeError(code1, 6);
	t.sig0([ValueTypes.RefArray(false, at)], SigCache.arr_i);
	t.valid(code1);
}

def test_array_new_fixed(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.F64, true)]);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.ARRAY_NEW_FIXED.prefix, u8.!(Opcode.ARRAY_NEW_FIXED.code), heapIndexByte(at), 1
	];
	var results: Array<ValueType> = [ValueTypes.RefArray(false, at)];
	t.sig(SigCache.dd_d);
	t.TypeError(code1, 7);
	t.sig0(SigCache.arr_d, results);
	t.valid(code1);

	var code = Vector<byte>.new();
	var params = Vector<ValueType>.new();
	for (count < 5) {
		code.resize(0);
		for (i < count) code.put(u8.!(Opcode.LOCAL_GET.code)).put(byte.view(i));
		code.puta([Opcode.ARRAY_NEW_FIXED.prefix, u8.!(Opcode.ARRAY_NEW_FIXED.code), heapIndexByte(at), byte.view(count)]);
		for (i < count) params.put(ValueType.F64);

		var raw = code.extract();
		t.sig0(params.copy(), results);
		t.valid(raw);

		if (count > 0) {
			params[0] = ValueType.I32;
			t.sig0(params.extract(), results);
			t.TypeError(raw, raw.length - 3);
		}
	}
}

def test_array_new_data(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var at = t.newArray([unpackedT(ValueType.I32, true)]);
	var rat = t.newArray([unpackedT(ValueTypes.ANYREF, true)]);
	t.addData(0, [0]);
	t.module.explicit_data_count = 1;
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.ARRAY_NEW_DATA.prefix, u8.!(Opcode.ARRAY_NEW_DATA.code), heapIndexByte(at), 0
	];
	var results: Array<ValueType> = [ValueTypes.RefArray(false, at)];
	t.sig0([ValueType.I32, ValueType.F32], results);
	t.TypeError(code1, 5);
	t.sig0([ValueType.I32, ValueType.I32], results);
	t.valid(code1);

	var code2: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.ARRAY_NEW_DATA.prefix, u8.!(Opcode.ARRAY_NEW_DATA.code), heapIndexByte(at), 1 // data index OOB
	];
	t.invalid(WasmError.OOB_INDEX, code2, 8);

	var code3: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.ARRAY_NEW_DATA.prefix, u8.!(Opcode.ARRAY_NEW_DATA.code), heapIndexByte(rat), 0 // reference array
	];

	results = [ValueTypes.RefArray(false, rat)];
	t.sig0([ValueType.I32, ValueType.I32], results);
	t.invalid(WasmError.ILLEGAL_TYPE, code3, 5);  // ref array cannot be initialized from data
}

def test_array_new_elem(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var aat = t.newArray([unpackedT(ValueTypes.ANYREF, true)]);
	var dat = t.newArray([unpackedT(ValueTypes.EQREF, true)]);

	t.addTable(0, 0, [0]);
	var atable = t.addTableAndElemsOfType(ValueTypes.ANYREF);
	var dtable = t.addTableAndElemsOfType(ValueTypes.EQREF);

	for (i in [
		(aat, atable, true),
		(aat, dtable, true),
		(dat, atable, false),
		(dat, dtable, true)]) { // test all permutations of anyref, dataref

		var code1: Array<byte> = [
			u8.!(Opcode.LOCAL_GET.code), 0,
			u8.!(Opcode.LOCAL_GET.code), 1,
			Opcode.ARRAY_NEW_ELEM.prefix, u8.!(Opcode.ARRAY_NEW_ELEM.code), heapIndexByte(i.0), byte.view(i.1.1.elem_index)
		];
		var results: Array<ValueType> = [ValueTypes.RefArray(false, i.0)];
		t.sig0([ValueType.I32, ValueType.F32], results);
		t.TypeError(code1, 5);
		t.sig0([ValueType.I32, ValueType.I32], results);
		if (i.2) t.valid(code1);
		else t.TypeError(code1, 5);
	}

	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.ARRAY_NEW_ELEM.prefix, u8.!(Opcode.ARRAY_NEW_ELEM.code), heapIndexByte(aat), byte.view(t.module.elems.length)
	];
	var results: Array<ValueType> = [ValueTypes.RefArray(false, aat)];
	t.sig0([ValueType.I32, ValueType.I32], results);
	t.invalid(WasmError.OOB_INDEX, code1, 8); // test out-of-bounds element index
}

def test_i31_new(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.REF_I31.prefix, u8.!(Opcode.REF_I31.code)
	];
	t.sig(SigCache.i_i);
	t.TypeError(code1, 5);
	t.sig(SigCache.f_i);
	t.TypeError(code1, 3);
	t.sig0(SigCache.arr_i, [ValueTypes.I31REF]);
	t.valid(code1);
	t.sig0(SigCache.arr_i, [ValueTypes.ANYREF]);
	t.valid(code1);
}

def test_i31_get_su(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	for (opcode in [Opcode.I31_GET_S, Opcode.I31_GET_U]) {
		var code1: Array<byte> = [
			u8.!(Opcode.LOCAL_GET.code), 0,
			opcode.prefix, u8.!(opcode.code)
		];
		t.sig(SigCache.i_i);
		t.TypeError(code1, 3);
		t.sig(SigCache.f_i);
		t.TypeError(code1, 3);
		t.sig0([ValueTypes.I31REF], SigCache.arr_i);
		t.valid(code1);
		t.sig0([ValueTypes.ANYREF], SigCache.arr_i);
		t.TypeError(code1, 3);
	}
}

def testDeclPairs(t: CodeValidatorTester,
	test: (CodeValidatorTester, HeapTypeDecl, ValueType.Ref, HeapTypeDecl, ValueType.Ref) -> void) {
	var decls = [
		t.newStruct([]),
		t.newStruct([unpackedT(ValueType.I32, false)]),
		t.newStruct([unpackedT(ValueType.I64, false)]),
		t.newArray([unpackedT(ValueType.F32, true)]),
		t.newSig(SigCache.arr_v, SigCache.arr_v)
	];
	var types = Arrays.map(decls, ValueTypes.Ref(false, _));
	for (i < decls.length) {
		for (j < decls.length) {
			test(t, decls[i], types[i], decls[j], types[j]);
		}
	}
}


def test_ref_test0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType.Ref, dj: HeapTypeDecl, djt: ValueType.Ref) {
	t.setExtensions(Extension.GC);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.REF_TEST.prefix, u8.!(Opcode.REF_TEST.code), heapIndexByte(dj)
	];
	t.sig0([dit], SigCache.arr_i);
	t.valid(code1);
	t.sig0([ValueType.I32], SigCache.arr_i);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
}

def test_ref_cast0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType.Ref, dj: HeapTypeDecl, djt: ValueType.Ref) {
	t.setExtensions(Extension.GC);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.REF_CAST.prefix, u8.!(Opcode.REF_CAST.code), heapIndexByte(dj)
	];
	var arr_djt: Array<ValueType> = [djt];
	t.sig0([dit], arr_djt);
	t.valid(code1);
	t.sig0([ValueType.I32], arr_djt);
	t.invalid(WasmError.ILLEGAL_TYPE, code1, 3);
}

def nullableFlags(t1: ValueType, t2: ValueType) -> byte {
	return if(ValueType.Ref.?(t1) && ValueType.Ref.!(t1).nullable, byte.view(1))
		| if(ValueType.Ref.?(t2) && ValueType.Ref.!(t2).nullable, byte.view(2));
}
def test_br_on_cast0(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType.Ref, dj: HeapTypeDecl, djt: ValueType.Ref) {
	t.setExtensions(Extension.GC);
	var flags = nullableFlags(dit, djt);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.BR_ON_CAST.prefix, u8.!(Opcode.BR_ON_CAST.code), flags, 0, heapIndexByte(di), heapIndexByte(dj),
		u8.!(Opcode.UNREACHABLE.code)
	];
	var rt: Array<ValueType> = [djt];
	t.sig0([dit], rt);
	if (ValueTypes.isAssignable(djt, dit)) {
		t.valid(code1);
		t.sig0([ValueType.I32], rt);
		t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
	} else {
		t.invalid(WasmError.ILLEGAL_CAST, code1, 3);
	}
}

def test_br_on_cast1(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);
	var st1 = t.newStruct([]);
	var st2 = t.newStructP([st1], [unpackedT(ValueType.F32, true)]);
	var st1t = ValueTypes.RefStruct(false, st1);
	var st2t = ValueTypes.RefStruct(false, st2);

	for (opcode in [Opcode.NOP, Opcode.DROP, Opcode.UNREACHABLE]) {
		var flags = nullableFlags(st1t, st2t);
		var code1: Array<byte> = [
			u8.!(Opcode.BLOCK.code), BpTypeCode.REF.code, heapIndexByte(st2),
			u8.!(Opcode.LOCAL_GET.code), 0,
			Opcode.BR_ON_CAST.prefix, u8.!(Opcode.BR_ON_CAST.code), flags, 0, heapIndexByte(st1), heapIndexByte(st2),
			u8.!(opcode.code), // drop, nop, or unreachable
			u8.!(Opcode.END.code)
		];

		t.sig0([st1t], [st2t]);
		if (opcode == Opcode.NOP) {
			t.TypeError(code1, 13); // wrong type
		} else if (opcode == Opcode.DROP) {
			t.TypeError(code1, 13); // no value for fallthrough
		} else {
			t.valid(code1);
			t.sig0([st1t], SigCache.arr_v);
			t.TypeError(code1, 14);
		}
	}
}

def shared_br_on_cast_fail0(t: CodeValidatorTester, error: WasmError, from_nullable: bool, to_nullable: bool) {
	t.setExtensions(Extension.GC);
	var st1 = t.newStruct([]);
	var ft = ValueTypes.Ref(from_nullable, st1);
	var tt = ValueTypes.Ref(to_nullable, st1);
	t.sig0([ft], [tt]);
	var flags = nullableFlags(ft, tt);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.BR_ON_CAST_FAIL.prefix, u8.!(Opcode.BR_ON_CAST_FAIL.code), flags, 0, heapIndexByte(st1), heapIndexByte(st1)
	];
	if (error == WasmError.NONE) t.valid(code1);
	else t.invalid(error, code1, 3);
}

def test_br_on_cast_fail0(t: CodeValidatorTester) {
	t.setExtensions(Extension.GC);

	shared_br_on_cast_fail0(t, WasmError.NONE, false, false);
	shared_br_on_cast_fail0(t, WasmError.TYPE_MISMATCH, true, false);
	shared_br_on_cast_fail0(t, WasmError.ILLEGAL_CAST, false, true);
	shared_br_on_cast_fail0(t, WasmError.NONE, true, true);
}

def test_br_on_cast_fail1(t: CodeValidatorTester, di: HeapTypeDecl, dit: ValueType.Ref, dj: HeapTypeDecl, djt: ValueType.Ref) {
	t.setExtensions(Extension.GC);
	var flags = nullableFlags(dit, djt);
	var code1: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.BR_ON_CAST_FAIL.prefix, u8.!(Opcode.BR_ON_CAST_FAIL.code), flags, 0, heapIndexByte(di), heapIndexByte(dj)
	];
	if (!ValueTypes.isAssignable(djt, dit)) {
		t.sig0([dit], [djt]);
		t.invalid(WasmError.ILLEGAL_CAST, code1, 3);
		return;
	}
	t.sig0([ValueType.I32], [dit]);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 3);
	t.sig0([ValueType.I32], [djt]);
	t.invalid(WasmError.TYPE_MISMATCH, code1, 3);

	t.sig0([dit], [djt]);
	var outt = ValueType.Ref(dit.nullable && !djt.nullable, dit.heap);
	if (ValueTypes.isAssignable(outt, djt)) {
		t.valid(code1);
	} else {
		t.TypeError(code1, 3);
	}

	t.sig0([dit], [dit]);
	if (ValueTypes.isAssignable(outt, dit)) {
		t.valid(code1);
	} else {
		t.TypeError(code1, 3);
	}
}

def SIMD_UNOPS = [
	Opcode.V128_NOT,
	Opcode.I8X16_ABS,
	Opcode.I8X16_NEG,
	Opcode.I8X16_POPCNT,
	Opcode.I16X8_EXTEND_LOW_I8X16_S,
	Opcode.I16X8_EXTEND_HIGH_I8X16_S,
	Opcode.I16X8_EXTEND_LOW_I8X16_U,
	Opcode.I16X8_EXTEND_HIGH_I8X16_U,
	Opcode.I64X2_EXTEND_LOW_I32X4_S,
	Opcode.I64X2_EXTEND_HIGH_I32X4_S,
	Opcode.I64X2_EXTEND_LOW_I32X4_U,
	Opcode.I64X2_EXTEND_HIGH_I32X4_U,
	Opcode.I32X4_EXTEND_LOW_I16X8_S,
	Opcode.I32X4_EXTEND_HIGH_I16X8_S,
	Opcode.I32X4_EXTEND_LOW_I16X8_U,
	Opcode.I32X4_EXTEND_HIGH_I16X8_U,
	Opcode.I16X8_EXTADDPAIRWISE_I8X16_S,
	Opcode.I16X8_EXTADDPAIRWISE_I8X16_U,
	Opcode.I16X8_ABS,
	Opcode.I16X8_NEG,
	Opcode.I32X4_ABS,
	Opcode.I32X4_NEG,
	Opcode.I32X4_EXTADDPAIRWISE_I16X8_S,
	Opcode.I32X4_EXTADDPAIRWISE_I16X8_U,
	Opcode.I64X2_ABS,
	Opcode.I64X2_NEG,
	Opcode.F32X4_CEIL,
	Opcode.F32X4_FLOOR,
	Opcode.F32X4_TRUNC,
	Opcode.F32X4_NEAREST,
	Opcode.F32X4_ABS,
	Opcode.F32X4_NEG,
	Opcode.F32X4_SQRT,
	Opcode.F64X2_CEIL,
	Opcode.F64X2_FLOOR,
	Opcode.F64X2_TRUNC,
	Opcode.F64X2_NEAREST,
	Opcode.F64X2_ABS,
	Opcode.F64X2_NEG,
	Opcode.F64X2_SQRT,
	Opcode.I32X4_TRUNC_SAT_F32X4_S,
	Opcode.I32X4_TRUNC_SAT_F32X4_U,
	Opcode.F32X4_CONVERT_I32X4_S,
	Opcode.F32X4_CONVERT_I32X4_U,
	Opcode.I32X4_TRUNC_SAT_F64X2_S_ZERO,
	Opcode.I32X4_TRUNC_SAT_F64X2_U_ZERO,
	Opcode.F64X2_CONVERT_LOW_I32X4_S,
	Opcode.F64X2_CONVERT_LOW_I32X4_U,
	Opcode.F32X4_DEMOTE_F64X2_ZERO,
	Opcode.F64X2_PROMOTE_LOW_F32X4
];

def test_simd_unop1(t: CodeValidatorTester) {
	var code: Array<byte> = [
		Opcode.V128_LOAD.prefix, 0, 0
	];
	t.sig(SigCache.s_s);
	for (op in SIMD_UNOPS) {
		code[1] = byte.view(op.code | 0x80);
		code[2] = byte.view(op.code >> 7);
		t.invalid(WasmError.TYPE_MISMATCH, code, 1);
	}
}

def test_simd_unop2(t: CodeValidatorTester) {
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.V128_LOAD.prefix, 0, 0
	];
	t.sig(SigCache.s_s);
	for (op in SIMD_UNOPS) {
		code[3] = byte.view(op.code | 0x80);
		code[4] = byte.view(op.code >> 7);
		t.valid(code);
	}
}

def test_simd_unop3(t: CodeValidatorTester) {
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.V128_LOAD.prefix, 0, 0
	];
	for (sig in [SigCache.i_i, SigCache.i_s, SigCache.f_s, SigCache.ff_f]) {
		t.sig(sig);
		for (i < 10) { // no need to do all of them
			var op = SIMD_UNOPS[i];
			code[3] = byte.view(op.code | 0x80);
			code[4] = byte.view(op.code >> 7);
			t.TypeError(code, 3);
		}
	}
}

def SIMD_BINOPS = [
	Opcode.I8X16_SWIZZLE,
	Opcode.I8X16_EQ,
	Opcode.I8X16_NE,
	Opcode.I8X16_LT_S,
	Opcode.I8X16_LT_U,
	Opcode.I8X16_GT_S,
	Opcode.I8X16_GT_U,
	Opcode.I8X16_LE_S,
	Opcode.I8X16_LE_U,
	Opcode.I8X16_GE_S,
	Opcode.I8X16_GE_U,
	Opcode.I16X8_EQ,
	Opcode.I16X8_NE,
	Opcode.I16X8_LT_S,
	Opcode.I16X8_LT_U,
	Opcode.I16X8_GT_S,
	Opcode.I16X8_GT_U,
	Opcode.I16X8_LE_S,
	Opcode.I16X8_LE_U,
	Opcode.I16X8_GE_S,
	Opcode.I16X8_GE_U,
	Opcode.I32X4_EQ,
	Opcode.I32X4_NE,
	Opcode.I32X4_LT_S,
	Opcode.I32X4_LT_U,
	Opcode.I32X4_GT_S,
	Opcode.I32X4_GT_U,
	Opcode.I32X4_LE_S,
	Opcode.I32X4_LE_U,
	Opcode.I32X4_GE_S,
	Opcode.I32X4_GE_U,
	Opcode.I64X2_EQ,
	Opcode.I64X2_NE,
	Opcode.I64X2_LT_S,
	Opcode.I64X2_GT_S,
	Opcode.I64X2_LE_S,
	Opcode.I64X2_GE_S,
	Opcode.F32X4_EQ,
	Opcode.F32X4_NE,
	Opcode.F32X4_LT,
	Opcode.F32X4_GT,
	Opcode.F32X4_LE,
	Opcode.F32X4_GE,
	Opcode.F64X2_EQ,
	Opcode.F64X2_NE,
	Opcode.F64X2_LT,
	Opcode.F64X2_GT,
	Opcode.F64X2_LE,
	Opcode.F64X2_GE,
	Opcode.V128_AND,
	Opcode.V128_ANDNOT,
	Opcode.V128_OR,
	Opcode.V128_XOR,
	Opcode.I8X16_NARROW_I16X8_S,
	Opcode.I8X16_NARROW_I16X8_U,
	Opcode.I8X16_ADD,
	Opcode.I8X16_ADD_SAT_S,
	Opcode.I8X16_ADD_SAT_U,
	Opcode.I8X16_SUB,
	Opcode.I8X16_SUB_SAT_S,
	Opcode.I8X16_SUB_SAT_U,
	Opcode.I8X16_MIN_S,
	Opcode.I8X16_MIN_U,
	Opcode.I8X16_MAX_S,
	Opcode.I8X16_MAX_U,
	Opcode.I8X16_AVGR_U,
	Opcode.I16X8_ADD,
	Opcode.I16X8_ADD_SAT_S,
	Opcode.I16X8_ADD_SAT_U,
	Opcode.I16X8_SUB,
	Opcode.I16X8_SUB_SAT_S,
	Opcode.I16X8_SUB_SAT_U,
	Opcode.I16X8_MUL,
	Opcode.I16X8_MIN_S,
	Opcode.I16X8_MIN_U,
	Opcode.I16X8_MAX_S,
	Opcode.I16X8_MAX_U,
	Opcode.I16X8_Q15MULRSAT_S,
	Opcode.I16X8_NARROW_I32X4_S,
	Opcode.I16X8_NARROW_I32X4_U,
	Opcode.I16X8_AVGR_U,
	Opcode.I16X8_EXTMUL_LOW_I8X16_S,
	Opcode.I16X8_EXTMUL_HIGH_I8X16_S,
	Opcode.I16X8_EXTMUL_LOW_I8X16_U,
	Opcode.I16X8_EXTMUL_HIGH_I8X16_U,
	Opcode.I32X4_ADD,
	Opcode.I32X4_SUB,
	Opcode.I32X4_MUL,
	Opcode.I32X4_MIN_S,
	Opcode.I32X4_MIN_U,
	Opcode.I32X4_MAX_S,
	Opcode.I32X4_MAX_U,
	Opcode.I32X4_DOT_I16X8_S,
	Opcode.I32X4_EXTMUL_LOW_I16X8_S,
	Opcode.I32X4_EXTMUL_HIGH_I16X8_S,
	Opcode.I32X4_EXTMUL_LOW_I16X8_U,
	Opcode.I32X4_EXTMUL_HIGH_I16X8_U,
	Opcode.I64X2_ADD,
	Opcode.I64X2_SUB,
	Opcode.I64X2_MUL,
	Opcode.I64X2_EXTMUL_LOW_I32X4_S,
	Opcode.I64X2_EXTMUL_HIGH_I32X4_S,
	Opcode.I64X2_EXTMUL_LOW_I32X4_U,
	Opcode.I64X2_EXTMUL_HIGH_I32X4_U,
	Opcode.F32X4_ADD,
	Opcode.F32X4_SUB,
	Opcode.F32X4_MUL,
	Opcode.F32X4_DIV,
	Opcode.F32X4_MIN,
	Opcode.F32X4_MAX,
	Opcode.F32X4_PMIN,
	Opcode.F32X4_PMAX,
	Opcode.F64X2_ADD,
	Opcode.F64X2_SUB,
	Opcode.F64X2_MUL,
	Opcode.F64X2_DIV,
	Opcode.F64X2_MIN,
	Opcode.F64X2_MAX,
	Opcode.F64X2_PMIN,
	Opcode.F64X2_PMAX
];

def test_simd_binop1(t: CodeValidatorTester) {
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		Opcode.V128_LOAD.prefix, 0, 0
	];
	t.sig(SigCache.ss_s);
	for (op in SIMD_BINOPS) {
		code[3] = byte.view(op.code | 0x80);
		code[4] = byte.view(op.code >> 7);
		t.invalid(WasmError.TYPE_MISMATCH, code, 3);
		if (!t.t.ok) break;
	}
}

def test_simd_binop2(t: CodeValidatorTester) {
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.V128_LOAD.prefix, 0, 0
	];
	t.sig(SigCache.ss_s);
	for (op in SIMD_BINOPS) {
		code[5] = byte.view(op.code | 0x80);
		code[6] = byte.view(op.code >> 7);
		t.valid(code);
		if (!t.t.ok) break;
	}
}

def test_simd_binop3(t: CodeValidatorTester) {
	var code: Array<byte> = [
		u8.!(Opcode.LOCAL_GET.code), 0,
		u8.!(Opcode.LOCAL_GET.code), 1,
		Opcode.V128_LOAD.prefix, 0, 0
	];
	for (sig in [SigCache.ii_i, SigCache.is_s, SigCache.si_s, SigCache.ff_f]) {
		t.sig(sig);
		for (i < 10) { // no need to do all of them
			var op = SIMD_BINOPS[i];
			code[5] = byte.view(op.code | 0x80);
			code[6] = byte.view(op.code >> 7);
			t.TypeError(code, 5);
			if (!t.t.ok) break;
		}
	}
}
