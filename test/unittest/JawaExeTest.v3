// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = JawaTests.registerRtTest("exe", _, _);
def X = [
	T("baload", test_exe_baload),
	T("caload", test_exe_caload),
	T("daload", test_exe_daload),
	T("faload", test_exe_faload),
	T("iaload", test_exe_iaload),
	T("laload", test_exe_laload),
	T("saload", test_exe_saload),
	T("zaload", test_exe_zaload),
	T("bastore", test_exe_bastore),
	T("castore", test_exe_castore),
	T("dastore", test_exe_dastore),
	T("fastore", test_exe_fastore),
	T("iastore", test_exe_iastore),
	T("lastore", test_exe_lastore),
	T("sastore", test_exe_sastore),
	T("zastore", test_exe_zastore),
	T("xnewarray", test_exe_xnewarray),
	T("arraylength1", test_exe_arraylength1),
	T("arraylength2", test_exe_arraylength2),
	T("acmpeq", test_exe_acmpeq),
	T("anewarray", test_exe_anewarray),
	T("aaload", test_exe_aaload),
	T("aastore", test_exe_aastore),
	T("isnull", test_exe_isnull),
	T("multianewarray1", test_exe_multianewarray1),
	T("multianewarray2", test_exe_multianewarray2),
	T("multianewarray3", test_exe_multianewarray3),
	T("multianewarrayP1", test_exe_multianewarrayP1),
	T("multianewarrayP2", test_exe_multianewarrayP2),
	T("new1", test_exe_new1),
	T("new2", test_exe_new2),
	T("getfield1", test_exe_getfield1),
	T("getfield2", test_exe_getfield2),
	T("putfield", test_exe_putfield),
	T("getstatic1", test_exe_getstatic1),
	T("getstatic2", test_exe_getstatic2),
	T("putstatic", test_exe_putstatic),
	T("instanceof1", test_exe_instanceof1),
	T("instanceof2", test_exe_instanceof2),
	T("instanceof3", test_exe_instanceof3),
	T("checkcast1", test_exe_checkcast1),
	T("checkcast2", test_exe_checkcast2),
	T("checkcast3", test_exe_checkcast3),
	T("monitorenter", test_exe_monitorenter),
	T("monitorexit", test_exe_monitorexit),
	T("invokestatic1", test_exe_invokestatic1),
	T("invokestatic2", test_exe_invokestatic2),
	T("invokestatic3", test_exe_invokestatic3),
	T("invokespecial", test_exe_invokespecial),
	T("invokevirtual", test_exe_invokevirtual),
	T("invokeinterface", test_exe_invokeinterface),
	T("overload1", test_exe_overload1),
	T("object1", test_exe_object1),
	T("object2", test_exe_object2),
	T("object3", test_exe_object3),
	T("object4", test_exe_object4),
	T("ref_null", test_exe_ref_null),
	T("local", test_exe_local),
	T("Object.<init>", test_Object_init),
	T("Object.equals", test_Object_equals),
	T("Object.hashCode", test_Object_hashCode),
	T("String.equals", test_String_equals),
	T("String.hashCode", test_String_hashCode),
	T("Object.getClass1", test_Object_getClass1),
	T("Object.getClass2", test_Object_getClass2),
	()
];

class ArgCatcher {
	var args: Array<Value>;
	var result: HostResult;
	var host: HostFunction;
	new(sig: SigDecl) {
		host = HostFunctionN.new("catch-args", sig, invoke);
	}
	def invoke(args: Array<Value>) -> HostResult {
		this.args = Arrays.dup(args);
		return result;
	}
}

def NPE = Result.Trap(TrapReason.NULL_DEREF);
def AIOBE = Result.Trap(TrapReason.ARRAY_INDEX_OOB);
def NASE = Result.Trap(TrapReason.OOM); // TODO: out of memory for negative array size exception
def CCE = Result.Trap(TrapReason.FAILED_CAST);

// Value conversion helpers.
def i_v = Values.i_v;
def l_v = Values.l_v;
def d_v = Value.F64;
def f_v = Value.F32;

def t_r<T>(f: T -> Value, v: T) -> Result { // T -> Value -> Result
	return Result.Value([f(v)]);
}

def i_r = t_r(Values.i_v, _); // i32 -> Result
def d_r = t_r(Value.F64, _);  // double -> Result
def f_r = t_r(Value.F32, _);  // float -> Result
def l_r = t_r(Values.l_v, _); // long -> Result
def v_r(v: Value) -> Result { return Result.Value([v]); }

def vi_vv(v1: Value, v2: int) -> Array<Value> {
	return [v1, i_v(v2)];
}

def rNONE = Result.Value(Values.NONE);

def makeArray<T>(rt: JawaRuntime, vals: Array<T>, pair: (JawaArrayType, JawaPrimMappingOf<T>)) -> Value {
	return rt.initArray(pair.0, vals, pair.1);
}

def makeBoolArray = makeArray<bool>(_, _, JawaTypes.BOOL_ARRAY_PAIR);
def makeByteArray = makeArray<i8>(_, _, JawaTypes.BYTE_ARRAY_PAIR);
def makeCharArray = makeArray<u16>(_, _, JawaTypes.CHAR_ARRAY_PAIR);
def makeShortArray = makeArray<i16>(_, _, JawaTypes.SHORT_ARRAY_PAIR);
def makeIntArray = makeArray<i32>(_, _, JawaTypes.INT_ARRAY_PAIR);
def makeLongArray = makeArray<i64>(_, _, JawaTypes.LONG_ARRAY_PAIR);
def makeDoubleArray = makeArray<double>(_, _, JawaTypes.DOUBLE_ARRAY_PAIR);
def makeFloatArray = makeArray<float>(_, _, JawaTypes.FLOAT_ARRAY_PAIR);

def test_exe_baload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.BYTE);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeByteArray(t.rt, [
		8, 102, -116
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 3)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 999)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_i(8, run(vi_vv(array, 0)));
	t.assert_i(102, run(vi_vv(array, 1)));
	t.assert_i(-116, run(vi_vv(array, 2)));
}

def test_exe_caload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.CHAR);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeCharArray(t.rt, [
		7, 10000, 32767, u16.max
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9991)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_i(7, run(vi_vv(array, 0)));
	t.assert_i(10000, run(vi_vv(array, 1)));
	t.assert_i(32767, run(vi_vv(array, 2)));
	t.assert_i(65535, run(vi_vv(array, 3)));
}

def test_exe_daload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.DOUBLE);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeDoubleArray(t.rt, [
		double.view(0x4021cccccccccccd),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x7ff0000000000000)
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9991)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(d_r(0x4021cccccccccccd), run(vi_vv(array, 0)));
	t.assert_r(d_r(0xc073000000000000), run(vi_vv(array, 1)));
	t.assert_r(d_r(0x7ff8000000000000), run(vi_vv(array, 2)));
	t.assert_r(d_r(0x7ff0000000000000), run(vi_vv(array, 3)));
}

def test_exe_faload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.FLOAT);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeFloatArray(t.rt, [
		float.view(0x410e6666),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x7f800000)
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9991)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(f_r(0x410e6666), run(vi_vv(array, 0)));
	t.assert_r(f_r(0xc3510000), run(vi_vv(array, 1)));
	t.assert_r(f_r(0x7fc00000), run(vi_vv(array, 2)));
	t.assert_r(f_r(0x7f800000), run(vi_vv(array, 3)));
}

def test_exe_iaload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.INT);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeIntArray(t.rt, [
		5, 10100, int.min, int.max
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 4)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 9191)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_i(5, run(vi_vv(array, 0)));
	t.assert_i(10100, run(vi_vv(array, 1)));
	t.assert_i(int.min, run(vi_vv(array, 2)));
	t.assert_i(int.max, run(vi_vv(array, 3)));
}

def test_exe_laload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.LONG);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeLongArray(t.rt, [
		5, 10100, int.min, int.max, long.min, long.max
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 6)));
	t.assert_r(AIOBE, run(vi_vv(array, 7)));
	t.assert_r(AIOBE, run(vi_vv(array, 9291)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_r(l_r(5), run(vi_vv(array, 0)));
	t.assert_r(l_r(10100), run(vi_vv(array, 1)));
	t.assert_r(l_r(int.min), run(vi_vv(array, 2)));
	t.assert_r(l_r(int.max), run(vi_vv(array, 3)));
	t.assert_r(l_r(long.min), run(vi_vv(array, 4)));
	t.assert_r(l_r(long.max), run(vi_vv(array, 5)));
}

def test_exe_saload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.SHORT);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeShortArray(t.rt, [
		6, 10103, -20004, i16.min, i16.max
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 6)));
	t.assert_r(AIOBE, run(vi_vv(array, 9995)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_i(6, run(vi_vv(array, 0)));
	t.assert_i(10103, run(vi_vv(array, 1)));
	t.assert_i(-20004, run(vi_vv(array, 2)));
	t.assert_i(i16.min, run(vi_vv(array, 3)));
	t.assert_i(i16.max, run(vi_vv(array, 4)));
}

def test_exe_zaload(t: JawaTester) {
	var func = t.make_xaload(JawaPrimArrayOpcodes.BOOL);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var array = makeBoolArray(t.rt, [
		false, true, false
	]);

	t.assert_r(NPE, run(vi_vv(t.rt.nullRef(), 0)));
	t.assert_r(AIOBE, run(vi_vv(array, -1)));
	t.assert_r(AIOBE, run(vi_vv(array, 3)));
	t.assert_r(AIOBE, run(vi_vv(array, 5)));
	t.assert_r(AIOBE, run(vi_vv(array, 999)));
	t.assert_r(AIOBE, run(vi_vv(array, int.max)));
	t.assert_r(AIOBE, run(vi_vv(array, int.min)));

	t.assert_i(0, run(vi_vv(array, 0)));
	t.assert_i(1, run(vi_vv(array, 1)));
	t.assert_i(0, run(vi_vv(array, 2)));
}

def test_exe_bastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.BYTE);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeByteArray(t.rt, [
		-1, 2, 11, 123, -109
	]);
	var zero = Values.I32_0;

	t.assert_r(NPE, run([t.rt.nullRef(), zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(29995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a<i8>(_, ref, JawaTypes.BYTE_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	assert([0, 2, 11, 123, -109]);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(99)]));
	assert([0, 99, 11, 123, -109]);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(-5)]));
	assert([0, 99, -5, 123, -109]);

	t.assert_r(rNONE, run([ref, i_v(3), i_v(44)]));
	assert([0, 99, -5, 44, -109]);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(i8.max)]));
	assert([0, 99, -5, 44, i8.max]);
}

def test_exe_castore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.CHAR);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeCharArray(t.rt, [
		1, 2, 11, 12345, 65535
	]);
	var zero = Values.I32_0;

	t.assert_r(NPE, run([t.rt.nullRef(), zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(29995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a<u16>(_, ref, JawaTypes.CHAR_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	assert([0, 2, 11, 12345, 65535]);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(99)]));
	assert([0, 99, 11, 12345, 65535]);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(555)]));
	assert([0, 99, 11, 12345, 555]);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(u16.max)]));
	assert([0, 99, 65535, 12345, 555]);
}

def test_exe_dastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.DOUBLE);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeDoubleArray(t.rt, [
		double.view(0x4021cccccccccccd),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x7ff0000000000000),
		double.view(0xc071000456789ABC)
	]);
	var zero = Values.F64_0;

	t.assert_r(NPE, run([t.rt.nullRef(), i_v(0), zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(129995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a(_, ref, JawaTypes.DOUBLE_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	assert([
		double.view(0x0000000000000000),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x7ff0000000000000),
		double.view(0xc071000456789ABC)]);

	t.assert_r(rNONE, run([ref, i_v(3), d_v(0x1111222233334444)]));
	assert([
		double.view(0x0000000000000000),
		double.view(0xc073000000000000),
		double.view(0x7ff8000000000000),
		double.view(0x1111222233334444),
		double.view(0xc071000456789ABC)]);
}

def test_exe_fastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.FLOAT);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeFloatArray(t.rt, [
		float.view(0x410e6666),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x7f800000),
		float.view(0xd2110c43)
	]);
	var zero = Values.F32_0;

	t.assert_r(NPE, run([t.rt.nullRef(), i_v(0), zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(129995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a(_, ref, JawaTypes.FLOAT_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	assert([
		float.view(0x00000000),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x7f800000),
		float.view(0xd2110c43)
	]);

	t.assert_r(rNONE, run([ref, i_v(3), f_v(0x11223344)]));
	assert([
		float.view(0x00000000),
		float.view(0xc3510000),
		float.view(0x7fc00000),
		float.view(0x11223344),
		float.view(0xd2110c43)
	]);
}

def test_exe_iastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.INT);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeIntArray(t.rt, [
		1, 2, -13, 72345, 6553509
	]);
	var zero = Values.I32_0;

	t.assert_r(NPE, run([t.rt.nullRef(), zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(39995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a<i32>(_, ref, JawaTypes.INT_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), i_v(555666777)]));
	assert([555666777, 2, -13, 72345, 6553509]);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(997)]));
	assert([555666777, 997, -13, 72345, 6553509]);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(-777888999)]));
	assert([555666777, 997, -13, 72345, -777888999]);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(u16.max)]));
	assert([555666777, 997, 65535, 72345, -777888999]);
}

def test_exe_lastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.LONG);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeLongArray(t.rt, [
		1, 5, -13998744, 72345999888, 6553509998888
	]);
	var zero = Values.I64_0;

	t.assert_r(NPE, run([t.rt.nullRef(), i_v(0), zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(49995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a<i64>(_, ref, JawaTypes.LONG_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), l_v(555666777888999)]));
	assert([555666777888999, 5, -13998744, 72345999888, 6553509998888]);

	t.assert_r(rNONE, run([ref, i_v(1), l_v(-997)]));
	assert([555666777888999, -997, -13998744, 72345999888, 6553509998888]);

	t.assert_r(rNONE, run([ref, i_v(4), l_v(-777888999)]));
	assert([555666777888999, -997, -13998744, 72345999888, -777888999]);

	t.assert_r(rNONE, run([ref, i_v(2), l_v(u16.max)]));
	assert([555666777888999, -997, 65535, 72345999888, -777888999]);
}

def test_exe_sastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.SHORT);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeShortArray(t.rt, [
		-1, 2, 11, 12365, -10988
	]);
	var zero = Values.I32_0;

	t.assert_r(NPE, run([t.rt.nullRef(), zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(99995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a<i16>(_, ref, JawaTypes.SHORT_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	assert([0, 2, 11, 12365, -10988]);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(9937)]));
	assert([0, 9937, 11, 12365, -10988]);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(-5)]));
	assert([0, 9937, -5, 12365, -10988]);

	t.assert_r(rNONE, run([ref, i_v(3), i_v(4444)]));
	assert([0, 9937, -5, 4444, -10988]);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(i16.min)]));
	assert([0, 9937, -5, 4444, -32768]);
}

def test_exe_zastore(t: JawaTester) {
	var func = t.make_xastore(JawaPrimArrayOpcodes.BOOL);
	if (func == null) return;
	def run = Target.newInterpreter().run(100, func, _);
	var ref = makeBoolArray(t.rt, [
		false, true, false, true, false
	]);
	var zero = Values.I32_0;

	t.assert_r(NPE, run([t.rt.nullRef(), zero, zero]));
	t.assert_r(AIOBE, run([ref, i_v(-1), zero]));
	t.assert_r(AIOBE, run([ref, i_v(5), zero]));
	t.assert_r(AIOBE, run([ref, i_v(6), zero]));
	t.assert_r(AIOBE, run([ref, i_v(99995), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.max), zero]));
	t.assert_r(AIOBE, run([ref, i_v(int.min), zero]));

	def assert = t.assert_a<bool>(_, ref, JawaTypes.BOOL_MAPPING);

	t.assert_r(rNONE, run([ref, i_v(0), zero]));
	assert([false, true, false, true, false]);

	t.assert_r(rNONE, run([ref, i_v(1), i_v(0)]));
	assert([false, false, false, true, false]);

	t.assert_r(rNONE, run([ref, i_v(2), i_v(1)]));
	assert([false, false, true, true, false]);

	t.assert_r(rNONE, run([ref, i_v(3), i_v(1)]));
	assert([false, false, true, true, false]);

	t.assert_r(rNONE, run([ref, i_v(4), i_v(1)]));
	assert([false, false, true, true, true]);
}

def test_exe_xnewarrayof<T>(t: JawaTester, c: JawaPrimArrayOpcodes) {
	// XXX(code size): reduce polymorphic duplication of this method
	var i = Target.newInterpreter();
	var f = t.make_xnewarray(c);
	if (f == null) return;

	t.assert_r(NASE, i.run(100, f, [i_v(-1)]));

	for (len in [0, 1, 5, 257]) {
		var r = i.run(100, f, [i_v(len)]);
		var obj = t.assertIsJawaObject(c.arrayType, r);
		if (!t.t.ok) break;
		t.t.asserti(len, t.rt.getLength(obj));
	}
}

def test_exe_xnewarray(t: JawaTester) {
	test_exe_xnewarrayof<i8>(t, JawaPrimArrayOpcodes.BYTE);
	test_exe_xnewarrayof<bool>(t, JawaPrimArrayOpcodes.BOOL);
	test_exe_xnewarrayof<u16>(t, JawaPrimArrayOpcodes.CHAR);
	test_exe_xnewarrayof<i16>(t, JawaPrimArrayOpcodes.SHORT);
	test_exe_xnewarrayof<i32>(t, JawaPrimArrayOpcodes.INT);
	test_exe_xnewarrayof<i64>(t, JawaPrimArrayOpcodes.LONG);
	test_exe_xnewarrayof<float>(t, JawaPrimArrayOpcodes.FLOAT);
	test_exe_xnewarrayof<double>(t, JawaPrimArrayOpcodes.DOUBLE);
}

def test_exe_arraylength1(t: JawaTester) {
	var i = Target.newInterpreter();
	for (c in JawaPrimArrayOpcodes) {
		var f = t.make_xarraylength(c);
		if (f == null) return;

		t.assert_r(NPE, i.run(100, f, [t.rt.nullRef()]));
		for (len in [0, 1, 258]) {
			var ref = t.rt.newArray(c.arrayType, len);
			t.assert_i(len, i.run(100, f, [ref]));
		}
	}
}

def test_exe_arraylength2(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = t.sig_x_i(ValueType.Abstract(ajlo));
	def str = t.strCodeType(JawaFuncOpcode.ARRAYLENGTH.code, ajlo);
	var fi = t.addFuncImport(str, sig);
	var r = t.process();
	if (r == null) return;

	var at = t.assertIsJawaArrayType(JawaLang.OBJECT, r[ajlo.imp.import_index]);
	var expected_sig = t.sig_x_i(t.toWasmType(at));
	var f = t.assertIsFunction(expected_sig, r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	for (len in [0, 1, 259]) {
		var av = t.rt.newArray(at, len);
		t.assert_i(len, i.run(100, f, [av]));
	}
}

def test_exe_acmpeq(t: JawaTester) {
	var sig = t.sig_xx_i(t.toWasmType(JawaTypes.OBJECT));
	t.addFuncImport(t.strCode(JawaFuncOpcode.ACMPEQ.code), sig);
	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(sig, r[0]);
	if (f == null) return;

	def cases: Array<Value> = [
		t.rt.nullRef(),
		t.rt.newArray(JawaTypes.BYTE_ARRAY, 1),
		t.rt.newArray(JawaTypes.INT_ARRAY, 2),
		t.rt.newObject(JawaLang.OBJECT)
	];
	var i = Target.newInterpreter(), TRUE = i_r(1), FALSE = i_r(0);
	for (x < cases.length) {
		for (y < cases.length) {
			t.assert_r(if(x == y, TRUE, FALSE), i.run(100, f, [cases[x], cases[y]]));
		}
	}
}

def test_exe_anewarray(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = SigDecl.new(SigCache.arr_i, [ValueType.Abstract(ajlo)]);
	var cmd = t.strCodeType(JawaFuncOpcode.ANEWARRAY.code, ajlo);
	t.addFuncImport(cmd, sig);
	var r = t.process();
	if (r == null) return;

	var at = t.assertIsJawaArrayType(JawaLang.OBJECT, r[1]);
	var expected_sig = SigDecl.new(SigCache.arr_i, [t.toWasmType(at)]);
	var f = t.assertIsFunction(expected_sig, r[2]);
	if (f == null) return;

	var i = Target.newInterpreter();
	for (len in [0, 1, 7, 257]) {
		var r = i.run(100, f, [i_v(len)]);
		var obj = t.assertIsJawaObject(at, r);
		if (!t.t.ok) break;
		t.t.asserti(len, t.rt.getLength(obj));
	}
}

def test_exe_aaload(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = SigDecl.new([ValueType.Abstract(ajlo), ValueType.I32], [ValueType.Abstract(jlo)]);
	var cmd = t.strCodeType(JawaFuncOpcode.AALOAD.code, ajlo);
	t.addFuncImport(cmd, sig);
	var r = t.process();
	if (r == null) return;

	var at = t.assertIsJawaArrayType(JawaLang.OBJECT, r[1]);
	if (at == null) return;
	var expected_sig = SigDecl.new([t.toWasmType(at), ValueType.I32], [t.toWasmType(at.elem)]);
	var f = t.assertIsFunction(expected_sig, r[2]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var objs = [
		t.rt.nullRef(),
		t.rt.newObject(JawaLang.OBJECT),
		t.rt.newObject(JawaLang.OBJECT),
		t.rt.newObject(JawaLang.OBJECT)
	];
	var av = t.rt.newArray(at, 4);
	t.rt.setElem(av, 0, objs[0]);
	t.rt.setElem(av, 1, objs[1]);
	t.rt.setElem(av, 2, objs[2]);
	t.rt.setElem(av, 3, objs[3]);

	def run = i.run(100, f, _);
	for (i < objs.length) {
		t.assert_r(v_r(objs[i]), run([av, i_v(i)]));
	}
	t.assert_r(NPE, run([t.rt.nullRef(), i_v(0)]));
	t.assert_r(AIOBE, run([av, i_v(-1)]));
	t.assert_r(AIOBE, run([av, i_v(objs.length)]));
	t.assert_r(AIOBE, run([av, i_v(65555)]));
	t.assert_r(AIOBE, run([av, i_v(int.max)]));
}

def test_exe_aastore(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = SigDecl.new([ValueType.Abstract(ajlo), ValueType.I32, ValueType.Abstract(jlo)], SigCache.arr_v);
	var cmd = t.strCodeType(JawaFuncOpcode.AASTORE.code, ajlo);
	t.addFuncImport(cmd, sig);
	var r = t.process();
	if (r == null) return;

	var at = t.assertIsJawaArrayType(JawaLang.OBJECT, r[1]);
	if (at == null) return;
	var expected_sig = SigDecl.new([t.toWasmType(at), ValueType.I32, t.toWasmType(at.elem)], SigCache.arr_v);
	var f = t.assertIsFunction(expected_sig, r[2]);
	if (f == null) return;

	var nv = t.rt.nullRef();
	var obj1 = t.rt.newObject(JawaLang.OBJECT);
	var obj2 = t.rt.newObject(JawaLang.OBJECT);
	var obj3 = t.rt.newObject(JawaLang.OBJECT);
	var av = t.rt.newArray(at, 4);
	t.rt.setElem(av, 1, obj1);
	t.rt.setElem(av, 2, obj2);
	t.rt.setElem(av, 3, obj3);

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);

	t.assert_r(rNONE, run([av, i_v(0), nv]));
	t.assert_av([nv, obj1, obj2, obj3], av);

	t.assert_r(rNONE, run([av, i_v(0), obj2]));
	t.assert_av([obj2, obj1, obj2, obj3], av);

	t.assert_r(rNONE, run([av, i_v(2), obj3]));
	t.assert_av([obj2, obj1, obj3, obj3], av);

	t.assert_r(rNONE, run([av, i_v(3), nv]));
	t.assert_av([obj2, obj1, obj3, nv], av);

	t.assert_r(NPE, run([nv, i_v(0), nv]));
	t.assert_r(AIOBE, run([av, i_v(-1), nv]));
	t.assert_r(AIOBE, run([av, i_v(4), nv]));
	t.assert_r(AIOBE, run([av, i_v(65555), nv]));
	t.assert_r(AIOBE, run([av, i_v(int.max), nv]));
}

def test_exe_isnull(t: JawaTester) {
	var sig = t.sig_x_i(t.toWasmType(JawaTypes.OBJECT));
	t.addFuncImport(t.strCode(JawaFuncOpcode.ISNULL.code), sig);
	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(sig, r[0]);
	if (f == null) return;

	def cases: Array<Value> = [
		t.rt.newArray(JawaTypes.CHAR_ARRAY, 1),
		t.rt.newArray(JawaTypes.DOUBLE_ARRAY, 2),
		t.rt.newObject(JawaLang.OBJECT),
		t.rt.newObject(JawaLang.OBJECT)
	];
	var i = Target.newInterpreter(), TRUE = i_r(1), FALSE = i_r(0);
	for (x < cases.length) {
		t.assert_r(FALSE, i.run(100, f, [cases[x]]));
	}
	t.assert_r(TRUE, i.run(100, f, [t.rt.nullRef()]));
}

def test_exe_multianewarray1(t: JawaTester) {
	def dims = 1;
	var jlo = t.importJawaLangObject();
	var ajlo = t.importArrayOf(jlo);

	var sig = SigDecl.new(SigCache.arr_i, [ValueType.Abstract(ajlo)]);
	var asm = JawaAsm.new()
		.putc(JawaFuncOpcode.MULTIANEWARRAY.code)
		.put_ji4(dims)
		.put_abstype(ajlo);
	t.addFuncImport(asm, sig);
	var r = t.process();
	if (r == null) return;

	var at = t.assertIsJawaArrayType(JawaLang.OBJECT, r[1]);
	var expected_sig = SigDecl.new(SigCache.arr_i, [t.toWasmType(at)]);
	var f = t.assertIsFunction(expected_sig, r[2]);
	if (f == null) return;

	var i = Target.newInterpreter();
	for (len in [0, 1, 7, 257]) {
		var r = i.run(100, f, [i_v(len)]);
		var obj = t.assertIsJawaObject(at, r);
		if (!t.t.ok) break;
		t.t.asserti(len, t.rt.getLength(obj));
	}
}

def test_exe_multianewarray2(t: JawaTester) {
	def dims = 1;
	var it = t.importMultiArrayOf(t.importJawaLangObject(), dims);
	var pair = t.make_multianewarray(it, dims), at = pair.0, f = pair.1;
	if (f == null) return;

	var i = Target.newInterpreter();
	for (len in [0, 1, 7, 257]) {
		var r = i.run(10000, f, [i_v(len)]);
		var obj = t.assertIsJawaObject(at, r);
		if (!t.t.ok) return;
		t.t.asserti(len, t.rt.getLength(obj));
	}
}

def test_exe_multianewarray3(t: JawaTester) {
	def dims = 2;
	var it = t.importMultiArrayOf(t.importJawaLangObject(), dims);
	var pair = t.make_multianewarray(it, dims), at = pair.0, f = pair.1;
	if (f == null) return;

	var i = Target.newInterpreter();
	for (d1 in [0, 1, 3]) {
		for (d2 in [0, 1, 3]) {
			var r = i.run(1000, f, [i_v(d1), i_v(d2)]);
			var obj = t.assertIsJawaObject(at, r);
			if (!t.t.ok) return;
			t.t.asserti(d1, t.rt.getLength(obj));
			for (i < d1) {
				var sub = t.rt.getElem(obj, i);
				t.t.asserti(d2, t.rt.getLength(sub));
				for (j < d2) t.assert_v(t.rt.nullRef(), Result.Value([t.rt.getElem(sub, j)]));
			}
		}
	}
}

def test_exe_multianewarrayP1(t: JawaTester) {
	def dims = 1;
	for (c in JawaPrimArrayOpcodes) {
		var n = t.dup();
		var it = n.importPrimArray(c);
		var pair = n.make_multianewarray(it, dims), at = pair.0, f = pair.1;
		if (f == null) return;

		var i = Target.newInterpreter();
		for (len in [0, 1, 7, 257]) {
			var r = i.run(100, f, [i_v(len)]);
			var obj = t.assertIsJawaObject(at, r);
			if (!t.t.ok) return;
			t.t.asserti(len, t.rt.getLength(obj));
		}
	}
}

def test_exe_multianewarrayP2(t: JawaTester) {
	def dims = 2;
	for (c in JawaPrimArrayOpcodes) {
		var n = t.dup();
		var it = n.importArrayOf(n.importPrimArray(c));
		var pair = n.make_multianewarray(it, dims), at = pair.0, f = pair.1;
		if (f == null) return;

		var i = Target.newInterpreter();
		for (d1 in [0, 1, 3, 5]) {
			for (d2 in [0, 1, 3, 5]) {
				var r = i.run(100, f, [i_v(d1), i_v(d2)]);
				var obj = t.assertIsJawaObject(at, r);
				if (!t.t.ok) return;
				t.t.asserti(d1, t.rt.getLength(obj));
				for (i < d1) {
					var sub = t.rt.getElem(obj, i);
					t.t.asserti(d2, t.rt.getLength(sub));
				}
			}
		}
	}
}

def test_exe_new1(t: JawaTester) {
	var name = "Hiz", jname = JawaStrings.of(name);
	// Manually created class
	var jt = t.env.declareClass(jname, t.NO_CLASS_ATTRS, JawaLang.OBJECT, []);
	jt.instanceFields = [];
	jt.boilerplate = [];
	var it = t.importClass(name);

	var str3 = t.strCodeType(JawaFuncOpcode.NEW.code, it);
	var fi = t.addFuncImport(str3, SigDecl.new(SigCache.arr_v, [ValueType.Abstract(it)]));

	var r = t.process();
	if (r == null) return;
	var ct = t.assertIsJawaClassType(jt, r[it.imp.import_index]);
	if (ct == null) return;
	var f = t.assertIsFunction(SigDecl.new(SigCache.arr_v, [t.toWasmType(ct)]), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var got = i.run(100, f, []);
	t.assertIsJawaObject(ct, got);
}

def test_exe_new2(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	// Explicitly defined class
	var name = "Ion", jname = JawaStrings.of(name);
	var it1 = t.declareClass(name, t.NO_CLASS_ATTRS, jlo, []);
	var it2 = t.defineClass(it1, [], [], [], []);
	var str3 = t.strCodeType(JawaFuncOpcode.NEW.code, it1);
	var fi = t.addFuncImport(str3, SigDecl.new(SigCache.arr_v, [ValueType.Abstract(it1)]));

	var r = t.process();
	if (r == null) return;
	var ct1 = t.assertIsJawaClassTypeWithName(jname, r[it1.imp.import_index]);
	if (ct1 == null) return;
	var f = t.assertIsFunction(SigDecl.new(SigCache.arr_v, [t.toWasmType(ct1)]), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var got = i.run(100, f, []);
	t.assertIsJawaObject(ct1, got);
}

def test_exe_getfield1(t: JawaTester) {
	var className = "MyClass", jclassName = JawaStrings.of(className);
	var fieldName = "f1", jfieldName = JawaStrings.of(fieldName);
	var ct = JawaClassType.new(jclassName, t.NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [Values.I32_0];
	ct.instanceFields = [JawaField.new(jfieldName, t.NO_FIELD_ATTRS, 0, JawaTypes.BYTE)];
	t.env.add(ct);
	var it = t.importRefType(ct);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.GETFIELD.code, it, jfieldName);
	var fi = t.addFuncImport(str1, t.sig_x_i(ValueType.Abstract(it)));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(t.sig_x_i(t.toWasmType(ct)), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var ref = t.rt.newObject(ct);
	def run = i.run(100, f, _);

	t.assert_i(0, run([ref]));

	t.rt.setField(ref, 0, i_v(33));
	t.assert_i(33, run([ref]));

	t.rt.setField(ref, 0, i_v(77));
	t.assert_i(77, run([ref]));

	t.assert_r(NPE, run([t.rt.nullRef()]));
}

def test_exe_getfield2(t: JawaTester) {
	var classNameA = "MyA", jclassNameA = JawaStrings.of(classNameA);
	var classNameB = "MyB", jclassNameB = JawaStrings.of(classNameB);

	var fieldName = "f1", jfieldName = JawaStrings.of(fieldName);
	var ctA = JawaClassType.new(jclassNameA, t.NO_CLASS_ATTRS, null, []);
	ctA.boilerplate = [Values.I32_0];
	ctA.instanceFields = [
		JawaField.new(jfieldName, t.NO_FIELD_ATTRS, 0, JawaTypes.BYTE)
	];
	t.env.add(ctA);

	var ctB = JawaClassType.new(jclassNameB, t.NO_CLASS_ATTRS, ctA, []);
	ctB.boilerplate = [Values.I32_0, Values.I32_0];
	ctB.instanceFields = [
		ctA.instanceFields[0],
		JawaField.new(jfieldName, t.NO_FIELD_ATTRS, 1, JawaTypes.INT)
	];
	t.env.add(ctB);

	var itA = t.importRefType(ctA);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.GETFIELD.code, itA, jfieldName);
	var fiA = t.addFuncImport(str1, t.sig_x_i(ValueType.Abstract(itA)));

	var itB = t.importRefType(ctB);
	var str2 = t.strCodeTypeJawaName(JawaFuncOpcode.GETFIELD.code, itB, jfieldName);
	var fiB = t.addFuncImport(str2, t.sig_x_i(ValueType.Abstract(itB)));

	var r = t.process();
	if (r == null) return;
	var getA = t.assertIsFunction(t.sig_x_i(t.toWasmType(ctA)), r[fiA.imp.import_index]);
	if (getA == null) return;
	var getB = t.assertIsFunction(t.sig_x_i(t.toWasmType(ctB)), r[fiB.imp.import_index]);
	if (getB == null) return;

	var i = Target.newInterpreter();
	var ref = t.rt.newObject(ctB);
	def runA = i.run(100, getA, _);
	def runB = i.run(100, getB, _);

	t.assert_i(0, runA([ref]));

	t.rt.setField(ref, 0, i_v(33));
	t.assert_i(33, runA([ref]));
	t.assert_i(0, runB([ref]));

	t.rt.setField(ref, 0, i_v(77));
	t.assert_i(77, runA([ref]));
	t.assert_i(0, runB([ref]));

	t.rt.setField(ref, 1, i_v(44));
	t.assert_i(77, runA([ref]));
	t.assert_i(44, runB([ref]));

	t.assert_r(NPE, runA([t.rt.nullRef()]));
}

def test_exe_putfield(t: JawaTester) {
	var className = "MyClass", jclassName = JawaStrings.of(className);
	var fieldName = "f1", jfieldName = JawaStrings.of(fieldName);
	var ct = JawaClassType.new(jclassName, t.NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [Values.I32_0];
	ct.instanceFields = [JawaField.new(jfieldName, t.NO_FIELD_ATTRS, 0, JawaTypes.INT)];
	t.env.add(ct);
	var it = t.importRefType(ct);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.PUTFIELD.code, it, jfieldName);
	var fi = t.addFuncImport(str1, SigDecl.new([ValueType.Abstract(it), ValueType.I32], SigCache.arr_v));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(SigDecl.new([t.toWasmType(ct), ValueType.I32], SigCache.arr_v), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var ref = t.rt.newObject(ct);
	def run = i.run(100, f, _);

	t.assert_r(rNONE, run([ref, i_v(22)]));
	t.assert_i((22), v_r(t.rt.getField(ref, 0)));

	t.assert_r(rNONE, run([ref, i_v(-89)]));
	t.assert_i(-89, v_r(t.rt.getField(ref, 0)));

	t.assert_r(rNONE, run([ref, i_v(-99999999)]));
	t.assert_i(-99999999, v_r(t.rt.getField(ref, 0)));

	t.assert_r(NPE, run([t.rt.nullRef(), i_v(0)]));
}

def test_exe_getstatic1(t: JawaTester) {
	var className = "MyClass", jclassName = JawaStrings.of(className);
	var fieldName = "f1", jfieldName = JawaStrings.of(fieldName);
	var ct = JawaClassType.new(jclassName, t.NO_CLASS_ATTRS, null, []);
	ct.staticStorage = [Values.I32_0];
	ct.instanceFields = [];
	ct.staticFields = [JawaField.new(jfieldName, t.NO_FIELD_ATTRS, 0, JawaTypes.BYTE)];
	t.env.add(ct);
	var it = t.importRefType(ct);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.GETSTATIC.code, it, jfieldName);
	var fi = t.addFuncImport(str1, SigCache.v_i);

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(SigCache.v_i, r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);

	t.assert_i(0, run([]));

	t.rt.setStatic(ct, ct.staticFields[0], i_v(33));
	t.assert_i(33, run([]));

	t.rt.setStatic(ct, ct.staticFields[0], i_v(77));
	t.assert_i(77, run([]));
}

def test_exe_getstatic2(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var c = JawaClassBuilder.new(t, "C", t.NO_CLASS_ATTRS, jlo, []);

	c.addStaticField("g", JawaTypeRef.Prim(JawaTypes.FLOAT));
	c.define();

	var getstatic_g = c.GETSTATIC("g");

	var run = t.newFunction(SigCache.v_f, [
		Opcode.CALL.code, byte.view(getstatic_g.func_index)
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_v(Values.F32_0, i.run(100, f, []));
}

def test_exe_putstatic(t: JawaTester) {
	var className = "MyClass", jclassName = JawaStrings.of(className);
	var fieldName = "f1", jfieldName = JawaStrings.of(fieldName);
	var ct = JawaClassType.new(jclassName, t.NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [Values.I32_0];
	ct.instanceFields = [];
	ct.staticFields = [JawaField.new(jfieldName, t.NO_FIELD_ATTRS, 0, JawaTypes.INT)];
	ct.staticStorage = [Values.I32_0];
	t.env.add(ct);
	var it = t.importRefType(ct);
	var str1 = t.strCodeTypeJawaName(JawaFuncOpcode.PUTSTATIC.code, it, jfieldName);
	var fi = t.addFuncImport(str1, SigCache.i_v);

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(SigCache.i_v, r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);

	t.assert_r(rNONE, run([i_v(22)]));
	t.assert_i(22, v_r(t.rt.getStatic(ct, ct.staticFields[0])));

	t.assert_r(rNONE, run([i_v(-89)]));
	t.assert_i(-89, v_r(t.rt.getStatic(ct, ct.staticFields[0])));

	t.assert_r(rNONE, run([i_v(-99999999)]));
	t.assert_i(-99999999, v_r(t.rt.getStatic(ct, ct.staticFields[0])));
}

def test_exe_instanceof1(t: JawaTester) {
	var name = "Foof", jname = JawaStrings.of(name);
	var jlo = t.importJawaLangObject();
	var ict = t.declareClass(name, t.NO_CLASS_ATTRS, jlo, []);
	var xxx = t.defineClass(ict, [], [], [], []);
	var cmd = t.strCodeType(JawaFuncOpcode.INSTANCEOF.code, ict);
	var fi = t.addFuncImport(cmd, t.sig_x_i(ValueType.Abstract(ict)));

	var r = t.process();
	if (r == null) return;
	var ct = t.assertIsJawaClassTypeWithName(jname, r[ict.imp.import_index]);
	if (ct == null) return;

	var f = t.assertIsFunction(t.sig_x_i(t.toWasmType(JawaTypes.OBJECT)), r[fi.imp.import_index]);
	def run = Target.newInterpreter().run(100, f, _);

	t.assert_i(0, run([t.rt.nullRef()]));
	t.assert_i(0, run([t.rt.newObject(JawaTypes.OBJECT)]));
	t.assert_i(0, run([t.rt.newArray(JawaTypes.INT_ARRAY, 0)]));
	t.assert_i(1, run([t.rt.newObject(ct)]));
}

def test_exe_instanceof2(t: JawaTester) {
	var cases = Vector<(JawaPrimArrayOpcodes, Value)>.new();
	for (c in JawaPrimArrayOpcodes) {
		cases.put(c, t.rt.newArray(c.arrayType, 1));
	}

	for (c in JawaPrimArrayOpcodes) {
		var n = t.dup();

		var jlo = n.importJawaLangObject();
		var it = n.importPrimArray(c);
		var cmd = n.strCodeType(JawaFuncOpcode.INSTANCEOF.code, it);
		var fi = n.addFuncImport(cmd, SigDecl.new([ValueType.Abstract(jlo)], SigCache.arr_i));

		var r = n.process();
		if (r == null) return;

		var f = n.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.OBJECT)], SigCache.arr_i),
			r[fi.imp.import_index]);
		def run = Target.newInterpreter().run(100, f, _);

		def TRUE = v_r(i_v(1)), FALSE = v_r(i_v(0));
		t.assert_r(FALSE, run([t.rt.nullRef()]));
		t.assert_r(FALSE, run([t.rt.newObject(JawaTypes.OBJECT)]));

		for (i < cases.length) {
			var cc = cases[i];
			var got = run([cc.1]);
			if (cc.0 == c) {
				t.assert_r(TRUE, got);
			} else {
				t.assert_r(FALSE, got);
			}
		}
	}
}

def test_exe_instanceof3(t: JawaTester) {
	var inI = "I", jinI = JawaStrings.of(inI);
	var itI = JawaInterfaceType.new(jinI, []);
	itI.instanceMethods = [];
	t.env.add(itI);

	var cnA = "A", jcnA = JawaStrings.of(cnA);
	var ctA = JawaClassType.new(jcnA, t.NO_CLASS_ATTRS, JawaLang.OBJECT, [itI]);
	ctA.instanceFields = [];
	ctA.instanceMethods = [];
	ctA.finish(null);
	t.env.add(ctA);

	var jlo = t.importJawaLangObject();
	var it = t.importInterface(inI);
	var cmd = t.strCodeType(JawaFuncOpcode.INSTANCEOF.code, it);
	var fi = t.addFuncImport(cmd, SigDecl.new([ValueType.Abstract(jlo)], SigCache.arr_i));

	var r = t.process();
	if (r == null) return;

	var f = t.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.OBJECT)], SigCache.arr_i),
		r[fi.imp.import_index]);
	def run = Target.newInterpreter().run(100, f, _);

	var cases: Array<(Value, bool)> = [
		(t.rt.newArray(JawaTypes.BYTE_ARRAY, 3), false),
		(t.rt.newObject(ctA), true)
	];

	def TRUE = v_r(Values.I32_1), FALSE = v_r(Values.I32_0);

	t.assert_r(FALSE, run([t.rt.nullRef()]));
	t.assert_r(FALSE, run([t.rt.newObject(JawaTypes.OBJECT)]));

	for (c in cases) {
		var got = run([c.0]);
		if (c.1) {
			t.assert_r(TRUE, got);
		} else {
			t.assert_r(FALSE, got);
		}
	}
}

def test_exe_checkcast1(t: JawaTester) {
	var name = "Cce", jname = JawaStrings.of(name);
	var jlo = t.importJawaLangObject();
	var ict = t.declareClass(name, t.NO_CLASS_ATTRS, jlo, []);
	var xxx = t.defineClass(ict, [], [], [], []);
	var cmd = t.strCodeType(JawaFuncOpcode.CHECKCAST.code, ict);
	var fi = t.addFuncImport(cmd, SigDecl.new([ValueType.Abstract(jlo)], [ValueType.Abstract(ict)]));

	var r = t.process();
	if (r == null) return;
	var ct = t.assertIsJawaClassTypeWithName(jname, r[ict.imp.import_index]);
	if (ct == null) return;

	var f = t.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.OBJECT)], [t.toWasmType(ct)]), r[fi.imp.import_index]);
	def run = Target.newInterpreter().run(100, f, _);

	t.assert_r(Result.Value([t.rt.nullRef()]), run([t.rt.nullRef()]));
	t.assert_r(CCE, run([t.rt.newObject(JawaTypes.OBJECT)]));
	t.assert_r(CCE, run([t.rt.newArray(JawaTypes.FLOAT_ARRAY, 1)]));
	var ref = t.rt.newObject(ct);
	t.assert_r(v_r(ref), run([ref]));
}

def test_exe_checkcast2(t: JawaTester) {
	var cases = Vector<(JawaPrimArrayOpcodes, Value)>.new();
	for (c in JawaPrimArrayOpcodes) {
		cases.put(c, t.rt.newArray(c.arrayType, 1));
	}

	for (c in JawaPrimArrayOpcodes) {
		var n = t.dup();

		var jlo = n.importJawaLangObject();
		var it = n.importPrimArray(c);
		var cmd = n.strCodeType(JawaFuncOpcode.CHECKCAST.code, it);
		var fi = n.addFuncImport(cmd, SigDecl.new([ValueType.Abstract(jlo)], [ValueType.Abstract(it)]));

		var r = n.process();
		if (r == null) return;

		var f = n.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.OBJECT)], [t.toWasmType(c.arrayType)]),
			r[fi.imp.import_index]);
		def run = Target.newInterpreter().run(100, f, _);

		t.assert_r(Result.Value([t.rt.nullRef()]), run([t.rt.nullRef()]));
		t.assert_r(CCE, run([t.rt.newObject(JawaTypes.OBJECT)]));

		for (i < cases.length) {
			var cc = cases[i];
			var got = run([cc.1]);
			if (cc.0 == c) {
				t.assert_r(v_r(cc.1), got);
			} else {
				t.assert_r(CCE, got);
			}
		}
	}
}

def test_exe_checkcast3(t: JawaTester) {
	var inI = "I", jinI = JawaStrings.of(inI);
	var itI = JawaInterfaceType.new(jinI, []);
	itI.instanceMethods = [];
	t.env.add(itI);

	var cnA = "A", jcnA = JawaStrings.of(cnA);
	var ctA = JawaClassType.new(jcnA, t.NO_CLASS_ATTRS, JawaLang.OBJECT, [itI]);
	ctA.instanceFields = [];
	ctA.instanceMethods = [];
	ctA.finish(null);
	t.env.add(ctA);

	var jlo = t.importJawaLangObject();
	var it = t.importInterface(inI);
	var cmd = t.strCodeType(JawaFuncOpcode.CHECKCAST.code, it);
	var fi = t.addFuncImport(cmd, SigDecl.new([ValueType.Abstract(jlo)], [ValueType.Abstract(it)]));

	var r = t.process();
	if (r == null) return;

	var f = t.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.OBJECT)], [t.toWasmType(itI)]),
		r[fi.imp.import_index]);
	def run = Target.newInterpreter().run(100, f, _);

	var cases: Array<(Value, bool)> = [
		(t.rt.newArray(JawaTypes.BYTE_ARRAY, 3), false),
		(t.rt.newObject(ctA), true)
	];

	t.assert_r(Result.Value([t.rt.nullRef()]), run([t.rt.nullRef()]));
	t.assert_r(CCE, run([t.rt.newObject(JawaTypes.OBJECT)]));

	for (c in cases) {
		var got = run([c.0]);
		if (c.1) {
			t.assert_r(v_r(c.0), got);
		} else {
			t.assert_r(CCE, got);
		}
	}
}

def test_exe_monitorenter(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var fi = t.addFuncImport(t.strCode(JawaFuncOpcode.MONITORENTER.code), t.sig_x_v(ValueType.Abstract(jlo)));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(t.sig_x_v(t.toWasmType(JawaTypes.OBJECT)), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var ref = t.rt.newObject(JawaLang.OBJECT);
	t.assert_r(rNONE, i.run(100, f, [ref]));
	t.assert_r(NPE, i.run(100, f, [t.rt.nullRef()]));
}

def test_exe_monitorexit(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var fi = t.addFuncImport(t.strCode(JawaFuncOpcode.MONITOREXIT.code), t.sig_x_v(ValueType.Abstract(jlo)));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(t.sig_x_v(t.toWasmType(JawaTypes.OBJECT)), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	var ref = t.rt.newObject(JawaLang.OBJECT);
	t.assert_r(rNONE, i.run(100, f, [ref]));
	t.assert_r(NPE, i.run(100, f, [t.rt.nullRef()]));
}

def NO_INSTANCE_FIELDS: Array<(JawaString, JawaFieldAttr.set, JawaTypeRef)> = [];
def NO_STATIC_FIELDS = NO_INSTANCE_FIELDS;
def NO_INSTANCE_METHODS: Array<(JawaString, JawaMethodAttr.set, JawaSigRef, FuncDecl)> = [];

def test_exe_invokestatic1(t: JawaTester) {
	var className = "LoPan", jclassName = JawaStrings.of(className);
	var methodName = "m2", jmethodName = JawaStrings.of(methodName);
	var ct = JawaClassType.new(jclassName, t.NO_CLASS_ATTRS, null, []);
	var catcher = ArgCatcher.new(SigCache.v_i);
	ct.boilerplate = [];
	ct.instanceFields = [];
	ct.staticMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, catcher.host)];
	t.env.add(ct);
	var it = t.importRefType(ct);
	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKESTATIC.code, it, jmethodName,
		t.importSig(ct.staticMethods[0].sig));
	var fi = t.addFuncImport(str1, SigCache.v_i);

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(SigCache.v_i, r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);
	var args: Array<Value>;

	args = [];
	catcher.result = HostResult.Value1(Value.I32(33));
	t.assert_i(33, run(args));
	t.assert_r(Result.Value(args), Result.Value(catcher.args));

	catcher.result = HostResult.Value1(Value.I32(919));
	t.assert_i(919, run(args));
	t.assert_r(Result.Value(args), Result.Value(catcher.args));
}

def addInvokeStatic(t: JawaTester, jsig: JawaSigRef, sig: SigDecl, body: FuncDecl) -> FuncDecl {
	var name = [byte.view('C' + body.func_index)];
	var jname = JawaStrings.of(name);
	var m1 = "m", jm1 = JawaStrings.of(m1);
	var it = t.declareClass(name, t.NO_CLASS_ATTRS, null, []);

	t.defineClass(it,
		NO_INSTANCE_FIELDS, NO_INSTANCE_METHODS, NO_STATIC_FIELDS,
		[(jm1, t.NO_METHOD_ATTRS, jsig, body)]  // static methods
	);

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKESTATIC.code, it, jm1, jsig);
	return t.addFuncImport(str1, SigCache.i_i);
}

def test_exe_invokestatic2(t: JawaTester) {
	var g1 = byte.!(t.newGlobal(ValueType.I32, InitExpr.I32(42)).global_index);
	var f1 = t.newFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.GLOBAL_GET.code, g1,
		Opcode.I32_SUB.code
	]);

	var fi = addInvokeStatic(t,
		JawaSigRef.new([JawaTypeRef.Prim(JawaTypes.INT)], JawaTypeRef.Prim(JawaTypes.INT)),
		SigCache.i_i,
		f1);

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(SigCache.i_i, r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);

	t.assert_i(0, run([i_v(42)]));
	t.assert_i(42, run([i_v(84)]));
	t.assert_i(958, run([i_v(1000)]));
}

def test_exe_invokestatic3(t: JawaTester) {
	var g1 = byte.!(t.newGlobal(ValueType.I32, InitExpr.I32(29)).global_index);
	var f1 = t.newFunction(SigCache.i_i, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.GLOBAL_GET.code, g1,
		Opcode.I32_SUB.code
	]);

	var f2 = addInvokeStatic(t,
		JawaSigRef.new([JawaTypeRef.Prim(JawaTypes.INT)], JawaTypeRef.Prim(JawaTypes.INT)),
		SigCache.i_i,
		f1);

	var f3 = addInvokeStatic(t,
		JawaSigRef.new([JawaTypeRef.Prim(JawaTypes.INT)], JawaTypeRef.Prim(JawaTypes.INT)),
		SigCache.i_i,
		f2);

	var r = t.process();
	if (r == null) return;
	var f2i = t.assertIsFunction(SigCache.i_i, r[f2.imp.import_index]);
	var f3i = t.assertIsFunction(SigCache.i_i, r[f3.imp.import_index]);
	if (f2i == null) return;
	if (f3i == null) return;

	var i = Target.newInterpreter();

	t.assert_i(0, i.run(100, f2i, [i_v(29)]));
	t.assert_i(0, i.run(100, f3i, [i_v(29)]));

	t.assert_i(26, i.run(100, f2i, [i_v(55)]));
	t.assert_i(26, i.run(100, f3i, [i_v(55)]));

	t.assert_i(971, i.run(100, f2i, [i_v(1000)]));
	t.assert_i(971, i.run(100, f3i, [i_v(1000)]));
}

def test_exe_invokespecial(t: JawaTester) {
	var className = "Krug", jclassName = JawaStrings.of(className);
	var methodName = "far", jmethodName = JawaStrings.of(methodName);
	var ct = JawaClassType.new(jclassName, t.NO_CLASS_ATTRS, null, []);
	ct.boilerplate = [];
	ct.instanceFields = [];
	ct.instanceMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, null)];
	ct.staticMethods = [];
	t.env.add(ct);
	var catcher = ArgCatcher.new(SigDecl.new([t.rt.toWasmType(ct)], SigCache.arr_i));
	ct.instanceMethods[0].impl = catcher.host;
	var it = t.importRefType(ct);
	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKESPECIAL.code, it, jmethodName,
		 JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var fi = t.addFuncImport(str1, t.sig_x_i(ValueType.Abstract(it)));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(t.sig_x_i(t.toWasmType(ct)), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);
	var args: Array<Value>;

	var ref = t.rt.newObject(ct);
	args = [ref];
	catcher.result = HostResult.Value1(Value.I32(77));
	t.assert_i(77, run(args));
	t.assert_r(Result.Value(args), Result.Value(catcher.args));

	args = [ref];
	catcher.result = HostResult.Value1(Value.I32(99));
	t.assert_i(99, run(args));
	t.assert_r(Result.Value(args), Result.Value(catcher.args));
}

def test_exe_invokevirtual(t: JawaTester) {
	var methodName = "m", jmethodName = JawaStrings.of(methodName);

	var cnA = "A", jcnA = JawaStrings.of(cnA);
	var ctA = JawaClassType.new(jcnA, t.NO_CLASS_ATTRS, null, []);
	var catcherA = ArgCatcher.new(SigCache.r_i);
	ctA.boilerplate = [];
	ctA.instanceFields = [];
	ctA.instanceMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, catcherA.host)];
	ctA.staticMethods = [];
	var err = ErrorGen.new("");
	ctA.finish(err);
	t.t.assertz(true, err.ok());
	t.env.add(ctA);
	var itA = t.importClass(cnA);

	var cnB = "B", jcnB = JawaStrings.of(cnB);
	var ctB = JawaClassType.new(jcnB, t.NO_CLASS_ATTRS, null, []);
	var catcherB = ArgCatcher.new(SigCache.r_i);
	ctB.boilerplate = [];
	ctB.instanceFields = [];
	ctB.instanceMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, catcherB.host)];
	ctB.staticMethods = [];
	ctB.finish(err);
	t.t.assertz(true, err.ok());

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, itA, jmethodName,
		 JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var fi = t.addFuncImport(str1, t.sig_x_i(ValueType.Abstract(itA)));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(t.sig_x_i(t.toWasmType(ctA)), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);
	var args: Array<Value>;

	{
		var ref = t.rt.newObject(ctA);
		args = [ref];
		catcherA.result = HostResult.Value1(Value.I32(77));
		t.assert_i(77, run(args));
		t.assert_r(Result.Value(args), Result.Value(catcherA.args));

		args = [ref];
		catcherA.result = HostResult.Value1(Value.I32(99));
		t.assert_i(99, run(args));
		t.assert_r(Result.Value(args), Result.Value(catcherA.args));
	}
	{
		var ref = t.rt.newObject(ctB);
		args = [ref];
		catcherA.result = HostResult.Value1(Value.I32(55));
		catcherB.result = HostResult.Value1(Value.I32(66));
		t.assert_i(66, run(args));
		t.assert_r(Result.Value(args), Result.Value(catcherB.args));

		args = [ref];
		catcherB.result = HostResult.Value1(Value.I32(99));
		t.assert_i(99, run(args));
		t.assert_r(Result.Value(args), Result.Value(catcherB.args));
	}
}

def test_exe_invokeinterface(t: JawaTester) {
	var methodName = "m", jmethodName = JawaStrings.of(methodName);

	var inI = "I", jinI = JawaStrings.of(inI);
	var itI = JawaInterfaceType.new(jinI, []);
	itI.instanceMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, null)];
	t.env.add(itI);

	var cnA = "A", jcnA = JawaStrings.of(cnA);
	var ctA = JawaClassType.new(jcnA, t.NO_CLASS_ATTRS, null, [itI]);
	var catcherA = ArgCatcher.new(SigCache.r_i);
	ctA.boilerplate = [];
	ctA.instanceFields = [];
	ctA.instanceMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, catcherA.host)];
	ctA.staticMethods = [];
	var err = ErrorGen.new("");
	ctA.finish(err);
	t.t.assertz(true, err.ok());
	t.env.add(ctA);
	var iitI = t.importInterface(inI);

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEINTERFACE.code, iitI, jmethodName,
		JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var fi = t.addFuncImport(str1, t.sig_x_i(ValueType.Abstract(iitI)));

	var r = t.process();
	if (r == null) return;
	var f = t.assertIsFunction(t.sig_x_i(t.toWasmType(itI)), r[fi.imp.import_index]);
	if (f == null) return;

	var i = Target.newInterpreter();
	def run = i.run(100, f, _);
	var args: Array<Value>;

	{
		var ref = t.rt.newObject(ctA);
		args = [ref];
		catcherA.result = HostResult.Value1(Value.I32(77));
		t.assert_i(77, run(args));
		t.assert_r(Result.Value(args), Result.Value(catcherA.args));

		args = [ref];
		catcherA.result = HostResult.Value1(Value.I32(99));
		t.assert_i(99, run(args));
		t.assert_r(Result.Value(args), Result.Value(catcherA.args));
	}
}

def test_exe_overload1(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var c = JawaClassBuilder.new(t, "C", t.NO_CLASS_ATTRS, jlo, []);

	var idI = t.newFunction(SigCache.ii_i, [
		Opcode.LOCAL_GET.code, 0
	]);
	var idF = t.newFunction(SigCache.ff_f, [
		Opcode.LOCAL_GET.code, 1
	]);

	var ti = JawaTypeRef.Prim(JawaTypes.INT), tf = JawaTypeRef.Prim(JawaTypes.FLOAT);
	c.addStaticMethod("id", [ti, ti], ti, idI);
	c.addStaticMethod("id", [tf, tf], tf, idF);
	c.define();

	var new_c = c.NEW();

	var jid = JawaStrings.of("id");
	var invokestatic_idI = t.addFuncImport(
		t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKESTATIC.code, c.it, jid, JawaSigRef.new([ti, ti], ti)),
		 SigCache.ii_i);
	var invokestatic_idF = t.addFuncImport(
		t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKESTATIC.code, c.it, jid, JawaSigRef.new([tf, tf], tf)),
		 SigCache.ff_f);

	var r = t.process();
	if (r == null) return;

	var runI = t.assertIsFunction(SigCache.ii_i, r[invokestatic_idI.imp.import_index]);
	var runF = t.assertIsFunction(SigCache.ff_f, r[invokestatic_idF.imp.import_index]);

	var i = Target.newInterpreter();
	t.assert_i(456, i.run(100, runI, [i_v(456), i_v(654)]));
	t.assert_v(f_v(88), i.run(100, runF, [f_v(77), f_v(88)]));
}

def test_exe_object1(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var c = JawaClassBuilder.new(t, "C", t.NO_CLASS_ATTRS, jlo, []);

	var getF = t.newFunction(t.sig_x_i(c.at), []);
	var setF = t.newFunction(SigDecl.new([c.at, ValueType.I32], SigCache.arr_v), []);

	c.addInstanceField("f", JawaTypeRef.Prim(JawaTypes.INT));
	c.addInstanceField("g", JawaTypeRef.Prim(JawaTypes.FLOAT));
	c.addInstanceMethod("getF", [], JawaTypeRef.Prim(JawaTypes.INT), getF);
	c.addInstanceMethod("setF", [JawaTypeRef.Prim(JawaTypes.INT)], JawaTypeRef.Void, setF);
	c.define();

	var new_c = c.NEW();
	var getfield_f = c.GETFIELD("f");
	var getfield_g = c.GETFIELD("g");
	var setfield_f = c.PUTFIELD("f");
	var setfield_g = c.PUTFIELD("g");

	t.addCodeV(setF, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, byte.view(setfield_f.func_index)
	]);
	t.addCodeV(getF, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.CALL.code, byte.view(getfield_f.func_index)
	]);

	var run = t.newFunction(SigDecl.new([ValueType.I32, c.at], SigCache.arr_i), [
		Opcode.CALL.code, byte.view(new_c.func_index),
		Opcode.LOCAL_TEE.code, 1,
		Opcode.LOCAL_GET.code, 0,
		Opcode.CALL.code, byte.view(setF.func_index),
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, byte.view(getF.func_index)
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_i(456, i.run(100, f, [i_v(456), Values.REF_NULL]));
	t.assert_i(778899, i.run(100, f, [i_v(778899), Values.REF_NULL]));
}

def test_exe_object2(t: JawaTester) {
	def methodName = "hmm";
	var jlo = t.importJawaLangObject();
	var c = JawaClassBuilder.new(t, "C", t.NO_CLASS_ATTRS, jlo, []);
	var cm1 = t.newFunction(t.sig_x_i(c.at), [Opcode.I32_CONST.code, 33]);
	c.addInstanceMethod(methodName, [], JawaTypeRef.Prim(JawaTypes.INT), cm1);
	c.define();

	var d = JawaClassBuilder.new(t, "D", t.NO_CLASS_ATTRS, c.it, []);
	var dm1 = t.newFunction(t.sig_x_i(d.at), [Opcode.I32_CONST.code, 44]);
	d.addInstanceMethod(methodName, [], JawaTypeRef.Prim(JawaTypes.INT), dm1);
	d.define();

	var new_c = c.NEW();
	var new_d = d.NEW();
	var invokevirtual_m1 = c.INVOKEVIRTUAL(methodName);

	var run = t.newFunction(SigCache.i_i, []);
	t.addCodeV(run, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypeCode.ABS.code, byte.!(c.it.abstype_index),
		Opcode.CALL.code, byte.!(new_d.func_index),
		Opcode.ELSE.code,
		Opcode.CALL.code, byte.!(new_c.func_index),
		Opcode.END.code,
		Opcode.CALL.code, byte.!(invokevirtual_m1.func_index)
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_i(33, i.run(100, f, [i_v(0)]));
	t.assert_i(44, i.run(100, f, [i_v(1)]));
}

def test_exe_object3(t: JawaTester) {
	def methodName = "hJ", jmethodName = JawaStrings.of(methodName);

	var inI = "I", jinI = JawaStrings.of(inI);
	var itI = JawaInterfaceType.new(jinI, []);
	itI.instanceMethods = [JawaMethod.new(jmethodName, t.NO_METHOD_ATTRS, JawaSigCache.m_v_i, null)];
	t.env.add(itI);
	var iitI = t.importInterface(inI);

	var jlo = t.importJawaLangObject();
	var c = JawaClassBuilder.new(t, "C", t.NO_CLASS_ATTRS, jlo, [iitI]);
	var cm1 = t.newFunction(t.sig_x_i(c.at), [Opcode.I32_CONST.code, 22]);
	c.addInstanceMethod(methodName, [], JawaTypeRef.Prim(JawaTypes.INT), cm1);
	c.define();

	var d = JawaClassBuilder.new(t, "D", t.NO_CLASS_ATTRS, c.it, []);
	var dm1 = t.newFunction(t.sig_x_i(d.at), [Opcode.I32_CONST.code, 33]);
	d.addInstanceMethod(methodName, [], JawaTypeRef.Prim(JawaTypes.INT), dm1);
	d.define();


	var new_c = c.NEW();
	var new_d = d.NEW();
	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEINTERFACE.code, iitI, jmethodName,
		JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var invokeinterface_m1 = t.addFuncImport(str1, t.sig_x_i(ValueType.Abstract(iitI)));

	var run = t.newFunction(SigCache.i_i, []);
	t.addCodeV(run, [
		Opcode.LOCAL_GET.code, 0,
		Opcode.IF.code, BpTypeCode.ABS.code, byte.!(c.it.abstype_index),
		Opcode.CALL.code, byte.!(new_d.func_index),
		Opcode.ELSE.code,
		Opcode.CALL.code, byte.!(new_c.func_index),
		Opcode.END.code,
		Opcode.CALL.code, byte.!(invokeinterface_m1.func_index)
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_i(22, i.run(100, f, [i_v(0)]));
	t.assert_i(33, i.run(100, f, [i_v(1)]));
}

def test_exe_object4(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var c = JawaClassBuilder.new(t, "Cxx", t.NO_CLASS_ATTRS, jlo, []);
	c.addInstanceField("f", JawaTypeRef.Prim(JawaTypes.INT));
	c.define();

	var d = JawaClassBuilder.new(t, "Dyy", t.NO_CLASS_ATTRS, c.it, []);
	d.addInstanceField("g", JawaTypeRef.Prim(JawaTypes.FLOAT));
	d.define();

	var new_d = d.NEW();
	var getfield_f = c.GETFIELD("f");
	var getfield_g = d.GETFIELD("g");
	var setfield_f = c.PUTFIELD("f");
	var setfield_g = d.PUTFIELD("g");

	var run = t.newFunction(SigCache.f_f, [
		Opcode.CALL.code, byte.view(new_d.func_index),
		Opcode.LOCAL_TEE.code, 1,
		Opcode.LOCAL_GET.code, 0,
		Opcode.CALL.code, byte.view(setfield_g.func_index),
		Opcode.LOCAL_GET.code, 1,
		Opcode.I32_CONST.code, 11,
		Opcode.CALL.code, byte.view(setfield_f.func_index),
		Opcode.LOCAL_GET.code, 1,
		Opcode.CALL.code, byte.view(getfield_g.func_index)
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_r(f_r(456), i.run(100, f, [f_v(456)]));
	t.assert_r(f_r(778899), i.run(100, f, [f_v(778899)]));
}

def test_exe_ref_null(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var sig = SigDecl.new(SigCache.arr_v, [ValueType.Abstract(jlo)]);
	var run = t.newFunction(sig, []);
	t.addCodeV(run, [
		Opcode.REF_NULL.code, BpTypeCode.EXTERNREF.code
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_r(v_r(t.rt.nullRef()), i.run(100, f, []));
}

def test_exe_local(t: JawaTester) {
	var jlo = t.importJawaLangObject();
	var sig = SigDecl.new(SigCache.arr_v, [ValueType.Abstract(jlo)]);
	var run = t.newFunction(sig, []);
	t.addCodeV_extra_raw(run, [
		1, 1, BpTypeCode.ABS.code, byte.view(jlo.abstype_index),
		Opcode.LOCAL_GET.code, 0,
		Opcode.END.code
	]);

	var instance = t.instantiate();
	if (instance == null) return;

	var i = Target.newInterpreter();
	var f = instance.functions[run.func_index];

	t.assert_r(v_r(t.rt.nullRef()), i.run(100, f, []));
}

def test_Object_init(t: JawaTester) {
	var initName = "<init>", jinitName = JawaStrings.of(initName);
	var jlo = t.importJawaLangObject();
	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jinitName,
		JawaSigRef.new([], JawaTypeRef.Void));
	var sig = t.sig_x_v(ValueType.Abstract(jlo));
	var fi = t.addFuncImport(str1, sig);
	var r = t.process();
	if (r == null) return;

	var f = t.assertIsFunction(t.sig_x_v(t.toWasmType(JawaTypes.OBJECT)), r[fi.imp.import_index]);

	var i = Target.newInterpreter();
	t.assert_r(rNONE, i.run(10, f, [t.rt.newObject(JawaLang.OBJECT)]));
	t.assert_r(rNONE, i.run(10, f, [t.rt.newObject(JawaLang.OBJECT)]));
}

def test_Object_equals(t: JawaTester) {
	var eqName = "equals", jeqName = JawaStrings.of(eqName);
	var jlo = t.importJawaLangObject();
	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jeqName,
		JawaSigRef.new([JawaTypeRef.Abstract(jlo)], JawaTypeRef.Prim(JawaTypes.BOOL)));
	var sig = t.sig_xx_i(ValueType.Abstract(jlo));
	var fi = t.addFuncImport(str1, sig);
	var r = t.process();
	if (r == null) return;

	var expected_sig = t.sig_xx_i(t.toWasmType(JawaTypes.OBJECT));
	var f = t.assertIsFunction(expected_sig, r[fi.imp.import_index]);

	var i = Target.newInterpreter();
	var n = t.rt.nullRef();
	var args = [t.rt.newObject(JawaLang.OBJECT), t.rt.newObject(JawaLang.OBJECT), n];
	for (x in args) {
		for (y in args) {
			if (x == n) {
				t.assert_r(NPE, i.run(10, f, [x, y]));
			} else {
				var expected = if(x == y, i_r(1), i_r(0));
				t.assert_r(expected, i.run(10, f, [x, y]));
			}
		}
	}
}

def test_Object_hashCode(t: JawaTester) {
	var eqName = "hashCode", jeqName = JawaStrings.of(eqName);
	var jlo = t.importJawaLangObject();
	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jeqName,
		JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var sig = t.sig_x_i(ValueType.Abstract(jlo));
	var fi = t.addFuncImport(str1, sig);
	var r = t.process();
	if (r == null) return;

	var expected_sig = t.sig_x_i(t.toWasmType(JawaTypes.OBJECT));
	var f = t.assertIsFunction(expected_sig, r[fi.imp.import_index]);

	var i = Target.newInterpreter();
	var n = t.rt.nullRef();
	t.assert_r(NPE, i.run(10, f, [n]));
	i.run(10, f, [t.rt.newObject(JawaLang.OBJECT)]); // actual hashcode doesn't matter
}

def test_String_equals(t: JawaTester) {
	var eqName = "equals", jeqName = JawaStrings.of(eqName);
	var jlo = t.importJawaLangObject();
	var jls = t.importJawaLangString();

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jeqName,
		JawaSigRef.new([JawaTypeRef.Abstract(jlo)], JawaTypeRef.Prim(JawaTypes.BOOL)));
	var sig1 = t.sig_xx_i(ValueType.Abstract(jlo));
	var f1 = t.addFuncImport(str1, sig1);

	var str2 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jls, jeqName,
		JawaSigRef.new([JawaTypeRef.Abstract(jlo)], JawaTypeRef.Prim(JawaTypes.BOOL)));
	var sig2 = SigDecl.new([ValueType.Abstract(jls), ValueType.Abstract(jlo)], SigCache.arr_i);
	var f2 = t.addFuncImport(str2, sig2);

	var r = t.process();
	if (r == null) return;

	var hf1 = t.assertIsFunction(t.sig_xx_i(t.toWasmType(JawaTypes.OBJECT)), r[f1.imp.import_index]);
	var hf2 = t.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.STRING),
		 t.toWasmType(JawaLang.OBJECT)], SigCache.arr_i), r[f2.imp.import_index]);

	if (hf1 == null) return;
	if (hf2 == null) return;

	var i = Target.newInterpreter();
	var array = [
		(1, t.rt.newObject(JawaLang.OBJECT)),
		(2, t.rt.stringRep.toWasm(JawaStrings.of("foo"))),
		(2, t.rt.stringRep.toWasm(JawaStrings.of("foo"))),
		(3, t.rt.stringRep.toWasm(JawaStrings.of("bar"))),
		(0, t.rt.nullRef())];
	for (x in array) {
		for (y in array) {
			var got1 = i.run(10, hf1, [x.1, y.1]);
			var got2 = i.run(10, hf2, [x.1, y.1]);
			if (x.0 == 0) {
				t.assert_r(NPE, got1);
				t.assert_r(NPE, got2);
			} else {
				var expected = if(x.0 == y.0, i_r(1), i_r(0));
				t.assert_r(expected, got1);
				t.assert_r(expected, got2);
			}
		}
	}
}

def test_String_hashCode(t: JawaTester) {
	var eqName = "hashCode", jeqName = JawaStrings.of(eqName);
	var jlo = t.importJawaLangObject();
	var jls = t.importJawaLangString();

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jeqName,
		JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var sig1 = t.sig_x_i(ValueType.Abstract(jlo));
	var f1 = t.addFuncImport(str1, sig1);

	var str2 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jls, jeqName,
		JawaSigRef.new([], JawaTypeRef.Prim(JawaTypes.INT)));
	var sig2 = SigDecl.new([ValueType.Abstract(jls)], SigCache.arr_i);
	var f2 = t.addFuncImport(str2, sig2);

	var r = t.process();
	if (r == null) return;

	var hf1 = t.assertIsFunction(t.sig_x_i(t.toWasmType(JawaTypes.OBJECT)), r[f1.imp.import_index]);
	var hf2 = t.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.STRING)], SigCache.arr_i), r[f2.imp.import_index]);

	if (hf1 == null) return;
	if (hf2 == null) return;

	var s1 = JawaStrings.of("foox"), s2 = JawaStrings.of("foox"), s3 = JawaStrings.of("b");
	var i = Target.newInterpreter();
	var array = [
		(-1, t.rt.newObject(JawaLang.OBJECT)),
		(int.view(s1.hashCode()), t.rt.stringRep.toWasm(s1)),
		(int.view(s2.hashCode()), t.rt.stringRep.toWasm(s2)),
		(int.view(s3.hashCode()), t.rt.stringRep.toWasm(s3)),
		(-2, t.rt.nullRef())
	];
	for (x in array) {
		var got1 = i.run(10, hf1, [x.1]);
		var got2 = i.run(10, hf2, [x.1]);
		if (x.0 == -2) {
			t.assert_r(NPE, got1);
			t.assert_r(NPE, got2);
		} else if (x.0 == -1) {
			t.assert_r(got1, got2);
		} else {
			var expected = i_r(x.0);
			t.assert_r(expected, got1);
			t.assert_r(expected, got2);
		}
	}
}

def test_Object_getClass1(t: JawaTester) {
	var methName = "getClass", jmethName = JawaStrings.of(methName);
	var jlo = t.importJawaLangObject();
	var jlc = t.importJawaLangClass();

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jmethName,
		JawaSigRef.new([], JawaTypeRef.Abstract(jlc)));
	var sig1 = SigDecl.new([ValueType.Abstract(jlo)], [ValueType.Abstract(jlc)]);
	var f1 = t.addFuncImport(str1, sig1);

	var r = t.process();
	if (r == null) return;

	var hf1 = t.assertIsFunction(SigDecl.new([t.toWasmType(JawaLang.OBJECT)], [t.toWasmType(JawaLang.CLASS)]), r[f1.imp.import_index]);

	var i = Target.newInterpreter();
	var cases = [
		(t.rt.newObject(JawaLang.OBJECT),
			t.rt.classRep.toWasm(JawaLang.OBJECT)),
		(t.rt.stringRep.toWasm(JawaStrings.of("foo")),
			t.rt.classRep.toWasm(JawaLang.STRING)),
		(t.rt.classRep.toWasm(JawaLang.OBJECT),
			t.rt.classRep.toWasm(JawaLang.CLASS))
	];
	for (c in cases) {
		var got1 = i.run(10, hf1, [c.0]);
		t.assert_v(c.1, got1);
	}
	t.assert_r(NPE, i.run(10, hf1, [t.rt.nullRef()]));
}

def test_Object_getClass2(t: JawaTester) {
	var cases = Vector<(Value, Value)>.new();
	for (c in JawaPrimArrayOpcodes) {
		cases.put(t.rt.newArray(c.arrayType, 3), t.rt.classRep.toWasm(c.arrayType));
	}
	for (ct in [JawaLang.OBJECT, JawaLang.STRING]) {
		var at = ct.arrayOf();
		cases.put(t.rt.newArray(at, 2), t.rt.classRep.toWasm(at));
	}
	var methName = "getClass", jmethName = JawaStrings.of(methName);
	var jlo = t.importJawaLangObject();
	var jlc = t.importJawaLangClass();

	var str1 = t.strCodeTypeJawaNameSig(JawaFuncOpcode.INVOKEVIRTUAL.code, jlo, jmethName,
		JawaSigRef.new([], JawaTypeRef.Abstract(jlc)));
	var sig1 = SigDecl.new([ValueType.Abstract(jlo)], [ValueType.Abstract(jlc)]);
	var f1 = t.addFuncImport(str1, sig1);

	var r = t.process();
	if (r == null) return;

	var hf1 = t.assertIsFunction(
		SigDecl.new([t.toWasmType(JawaLang.OBJECT)], [t.toWasmType(JawaLang.CLASS)]),
		r[f1.imp.import_index]);

	var i = Target.newInterpreter();
	for (c in cases.extract()) {
		var got1 = i.run(10, hf1, [c.0]);
		t.assert_v(c.1, got1);
	}
}

// TODO	ATHROW
// TODO	DCMPG
// TODO	DCMPL
// TODO	DREM
// TODO	FCMPG
// TODO	FCMPL
// TODO	FREM
// TODO	INVOKEDYNAMIC
